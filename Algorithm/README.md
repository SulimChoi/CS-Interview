# :bookmark_tabs: Algorithm      

* [Dynamic Programming](#dynamic-programming)   
  - [Fibonacci 공식을 재귀, DP, 반복문으로 구현 시 차이점](#fibonacci-공식을-재귀-동적계획법-반복문으로-구현-시-차이점)
* [Graph](#graph)   
  - [DFS, BFS](#그래프-탐색)   
  - [DAG](#dag)   
  - [Tree](#tree)   
  - [MST](#minimum-spanning-tree)   
  - [](#)   
* [Union Find](#union-find)   
* [Greedy](#그리디-알고리즘)   
* [분할 정복](#분할-정복)   
* [이분 탐색](#이분-탐색)   
* [문자열 알고리즘](#문자열-알고리즘)  
  - [KMP(Knuth, Morris, Prett)](#kmpknuth-morris-prett)   
  - [Trie](#trie)   

## Dynamic Programming   
- __큰 문제를 작은 문제로 나눠서 푸는 알고리즘__   
  - __만족해야 하는 2가지 속성__   
    - __Overlapping Subproblem__   
      - __큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.__   
      - __문제를 작은 문제로 쪼갤 수 있다.__   
      - __ex) 피보나치 수 F(n) = F(n-1) + F(n-2)을 구할 경우   
      F(n-1), F(n-2)를 구해야 하는데   
      F(n-1)을 구할 경우 F(n-1) = F(n-2) + F(n-3)   
      F(n-2)을 구할 경우 F(n-2) = F(n-3) + F(n-4)로 문제가 쪼개지게 된다.__   
      - 
    - __Optimal Substructure__   
      - __문제의 정답을 작은 문제의 정답에서 구할 수 있다.__    
      - __ex) 피보나치 수 F(n) = F(n-1) + F(n-2)을 구할 경우   
      작은 문제 F(n-1), F(n-2)를 합하여 F(n)을 구할 수 있다.__   
      - __이 규칙이 만족된다면, 문제에 상관없이 같은 문제에 대한 답은 똑같다__   
        - F(5) = F(4) + F(3) = (F(3) + __F(2)__ ) + (__F(2)__ + F(1))    
          F(4) = F(3) + F(2) = (__F(2)__ + F(1)) + __F(2)__   
          F(3) = __F(2)__ + F(1)  
          __F(2)의 값은 항상 같다.    
          그러므로 문제에 대한 정답이 한 번 구해지면 Memoization 배열에 저장하여 같은 문제를 구할 때 계산하지 않고 배열에 저장된 값을 불러와 사용한다.   
          즉, Dynamic Programming은 각 문제를 한 번만 풀면 된다.__   
          
  - __Top-down__   
    - __큰 문제를 작은 문제로 나누면서 재귀적으로 푸는 방식__   
      1 - 가장 큰 문제에서 작은 문제를 재귀적으로 호출한다.   
      2 - 가장 작은 문제가 호출되면 해당 문제를 푼다.    
      3 - 푼 작은 문제를 리턴하여 그 값을 가지고 점차적으로 큰 문제를 해결한다.      
        
  - __Bottom-up__   
    - __작은 문제부터 큰 문제로 해결해나가는 반복문으로 푸는 방식__   
      1 - 제일 크기가 작은 문제부터 푼다.   
      2 - 푼 작은 문제를 통해 점차적으로 큰 문제를 푼다.      
      
### Fibonacci 공식을 재귀, 동적계획법, 반복문으로 구현 시 차이점   
  - __재귀__   
    - 함수 내에서 2개의 함수를 호출하기 때문에 지수적으로 증가해 __O(2^n)__ 라는 시간복잡도를 가진다.   
  - __반복문__   
    - 작은 순서부터 차례대로 값을 만들어가고 만들어진 값에 이전의 값을 더해나가는 방식이기 때문에 __O(n)__ 이라는 시간복잡도를 가진다.   
  - __Dynamic Programming__    
    - __memoization__ 을 사용하여 한번 계산된 문제를 저장하여 나중에 같은 문제가 나왔을 시 계산하지 않고 해당 값을 사용하여 중복된 문제에 대한 계산 시간을 줄이는 방식으로 __O(n)__ 이라는 시간복잡도를 가진다.   
  - __동적계획법은 재귀, 반복 두 가지 방식이 다 가능하고 같은 시간복잡도 O(n)을 가지지만 재귀적인 방법 같은 경우 함수를 계속 호출하는데 오버헤드가 발생하기 때문에 반복적인 방식에 비해 오래 걸린다.__
  -	__n이 작을 때는 3가지 방법의 속도에서 큰 차이를 보이지 않지만 30이 넘어가면 재귀 방식이 느려지는 것을 느낄 수 있다.__

## Graph   
  - __Graph__   
    - 자료구조의 일종   
    - 정점(Node,Vertex), 간선(Edge)로 구성   
      - 두 정점 사이에 여러 개의 간선이 존재할 수 있다.   
    - __방향 있는 그래프__    
      - A->B 같이 방향이 있는 Directed Graph   
    - __방향 없는 그래프__   
      - A-B 같이 방향이 없는 Undirected Graph로 Bidirection Graph라고도 한다.   
    - __차수__    
      - 정점과 연결되어 있는 간선의 개수   
      - 방향 그래프의 경우 In-degree(정점으로 들어오는 간선의 수), Out-degree(정점에서 나가는 간선의 수)로 나누어 차수를 계산한다.   
    - __표현 방법__   
      - __인접 행렬__   
        - 정점의 개수 V일 경우 V x V 크기의 이차원 배열 사용 A[V][V], 공간복잡도 V^2   
        - A[i][j] = w (정점 i -> 정점 j로 가는 간선이 있을 경우, 그 가중치), 0 (없을 경우)   
        - 연결되지 않은 정점에 대한 공간도 할당되기 때문에 공간이 낭비된다.   
      - __인접 리스트__   
        - 정점의 개수 V일 경우 V 크기의 리스트 사용 A[V], 공간복잡도 E   
        - 리스트는 크기를 동적으로 변경할 수 있어야 하기 때문에 링크드 리스트나, 길이를 동적으로 변경할 수 있는 배열 사용    
        - A[i] = (i,w) (정점 i에 연결된 정점과 그 간선의 가중치)       

### 그래프 탐색    
  - __하나의 정점으로부터 시작하여 모든 정점들을 한 번씩 방문하는 것__   
  - __DFS(Depth First Search)__   
    - __깊이 우선 탐색__   
    - __`스택`을 이용하여 갈 수 있는 만큼 최대한 많이 가고 갈 수 없으면 이전 정점으로 돌아와 다른 방향으로 다시 탐색하는 방식__      
    - __재귀적 방식__   
    - __모든 곳을 방문할 시 주로 사용__   
  
  - __BFS(Breadth First Search)__   
    - __너비 우선 탐색__    
    - __`큐`를 이용하여 지금 위치에서 인접한 곳을 모두 방문하고 방문한 곳으로부터 인접한 곳을 모두 방문하며 탐색하는 방식__    
    - __방문했는지 확인을 위한 배열 필요__   
    - __가중치가 1일 때 최단 경로를 찾을 경우 주로 사용하지만 모든 곳을 방문할 시 DFS처럼 사용 가능하다.__   
    - 인접 행렬로 구현한 시간복잡도(V^2)   
    - 인접 리스트로 구현한 시간복잡도(V+E)   

### DAG   
  - __DAG(Directed Acyclic Graph)__   
    - 사이클이 없는 방향있는 그래프   
    
  - __위상 정렬(Topological sort)__   
    - __그래프의 간선 U -> V가 U가 V보다 먼저라는 의미일 때 정점의 순서를 찾는 알고리즘__   
      - DAG에서만 위상정렬이 가능하다.   
        - 사이클이 없기 떄문이다.   
    - 순서에 추가되는 정점은 in-degree가 0일 때로 표현할 수 있다.   
    - __BFS로 응용해서 구현한다.__   
      - __정점의 in-degree가 0일 때 큐에 추가한다.__   
    - __DFS로도 응용해서 구현할 수 있다.__   
      - 그래프의 간선을 모두 반대방향으로 뒤집고 DFS를 수행하여 정점이 스택에서 빠져나오는 순서를 기록하면 위상 정렬의 순서와 같아진다.   
        - 정점이 스택에서 빠져나온다는 것은 더 이상 방문할 수 있는 정점이 없다는 것을 의미한다.   
      
### Tree   
  - __Tree__   
    - __사이클이 없는 연결 그래프__   
    - 정점의 개수 : V, 간선의 개수 : V-1   
      - 모든 정점이 연결되어 있어야 한다.   
    - __부모, 자식 관계__   
    - 깊이(depth)
      - 루트에서부터 거리   
      - 루트의 깊이를 0 또는 1로 한다.   
    - 높이   
      - 깊이 중 가장 큰 값   
    - 리프 노드(단말 정점)   
      - 자식 노드가 없는 노드   
      
    - __조상, 자손__   
      - 조상 : 자신을 포함한 부모들   
      - 자손 : 자신을 포함한 자식들   
      
    - __이진 트리__   
      - __자식을 최대 2개만 가지고 있는 트리__   
      
    - __포화 이진 트리__   
      - 리프 노드를 제외한 노드의 자식의 수 : 2   
      - 리프 노드의 자식의 수 : 0   
      - __모든 리프 노드의 깊이가 같아야 한다.__   
      - __높이가 h인 트리의 노드 개수 = 2^h - 1__   
      
    - __완전 이진 트리__   
      - 리프 노드를 제외한 노드의 자식의 수 : 2   
      - 리프 노드의 자식의 수 : 0   
      - __마지막 레벨에는 노드의 일부가 없을 수도 있다.__   
        - 오른쪽에서부터 몇 개가 사라진 형태    
        
    - __트리의 순회__   
      - __DFS로 순회하는 3가지 방법__   
        - __전위 순회__   
          - Current -> Left -> Right      
        - __중위 순회__   
          - Left -> Current -> Right   
        - __후위 순회__    
          - Left -> Right -> Current   
          
    - __트리의 탐색__   
      - BFS로 구할 수 있다.   
        - 트리는 사이클이 없는 그래프이기 때문에 임의의 두 정점 사이의 경로가 1개이기 때문이다.   
        - 따라서, BFS 알고리즘을 이용해서 최단 거리를 구할 수 있다.   
        - 경로가 1개라 찾은 경로가 최단 경로    

### Minimum Spanning Tree   
  - __Spanning Tree__   
    - __그래프에서 일부 간선을 선택해 만든 트리__   
  
  - __Minimum Spanning Tree__   
    - __Spanning Tree 중 선택한 간선의 가중치의 합이 최소인 트리__   
    
    - __Prim__    
      - __정점을 이용하여 MST를 구하는 알고리즘__   
      - __순서__  
        __1. 그래프에서 아무 정점 선택__   
        __2. 선택한 정점 u와 선택하지 않은 정점 v를 연결하는 간선 중에 최소값을 고른다. 이 간선을 (u,v)라고 한다.__   
        __3. 선택한 간선을 MST에 추가하고, v를 선택한다.__   
        __4. 모든 정점을 선택하지 않았다면, 2번 단계로 돌아간다.__   
      - __각각의 정점을 선택하고 모든 간선을 살펴봐야 한다.__   
        - 시간복잡도 = O(V*E), 최악 시간복잡도 = O(V^2)   
        - __최소 값을 우선 순위 큐 또는 힙을 이용하면 시간 복잡도 = O(E * logE)가 된다.__    
          - 최소 힙 또는 우선 순위 큐 push/pop 연산 O(logE) * 모든 간선을 확인하기 위해 우선순위 큐에 간선을 push하는 연산 E번, 확인을 위해 pop하는 연산이 최대 E번 수행되므로 O(E)   
      - __그래프에 간선이 많이 존재하는 ‘밀집 그래프(Dense Graph)’ 의 경우는 Prim 알고리즘이 적합하다.__   
      
    - __Kruskal__   
      - __간선을 이용하여 MST를 구하는 알고리즘__   
      - __가중지가 작은 간선부터 순서대로 살펴본다.__   
      - __집합을 구분하기 위해 Union Find 알고리즘을 사용한다.__   
      - __순서__   
        __1. 가장 작은 가중치를 가진 간선을 MST에 추가한다.__   
        __2. 그 다음 작은 가중치를 가진 간선을 확인 후 간선 e가 (u, v, c)일 때, u와 v가 다른 집합이면 e를 MST에 추가한다.__   
        __3. 위의 과정을 반복한다.__   
      - __모든 간선을 살펴봐야 한다.__    
        - __최소 값을 우선 순위 큐 또는 힙을 이용하면 시간 복잡도 = O(E * logE)가 된다.__    
          - 최소 힙 또는 우선 순위 큐 push/pop 연산 O(logE) * 모든 간선을 확인하기 위해 우선순위 큐에 간선을 push하는 연산 E번, 확인을 위해 pop하는 연산이 최대 E번 수행되므로 O(E)   
      - __그래프 내에 적은 숫자의 간선만을 가지는 ‘희소 그래프(Sparse Graph)’의 경우 Kruskal 알고리즘이 적합하다.__   

## Union Find   
  - __Union Find__   
    - 상호배타적 집합(Disjoint-set)이라고 한다.   
    
    - __2가지 연산__   
      - __Find(x)__   
        - x가 어떤 집합에 포함되어 있는지 찾는 연산, 루트를 찾는 연산으로 볼 수 있다.   
      - __Union(x,y)__   
        - x, y가 포함되어 있는 집합을 합치는 연산   
        - __y의 부모를 x로 만든다__   
          - parent[y] = x   
          
    - __구현은 트리를 이용한다.__   
      - parent[i] = i의 부모   
      - parent[i] == i 이면, 루트   
      
    - __문제점__   
      - __원소 갯수가 N일 때, Union()과 Find()의 시간복잡도 = O(N)이다.__   
        - __경로 압축을 통해서 시간복잡도를 O(logN)으로 줄일 수 있다.__   
          - __Find 하면서 만난 모든 값의 부모 노드를 root로 만든다__   
          
      - __경로 압축을 사용하면 Union을 구현할 때, 트리의 랭크(높이)가 다른 값을 가질 수도 있다.__   
        - __따라서, 랭크가 작은 것을 랭크가 높은 것의 자식으로 만듦으로써 시간복잡도를 O(α(N))로 줄일 수 있다.__   
        - __α는 애커만 역함수(Inverse Ackermann Function)라고 하는데 N < 2^65536이면 5보다 작다.__   

## 그리디 알고리즘   
  - __그리디 알고리즘__   
    - __현재 가장 좋다고 생각되는 것을 선택하면서 답을 찾아가는 알고리즘__   
      - __현재는 최적의 답일 수 있지만, 최종적으로는 답이 최적이 아닐 수도 있다.__    
      - ex) 동전 1, 4, 5원짜리가 있는데 사용하는 동전의 개수를 최소로 해야 할 경우      
        - 12원을 거슬러주는 경우   
        - 5원 x 2개 = 10원 , 1원 x 2개 = 2원 으로 총 4개의 동전이 필요하다.   
        - 하지만 정답은 4원 x 3개 = 12원 이다.   

      - __왜 최적이 되는지를 증명해야하기 때문에 가장 어려운 알고리즘이다.__    
      
## 분할 정복   
  - __분할 정복__   
    - __분할 : 문제를 2개 이상의 작은 부분 문제로 나눈 다음 해결하는 것__   
    - __정복 : 해결한 문제를 다시 합쳐서 정답을 구하는 것__   
    - ex) 퀵 소트, 머지 소트, 큰 수 곱셈(카라추바 알고리즘), FFT   
    - __분할 정과 DP는 문제를 작은 부분으로 나눈 다는 것을 동일하지만 같은 문제가 중복되어서 나오지는 않는다__    
      - 분할 정복 : 같은 문제 중복 X   
      - DP : 중복된 문제를 Memoization으로 해결   
      
## 이분 탐색   
  - __이분 탐색__   
    - __정렬되어 있는 리스트에서 어떤 값을 빠르게 찾는 알고리즘__   
      - __어떤 값을 찾으려고 할 때, 가능 여부를 판별하는 방식으로하여 답을 찾을 수 있다.__   
      - ex) A에서 B까지 가는 가장 빠른 시간이 M인 경우   
        - M보다 작은 값은 모두 불가능   
        - M보다 큰 값은 모두 가능   

      - __가능 여부를 판별하는 문제도 값을 구하는 문제로 바꿀 수 있다.__    
      - ex) A에서 B까지 X라는 시간으로 이동할 수 있나?   
        - A에서 B까지 1이라는 시간으로 이동할 수 있나? 불가능   
        - A에서 B까지 2이라는 시간으로 이동할 수 있나? 불가능   
        - A에서 B까지 3이라는 시간으로 이동할 수 있나? 가능   
        - A에서 B까지 4이라는 시간으로 이동할 수 있나? 가능   
        - __A에서 B로 이동하는 가장 빠른 시간은 3이다.   

      - __즉, 어떤 기준 X를 가지고 YES / NO 로 나누어지는 것만 정답을 찾을 수 있다.__    

    - __정답을 찾는 과정__   
      ①. 가능한 정답의 최솟값 설정 - Left    
      ②. 가능한 정답의 최댓값 설정 - Right     
      ③. 최솟값과 최댓값의 중간 값으로 정답을 설정 - Mid = (Left + Right) / 2   
      ④. 정답을 하나 결정했을 때, 문제의 조건에 맞는 지 검사하는 함수 - check(Mid)       
      ⑤. 조건에 맞는 경우, 정답을 더 크게 해야 하는지 작게 해야 하는 지 결정 - Left = Mid ~~ 또는 Right = Mid ~~   

    - __최대값의 최소값을 구하는 문제는 보통 이분 탐색을 이용해서 정답을 찾는다.__   

    - __리스트 크기가 N 일 때, 시간복잡도 = O(log N)__   

    - __Upper Bound(상한)__   
      - 찾고자 하는 값보다 큰 값이 처음 나타나는 위치      

    - __Lower Bound(하한)__   
      - 찾고자 하는 값 이상의 값이 처음 나타나는 위치     

## 문자열 알고리즘          
### KMP(Knuth, Morris, Prett)      
  - __문자열 S에서 패턴 문자열 P를 찾을 때 사용하는 알고리즘__        
    - __패턴 문자열 P는 자신의 부분 문자열 패턴을 알아내기 위해 배열을 이용한다.__   
      - __pi[i] = 패턴 문자열 P의 i까지 부분 문자열에서 prefix(접두사) == suffix(접미사)가 될 수 있는 부분 문자열 중 가장 긴 것의 길이를 저장__     
      - __P에 대한 부분 문자열 검사하는데 걸리는 시간복잡도 = O(P)__   
    - __배열 pi를 이용하여 문자열 S와 패턴 문자열 P를 비교한다.__   
      - __최종 시간복잡도 = O(S+P)__   

### Trie   
  - __문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조__   
    - __문자열 N개 중에서 문자열 S를 찾을 때 사용하는 알고리즘__   
    - __빠르게 탐색이 가능하다는 장점이 있지만 각 노드에서 자식들에 대한 포인터들을 배열로 모두 저장하고 있다는 점에서 저장 공간의 크기가 크다는 단점이 있다.__
    - __총 문자열 수를 N, 제일 긴 문자열의 길이를 L이라 할 때 시간복잡도__   
      - 생성 시, 시간복잡도 = O(N*L)   
        - 삽입 자체의 시간복잡도 = O(L)   
      - 탐색 시, 시간복잡도 = O(L)   
      
    - ex) 검색어 자동 완성, 사전 찾기, 문자열 검사 등      
