# :bookmark_tabs: Algorithm      

* [Dynamic Programming](#dynamic-programming)   
  - [Fibonacci 공식을 재귀, DP, 반복문으로 구현 시 차이점](#fibonacci-공식을-재귀-동적계획법-반복문으로-구현-시-차이점)
* [](#)   
   - [](#)   
   - [](#)   
   - [](#)   
* [](#)   
   - [](#)   
   - [](#)   
   - [](#)   
      
   
## Dynamic Programming   
- __큰 문제를 작은 문제로 나눠서 푸는 알고리즘__   
  - __만족해야 하는 2가지 속성__   
    - __Overlapping Subproblem__   
      - __큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.__   
      - __문제를 작은 문제로 쪼갤 수 있다.__   
      - __ex) 피보나치 수 F(n) = F(n-1) + F(n-2)을 구할 경우   
      F(n-1), F(n-2)를 구해야 하는데   
      F(n-1)을 구할 경우 F(n-1) = F(n-2) + F(n-3)   
      F(n-2)을 구할 경우 F(n-2) = F(n-3) + F(n-4)로 문제가 쪼개지게 된다.__   
      - 
    - __Optimal Substructure__   
      - __문제의 정답을 작은 문제의 정답에서 구할 수 있다.__    
      - __ex) 피보나치 수 F(n) = F(n-1) + F(n-2)을 구할 경우   
      작은 문제 F(n-1), F(n-2)를 합하여 F(n)을 구할 수 있다.__   
      - __이 규칙이 만족된다면, 문제에 상관없이 같은 문제에 대한 답은 똑같다__   
        - F(5) = F(4) + F(3) = (F(3) + __F(2)__ ) + (__F(2)__ + F(1))    
          F(4) = F(3) + F(2) = (__F(2)__ + F(1)) + __F(2)__   
          F(3) = __F(2)__ + F(1)  
          __F(2)의 값은 항상 같다.    
          그러므로 문제에 대한 정답이 한 번 구해지면 Memoization 배열에 저장하여 같은 문제를 구할 때 계산하지 않고 배열에 저장된 값을 불러와 사용한다.   
          즉, Dynamic Programming은 각 문제를 한 번만 풀면 된다.__   
          
  - __Top-down__   
    - __큰 문제를 작은 문제로 나누면서 재귀적으로 푸는 방식__   
      1 - 가장 큰 문제에서 작은 문제를 재귀적으로 호출한다.   
      2 - 가장 작은 문제가 호출되면 해당 문제를 푼다.    
      3 - 푼 작은 문제를 리턴하여 그 값을 가지고 점차적으로 큰 문제를 해결한다.      
        
  - __Bottom-up__   
    - __작은 문제부터 큰 문제로 해결해나가는 반복문으로 푸는 방식__   
      1 - 제일 크기가 작은 문제부터 푼다.   
      2 - 푼 작은 문제를 통해 점차적으로 큰 문제를 푼다.      
      
### Fibonacci 공식을 재귀, 동적계획법, 반복문으로 구현 시 차이점   
  - __재귀__   
    - 함수 내에서 2개의 함수를 호출하기 때문에 지수적으로 증가해 __O(2^n)__ 라는 시간복잡도를 가진다.   
  - __반복문__   
    - 작은 순서부터 차례대로 값을 만들어가고 만들어진 값에 이전의 값을 더해나가는 방식이기 때문에 __O(n)__ 이라는 시간복잡도를 가진다.   
  - __Dynamic Programming__    
    - __memoization__ 을 사용하여 한번 계산된 문제를 저장하여 나중에 같은 문제가 나왔을 시 계산하지 않고 해당 값을 사용하여 중복된 문제에 대한 계산 시간을 줄이는 방식으로 __O(n)__ 이라는 시간복잡도를 가진다.   
  - __동적계획법은 재귀, 반복 두 가지 방식이 다 가능하고 같은 시간복잡도 O(n)을 가지지만 재귀적인 방법 같은 경우 함수를 계속 호출하는데 오버헤드가 발생하기 때문에 반복적인 방식에 비해 오래 걸린다.__
  -	__n이 작을 때는 3가지 방법의 속도에서 큰 차이를 보이지 않지만 30이 넘어가면 재귀 방식이 느려지는 것을 느낄 수 있다.__

