# :bookmark_tabs: Algorithm      

* [Dynamic Programming](#dynamic-programming)   
  - [Fibonacci 공식을 재귀, DP, 반복문으로 구현 시 차이점](#fibonacci-공식을-재귀-동적계획법-반복문으로-구현-시-차이점)
* [Graph](#graph)   
   - [DFS, BFS](#그래프-탐색)   
   - [](#)   
   - [](#)   
* [Greedy](#그리디-알고리즘)   
   - [](#)   
   - [](#)   
   - [](#)   
      
   
## Dynamic Programming   
- __큰 문제를 작은 문제로 나눠서 푸는 알고리즘__   
  - __만족해야 하는 2가지 속성__   
    - __Overlapping Subproblem__   
      - __큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.__   
      - __문제를 작은 문제로 쪼갤 수 있다.__   
      - __ex) 피보나치 수 F(n) = F(n-1) + F(n-2)을 구할 경우   
      F(n-1), F(n-2)를 구해야 하는데   
      F(n-1)을 구할 경우 F(n-1) = F(n-2) + F(n-3)   
      F(n-2)을 구할 경우 F(n-2) = F(n-3) + F(n-4)로 문제가 쪼개지게 된다.__   
      - 
    - __Optimal Substructure__   
      - __문제의 정답을 작은 문제의 정답에서 구할 수 있다.__    
      - __ex) 피보나치 수 F(n) = F(n-1) + F(n-2)을 구할 경우   
      작은 문제 F(n-1), F(n-2)를 합하여 F(n)을 구할 수 있다.__   
      - __이 규칙이 만족된다면, 문제에 상관없이 같은 문제에 대한 답은 똑같다__   
        - F(5) = F(4) + F(3) = (F(3) + __F(2)__ ) + (__F(2)__ + F(1))    
          F(4) = F(3) + F(2) = (__F(2)__ + F(1)) + __F(2)__   
          F(3) = __F(2)__ + F(1)  
          __F(2)의 값은 항상 같다.    
          그러므로 문제에 대한 정답이 한 번 구해지면 Memoization 배열에 저장하여 같은 문제를 구할 때 계산하지 않고 배열에 저장된 값을 불러와 사용한다.   
          즉, Dynamic Programming은 각 문제를 한 번만 풀면 된다.__   
          
  - __Top-down__   
    - __큰 문제를 작은 문제로 나누면서 재귀적으로 푸는 방식__   
      1 - 가장 큰 문제에서 작은 문제를 재귀적으로 호출한다.   
      2 - 가장 작은 문제가 호출되면 해당 문제를 푼다.    
      3 - 푼 작은 문제를 리턴하여 그 값을 가지고 점차적으로 큰 문제를 해결한다.      
        
  - __Bottom-up__   
    - __작은 문제부터 큰 문제로 해결해나가는 반복문으로 푸는 방식__   
      1 - 제일 크기가 작은 문제부터 푼다.   
      2 - 푼 작은 문제를 통해 점차적으로 큰 문제를 푼다.      
      
### Fibonacci 공식을 재귀, 동적계획법, 반복문으로 구현 시 차이점   
  - __재귀__   
    - 함수 내에서 2개의 함수를 호출하기 때문에 지수적으로 증가해 __O(2^n)__ 라는 시간복잡도를 가진다.   
  - __반복문__   
    - 작은 순서부터 차례대로 값을 만들어가고 만들어진 값에 이전의 값을 더해나가는 방식이기 때문에 __O(n)__ 이라는 시간복잡도를 가진다.   
  - __Dynamic Programming__    
    - __memoization__ 을 사용하여 한번 계산된 문제를 저장하여 나중에 같은 문제가 나왔을 시 계산하지 않고 해당 값을 사용하여 중복된 문제에 대한 계산 시간을 줄이는 방식으로 __O(n)__ 이라는 시간복잡도를 가진다.   
  - __동적계획법은 재귀, 반복 두 가지 방식이 다 가능하고 같은 시간복잡도 O(n)을 가지지만 재귀적인 방법 같은 경우 함수를 계속 호출하는데 오버헤드가 발생하기 때문에 반복적인 방식에 비해 오래 걸린다.__
  -	__n이 작을 때는 3가지 방법의 속도에서 큰 차이를 보이지 않지만 30이 넘어가면 재귀 방식이 느려지는 것을 느낄 수 있다.__

## Graph   
  - __Graph__   
    - 자료구조의 일종   
    - 정점(Node,Vertex), 간선(Edge)로 구성   
      - 두 정점 사이에 여러 개의 간선이 존재할 수 있다.   
    - __방향 있는 그래프__    
      - A->B 같이 방향이 있는 Directed Graph   
    - __방향 없는 그래프__   
      - A-B 같이 방향이 없는 Undirected Graph로 Bidirection Graph라고도 한다.   
    - __차수__    
      - 정점과 연결되어 있는 간선의 개수   
      - 방향 그래프의 경우 In-degree(정점으로 들어오는 간선의 수), Out-degree(정점에서 나가는 간선의 수)로 나누어 차수를 계산한다.   
    - __표현 방법__   
      - __인접 행렬__   
        - 정점의 개수 V일 경우 V x V 크기의 이차원 배열 사용 A[V][V], 공간복잡도 V^2   
        - A[i][j] = w (정점 i -> 정점 j로 가는 간선이 있을 경우, 그 가중치), 0 (없을 경우)   
        - 연결되지 않은 정점에 대한 공간도 할당되기 때문에 공간이 낭비된다.   
      - __인접 리스트__   
        - 정점의 개수 V일 경우 V 크기의 리스트 사용 A[V], 공간복잡도 E   
        - 리스트는 크기를 동적으로 변경할 수 있어야 하기 때문에 링크드 리스트나, 길이를 동적으로 변경할 수 있는 배열 사용    
        - A[i] = (i,w) (정점 i에 연결된 정점과 그 간선의 가중치)       

### 그래프 탐색    
  - __하나의 정점으로부터 시작하여 모든 정점들을 한 번씩 방문하는 것__   
  - __DFS(Depth First Search)__   
    - __깊이 우선 탐색__   
    - __`스택`을 이용하여 갈 수 있는 만큼 최대한 많이 가고 갈 수 없으면 이전 정점으로 돌아와 다른 방향으로 다시 탐색하는 방식__      
    - __재귀적 방식__   
    - __모든 곳을 방문할 시 주로 사용__   
  
  - __BFS(Breadth First Search)__   
    - __너비 우선 탐색__    
    - __`큐`를 이용하여 지금 위치에서 인접한 곳을 모두 방문하고 방문한 곳으로부터 인접한 곳을 모두 방문하며 탐색하는 방식__    
    - __방문했는지 확인을 위한 배열 필요__   
    - __가중치가 1일 때 최단 경로를 찾을 경우 주로 사용하지만 모든 곳을 방문할 시 DFS처럼 사용 가능하다.__   
    - 인접 행렬로 구현한 시간복잡도(V^2)   
    - 인접 리스트로 구현한 시간복잡도(V+E)   

## 그리디 알고리즘   
  - __그리디 알고리즘__   
    - __현재 가장 좋다고 생각되는 것을 선택하면서 답을 찾아가는 알고리즘__   
      - __현재는 최적의 답일 수 있지만, 최종적으로는 답이 최적이 아닐 수도 있다.__    
      - ex) 동전 1, 4, 5원짜리가 있는데 사용하는 동전의 개수를 최소로 해야 할 경우      
        - 12원을 거슬러주는 경우   
        - 5원 x 2개 = 10원 , 1원 x 2개 = 2원 으로 총 4개의 동전이 필요하다.   
        - 하지만 정답은 4원 x 3개 = 12원 이다.   
        
      - __왜 최적이 되는지를 증명해야하기 때문에 가장 어려운 알고리즘이다.__    
      
## 분할 정복   
  - __분할 정복__   
    - __분할 : 문제를 2개 이상의 작은 부분 문제로 나눈 다음 해결하는 것__   
    - __정복 : 해결한 문제를 다시 합쳐서 정답을 구하는 것__   
    - ex) 퀵 소트, 머지 소트, 큰 수 곱셈(카라추바 알고리즘), FFT   
    - __분할 정과 DP는 문제를 작은 부분으로 나눈 다는 것을 동일하지만 같은 문제가 중복되어서 나오지는 않는다__    
      - 분할 정복 : 같은 문제 중복 X   
      - DP : 중복된 문제를 Memoization으로 해결   
      

    
