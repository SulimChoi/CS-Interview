# :bookmark_tabs: Operating System Concepts 9th edition      
## 5장 Process Scheduling   
__중요하다고 생각되는 목차에는 :star: 표시해놓았습니다.__   
__:star:되어 있는 목차를 클릭하시면 클릭하신 목차의 내용이 있는 페이지로 넘어가며__   
__해당 페이지 내에 있는 중요 개념 옆에 :star: 표시해놓았습니다.__   

__혹시 잘못된 내용이 있거나 보완해야할 점이 있으면 `issue` 해주시거나 알려주시면 감사하겠습니다.:bow:__   

* [5.Process Scheduling](#4process-scheduling)   
  - [5.1 Basic Concepts](#51-basic-concepts)   
    - [5.1.1 CPU-I/O Burst Cycle(CPU 입출력 버스트 사이클)](#511-cpu-io-burst-cyclecpu-입출력-버스트-사이클)   
    - [5.1.2 CPU Scheduler(CPU 스케줄러)](#512-cpu-schedulercpu-스케줄러) :star:   
    - [5.1.3 Preemptive Scheduling(선점 스케줄링)](#513-preemptive-scheduling선점-스케줄링) :star:   
    - [5.1.4 Dispatcher(디스패처)](#514-dispatcher디스패처) :star:   
  - [5.2 Scheduling Criteria](#52-scheduling-criteria) :star:   
  - [5.3 Scheduling Algorithms](#53-scheduling-algorithms)   
    - [5.3.1 First-Come, First-Served Scheduling(선입선처리 스케줄링)](#531-first-come-first-served-scheduling선입선처리-스케줄링) :star:   
    - [5.3.2 Shortest-Job-First Scheduling(최단 작업 우선 스케줄링)](#532-shortest-job-first-scheduling최단-작업-우선-스케줄링) :star:      
    - [5.3.3 Priority Scheduling(우선순위 스케줄링)](#533-priority-scheduling우선순위-스케줄링) :star:       
    - [5.3.4 Round-Robin Scheduling(라운드-로빈 스케줄링)](#534-round-robin-scheduling라운드-로빈-스케줄링) :star:     
    - [5.3.5 Multilevel Queue Scheduling(다단계 큐 스케줄링)](#535-multilevel-queue-scheduling다단계-큐-스케줄링) :star:    
    - [5.3.6 Multilevel Feedback Queue Scheduling(다단계 피드백 큐 스케줄링)](#536-multilevel-feedback-queue-scheduling다단계-피드백-큐-스케줄링) :star:     
  - [](#)   
  - [](#)     
  - [](#)   
  - [](#)     
  
## 5.Process Scheduling   
### 5.1 Basic Concepts   

  - __멀티 프로그래밍은 CPU의 대기 시간을 활용하기 위해 한 순간에 다수의 프로세스들을 메모리에 저장시킨다.__   
    - 하나의 프로세스가 기다려야만 할 때, OS는 해당 프로세스를 CPU에서 제거하고 다른 프로세스에 CPU를 할당한다.   
    
#### 5.1.1 CPU-I/O Burst Cycle(CPU 입출력 버스트 사이클)   

  - __프로세스 실행은 CPU 실행과 입출력 사이클로 구성된다.__   
    - 프로세스들은 두 상태 사이에서 변경된다.   
    - 프로세스 실행은 CPU 버스트로 시작하고 입출력 버스트 - > CPU 버스트 -> 입출력 버스트 순으로 계속된다.   
      - 마지막 CPU 버스트는 실행 종료를 위한 시스템 요청과 함께 끝난다.   
    - 입출력 중심 프로그램은 짧은 CPU 버스트를 많이 가진다.   
    - CPU 중심 프로그램은 다수의 긴 CPU 버스트를 가진다.   
    - 이러한 버스트의 분포는 CPU 스케줄링 알고리즘을 선택하는데 매우 중요하다.   

#### 5.1.2 CPU Scheduler(CPU 스케줄러)   

  - __CPU가 idle 될 때 마다 OS는 ready queue에서 프로세스 하나를 선택해야 한다.__   
    - __프로세스 선택은 단기 스케줄러(CPU 스케줄러)에 의해 수행된다.__   
      - 스케줄러는 메모리 내의 실행될 준비가 되어 있는 프로세스들 중에서 선택하여 CPU에 할당 한다.   
    - ready queue는 항상 FIFO queue일 필요가 없다.   
      - FIFO, Priority, Tree, Unordered linked list로 구현될 수도 있다.   
    - queue에 있는 기록들은 프로세스들의 PCB이다.   
    
#### 5.1.3 Preemptive Scheduling(선점 스케줄링)   

  - __CPU 스케줄링이 발생되야 하는 4가지 상황__ :star:      
    - __1. 프로세스가 실행 상태(Running state)에서 대기 상태(Waiting state)로 전환될 때__   
      - 입출력 요청 후 또는 자식 프로세스가 종료되기를 기다리기 위한 wait() 호출 후    
    - __2. 프로세스가 실행 상태(Running state)에서 준비 상태(Ready state)로 전환될 때__   
      - 인터럽트 발생    
    - __3. 프로세스가 대기 상태(Waiting state)에서 준비 상태(Ready state)로 전환될 때__   
      - 입출력 완료   
    - __4. 프로세스가 종료할 때__   
    
  - __1, 4의 경우에는 일반적으로 스케줄링의 선택권이 없다.__   
    - ready queue에 프로세스가 존재한다면, 새로운 프로세스가 반드시 선택되야 한다.   
    - __1, 4의 스케줄링 방법은 비선점 또는 협조적이라고 한다.__   
      - CPU가 프로세스에 할당되면, 프로세스가 제거되거나 대기 상태로 전환됨으로써 CPU를 해제할 때까지 CPU를 점유한다.   
      
  - __2, 3의 경우 선택권이 있다.__   
    - __2, 3의 스케줄링 방법은 선점이라고 한다.__   
  
  - __선점(Preemptive)__ :star:   
    - 여러 프로세스 사이에 데이터가 공유될 때, 경쟁 상태(race condition)가 필요하다.  
      - 하나의 프로세스가 데이터를 수정 중일 때, 다른 프로세스가 데이터를 읽기 위해 선점하면 이슈가 발생한다.   
    - 시스템 호출 처리 과정 중, 커널은 프로세스를 위한 활동으로 바쁠 수 있다.   
      - 이러한 활동이 커널 데이터(ex) 입출력 큐) 변경과 연관이 있을 수도 있다.   
        - 이러한 변경 중간에 프로세스가 선점되고 커널이 같은 구조를 수정하거나 읽어야할 경우 아주 큰 문제가 발생한다.   
    - UNIX의 대부분 버전을 포함하는 특정 OS는 문맥 교환하기전에 시스템 호출이 완료되기를 기다리거나, 입출력 block이 발생되기를 기다림으로써 이러한 문제를 해결한다.   
    - 이러한 선점 구조는 커널 자료 구조가 일관적이지 않을 동안 커널이 프로세스를 선점하지 않게 하기 때문에, 커널 구조는 간닪하다.   
      - 하지만 이러한 커널 실행 모델은 주어진 시간 내에 작업이 완료되어야 하는 실시간 연산을 지원하는데 있어서는 취약하다.   
      
  - __인터럽트는 언제든 발생할 수 있고, 커널에 의해 항상 무시될 수 없기때문에 인터럽트에 의해 영향을 받는 코드 영역은 동시 사용으로부터 보호되어야 한다.__   
    - OS는 거의 항상 인터럽트를 받아들여야 한다.   
      - 그렇지 않을 경우 입력이 손실되거나 출력이 겹쳐서 쓰여질 수 있다.   
    - 이러한 코드 부분에 여러 프로세스가 병행으로 접근할 수 없도록 하기 위해서, 진입 시에 인터럽트를 disable하고 종료 시 reenable한다.   
    - 인터럽트를 disable하는 코드 영역은 자주 발생해서는 안되며 아주 적은 명령어만 포함해야한다.   
    
#### 5.1.4 Dispatcher(디스패처)   
  
  - __단기 스케줄러에 의해 선택된 프로세스에 CPU의 제어를 넘겨주는 모듈__   
    - 문맥 교환   
    - 사용자 모드로 전환   
    - 프로그램을 재시작하기 위해 사용자 프로그램의 적절한 위치로 이동   
    
  - __모든 프로세스 전환간 발생하기 때문에 가능한 한 아주 빨라야 한다.__   
  
  - __디스패치 지연(Dispatch latency)__   
    - 디스패처가 하나의 프로세스를 정지하고 다른 프로세스를 실행시키는데 걸리는 시간   
    
### 5.2 Scheduling Criteria   

  - __스케줄링 알고리즘 비교를 위한 속성__   
    - __CPU 이용률(CPU utilization)__   
      - __CPU를 최대한 바쁘게 만들어야 하기 때문에 40 ~ 90% 범위 안으로 사용해야한다.__   
      
    - __처리량(Throughput)__   
      - CPU가 프로세스를 실행시키느라 바쁘게 되면, 작업은 완료된다.   
      - __작업의 양을 측정하는 것은 time unit당 완료되어 지는 프로세스의 수이다.__   
        - ex) 긴 프로세스의 경우, 이러한 비율이 시간당 하나의 프로세스일 수도 있고, 짧은 프로세스의 경우, 초당 10개의 프로세스일 수 있다.   
    
    - __반환 시간(Turnaround time)__   
      - 특정 프로세스의 관점에서, 해당 프로세스를 실행하는데 걸리는 시간은 중요하다.   
      - __프로세스의 진입 시간부터 완료 시간까지의 시간이다.__   
      - __ready queue에서 기다리는 시간, CPU에서 실행되는 시간, 입출력하는 시간, 메모리에 적재되는데 기다리는 데 걸리는 시간의 합이다.__   
      - 반환 시간은 보통 출력장치의 속도에 의해 제한된다.   
    
    - __대기 시간(Waiting time)__   
      - CPU 스케줄링 알고리즘은 프로세스가 실행 또는 입출력을 하는 동안의 시간의 양에 영향을 주지 않는다.   
      - 오직 ready queue에서 프로세스가 기다리는 시간의 양에만 영향을 준다.   
      - __ready queue에서 기다린 기간의 합이다.__   
      
    - __응답 시간(Response time)__   
      - 상호 작용 시스템에서, 반환 시간은 가장 중요한 기준이 아닐 수도 있다.   
      - 프로세스는 꽤 빠르게 결과를 만들어 낼 수 있고 이전 결과가 사용자에게 출력되는 동안 연산을 계속 할 수 있다.   
      - __요청의 제출 시점부터 첫 응답이 생산될 때 까지의 시간이다.__   
      - 응답을 출력하는데 걸리는 시간이 아니라 응답을 시작하는데까지 걸리는 시간이다.   
      - 반환 시간은 보통 출력장치의 속도에 의해 제한된다.   
      
  - __CPU 이용률, 처리량을 최대화 시키고, 반환 시간, 대기 시간, 응답 시간을 최소화하는 게 이상적이다.__
    - 최악의 경우, 평균 값을 최적화한다.   
      - 일부의 경우, 최대 값 또는 최소 값을 최적화한다.   
        - ex) 모든 사용자가 좋은 서비스를 받는 것을 보장하기 위해 최대 응답 시간을 최소화 시키기를 원할 수도 있다.   
        
    - 상호 시스템의 경우, 평균 반응 시간을 최소화 하는 것보다 반응 시간에서의 변화를 최소화 시키는 것이 더 중요하다.   
      - 예측 가능하고 합리적인 반응 시간을 가진 시스템은 일반적으로 더 빠른 시스템보다 더 이상적이라고 고려될 수 있지만, 변동이 심하다.   
      - 오직 적은 양의 작업만 변화를 최소화하는 CPU 스케줄링 알고리즘에서 완료된다.   
      
### 5.3 Scheduling Algorithms   
#### 5.3.1 First-Come, First-Served Scheduling(선입선처리 스케줄링)   

  - __FCFS__ :star:   
    - __가장 간단한 CPU 스케줄링 알고리즘__    
      - __CPU에 먼저 요청한 프로세스가 CPU에 먼저 할당된다.__   
      - __FIFO queue에 의해 관리된다.__   
        - 프로세스가 ready queue에 들어갈 때, 프로세스의 PCB는 queue의 끝에 연결된다.   
        - CPU가 free일 때, queue의 앞부분에 있는 프로세스에 할당된다.   
      - __평균 대기 시간이 길다.__   
      - __호위 효과(Convoy effect)__   
        - 모든 프로세스들이 하나의 큰 프로세스가 CPU를 해제할 때까지 기다리는 것   
        - 더 짧은 프로세스가 먼저 시작되게 하는 것보다 더 낮은 CPU와 장치 이용량을 산출한다.   
      - __비선점형__   
        - 프로세스가 종료되거나 입출력 요청함으로써 CPU를 해제할 때까지 CPU를 점유한다.   
        - 시분할 시스템에서 부적절하다.   
          - 시분할 시스템에서는 각 사용자가 규칙적인 간격으로 CPU의 몫을 얻는 것이 매우 중요하기 때문이다.   

#### 5.3.2 Shortest-Job-First Scheduling(최단 작업 우선 스케줄링)   

  - __SJF__ :star:   
    - __다음 CPU 버스트의 길이가 가장 작은 프로세스를 먼저 CPU에 할당시킨다.__       
      - __프로세스의 CPU 실행시간이 같은 경우 FCFS 방식이 사용된다.__   
      - __FCFS보다 평균 대기 시간이 짧다.__   
      - __다음 CPU의 버스트 길이를 알 수 없다.__   
        - 일괄 처리 시스템에서 장기 스케줄링의 경우 사용자가 명시한 프로세스 제한 시간을 사용할 수 있다.   
        - 사용자들이 프로세스 시간 제한을 정확하게 예상하도록 동기를 부여받는다.   
          - 값이 낮을 수록 빠른 응답 속도를 나타내기 때문이다.   
          - 하지만 너무 작은 값은 시간 초과 오류를 일으키고 재실행이 필요하다.   
          - 일반적으로 장기 스케줄링에서 자주 사용된다.   

      - __단기 스케줄링에서는 구현될 수 없다.__   
        - 단기 스케줄링에서 다음 CPU 버스트 길이를 알 방법이 없다.   
        - 하지만 이러한 길이를 예상할 수 있는 방법이 있다.   
          - 다음 CPU 버스트는 이전 CPU 버스트와 비슷할 것이라고 예측한다.   
          - 다음 CPU 버스트의 길이의 근사값을 계산해 가장 짧다고 예상된 CPU 버스트를 가진 프로세르를 선택할 수 있다.   
          - 일반적으로 다음 CPU 버스트는 이전 CPU 버스트들의 측정된 길이의 지수 평균으로 예상되어진다.    

      - __선점형 또는 비선점형__   
        - 이전 프로세스가 계속 실행되는 동안 ready queue에 새로운 프로세스가 도착할 경우 선택이 발생한다.   
        - __선점 - 새로운 프로세스의 다음 CPU 버스트가 현재 실행되고 있는 프로세스의 남은 CPU 버스트보다 작을 경우 선점한다.__   
          - 최소 잔여 시간 우선(shortest-remaining-time-first) 스케줄링이라고 불린다.   
        - __비선점 - 현재 실행하는 프로세스를 종료하고 새로운 프로세스에 CPU를 할당한다.__   
      
#### 5.3.3 Priority Scheduling(우선순위 스케줄링)   

  - __우선순위는 각 프로세스들과 연관되어 있으며 CPU는 가장 높은 우선순위를 가진 프로세스에게 할당된다.__ :star:   
    - 우선순위가 같은 프로세스들은 FCFS방식으로 스케줄된다.   
    
  - __SJF는 우선순위 스케줄링 알고리즘의 특별한 경우다.__   
    - 더 많은 CPU 버스트를 가질수록 우선순위가 낮아진다.   
  
  - __0이 가장 높은 우선순위일 수 있고 가장 낮은 우선순위일 수 있다__   
    - 아래의 내용부터는 값이 낮을수록 높은 우선순위로 가정   
    
  - __우선순위는 내부적 또는 외부적으로 정의될 수 있다.__   
    - __내부적__   
      - 프로세스의 우선순위를 연산하기 위해 측정 가능한 양을 사용한다.   
        - ex) 시간 제한, 메모리 필요성, 열린 파일의 수, CPU 버스트 평균과 입출력 버스트 평균의 비율이 사용된다.   
    
    - __외부적__   
      - OS 외부 기준으로 정의된다.   
        - ex) 프로세스의 중요도, 컴퓨터 사용을 위해 지불된 자금의 종류와 양, 작업을 원조하는 부서 등 다른 요소   
        
  - __선점형 또는 비선점형__ :star:    
    - __선점 - 새로 들어온 프로세스의 우선순위가 현재 실행되는 프로세스의 우선순위보다 높을 경우 CPU를 선점한다.__   
    - __비선점 - 새로운 프로세스를 ready queue의 앞 부분에 넣는다.__    
    
  - __우선순위 알고리즘의 문제__ :star:   
    - __무한 블락(Indefinite blocking)__   
      - 실행할 준비가 되어 CPU를 기다리는 프로세스가 block된 상태로 간주될 수 있다.   
    - __기아 현상(Starvation)__   
      - 우선순위가 높은 프로세스들이 계속 들어와 우선순위가 낮은 프로세스들이 CPU를 무한히 대기하게 될 수도 있다.   
      
    - __해결 방안__   
      - __Aging__   
        - 오랜동안 기다리고 있는 프로세스의 우선순위를 점차적으로 증가시킨다.    
        
#### 5.3.4 Round-Robin Scheduling(라운드-로빈 스케줄링)    

  - __Round-Robin__ :star:    
    - 시분할 시스템을 위해 고안되었다.   
    - __FCFS + 시간 할당량(Time quantum) or 시간 조각(Time slice) => 선점__   
      - 프로세스가 작업을 완료하지 못하더라도 할당된 시간이 지나면 다음 프로세스가 실행된다.   
      - 시간 할당량은 0 ~ 100ms가 일반적이다.   
    - __ready queue는 원형 큐로 동작한다.__   
      - 새로운 프로세스는 ready queue의 끝에 추가된다.   
      - __CPU 스케줄러는 가장 첫 번째 프로세스를 고르고 시간 할당량 이후 인터럽트를 위한 타이머를 설정한 뒤 프로세스를 디스패치한다.__   
      - 프로세스의 CPU 버스트가 1 time quantum 이하 경우   
        - 해당 프로세스는 자발적으로 CPU를 반환하고 CPU는 ready queue에 있는 다음 프로세스를 실행시킨다.   
      - 프로세스의 CPU 버스트가 1 time quantum보다 클 경우   
        - 타이머를 울려 OS에 인터럽트를 야기한다.   
        - 문맥교환이 일어나고 프로세스는 ready queue의 끝에 추가되며 ready queue에 있는 다음 프로세스를 실행시킨다.   
      
    - __평균 대기시간이 길다.__   
      - 각 프로세스는 자신의 다음 시간 할당까지 (n-1) * q(시간 할당량) 시간 이상 기다리지 않는다.   
      - __시간 할당량이 크면 FCFS와 같다.__   
      - __시간 할당량이 작으면 많은 문맥교환이 일어나 프로세스의 실행이 느려진다.__   
        - 문맥교환 시간이 시간 할당량의 약 10%일 경우 CPU의 10%는 문맥교환에 사용된다.   
        - 대부분의 현대 시스템은 시간 할당의 범위를 10 ~ 100ms로 설정한다.   
        - 문맥교환을 위한 시간을 10ms보다 작고 문맥교환 시간은 시간 할당량의 작은 일부이다.   
        
    - __반환 시간은 시간 할당량의 크기에 달려있다.__   
      - 평균 반환 시간은 시간 할당량의 크기가 증가한다고 향상되지 않는다.   
      - __단일 시간 할당량 시간보다 다음 CPU 버스트가 적을 경우에는 향상 될 수 있다.__   
      - 평균 반환 시간은 더 작은 시간 할당량을 가질 수록 더 증가한다.   
        - 더 많은 문맥교환이 일어나기 때문이다.   
        
    - __일반적으로 CPU 버스트의 80%는 시간 할당량보다 짧아야 한다.__   
    
#### 5.3.5 Multilevel Queue Scheduling(다단계 큐 스케줄링)   

  - __프로세스들이 다른 그룹으로 분류된 상황을 위한 스케줄링 알고리즘__   
    - 일반적인 분류는 foreground(interactive) 프로세스와 background(batch) 프로세스로 나뉜다.   
    - 두 종류의 프로세스는 다른 응답 시간을 요구하고 다른 스케줄링을 요구한다.   
    - __foreground 프로세스가 background 프로세스보다 높은 우선순위를 가질 수 있다.__   
    
  - __Multilevel Queue Scheduling__ :star:   
    - __ready queue를 여러 분리된 queue로 나눈다.__   
    - 프로세스는 프로세스 우선순위, 타입, 메모리 크기와 같은 프로세스의 일부 속성에 기반하여 하나의 queue 영구적으로 할당된다.   
    - __각 queue는 고유의 스케줄링 알고리즘을 가진다.__   
      - ex) foreground queue는 RR, background queue는 FCFS   
    - __queue 사이에도 스케줄링 알고리즘 필요하다.__   
      - 고정된 우선순위 선점 스케줄링   
        - ex ) 5가지 queue를 가진 다단계 큐 스케줄링 알고리즘의 예    
          - 높은 우선순위에서 낮은 우선순위 순   
          - 1. System process
          - 2. Interactive process   
          - 3. Interactive editing process   
          - 4. Batch process   
          - 5. Student process   
        - 각각의 queue는 하위 우선수위 queue보다 절대적으로 높은 우선순위를 가진다.   
        
      - queue들 사이에 time slice를 할 수도 있다.   
        - 각 queue는 CPU 시간의 특정 양을 얻는다.   
          - ex) foreground queue는 RR 스케줄링을 위해 CPU 시간의 80%가 주어질 수 있고 background queue는 FCFS 스케줄링을 위해 20%를 얻을 수 있다.   
          
#### 5.3.6 Multilevel Feedback Queue Scheduling(다단계 피드백 큐 스케줄링)   

  - __다단계 큐는 프로세스가 시스템에 접속할 때, 하나의 queue에 영구적으로 할당되기 때문에 낮은 스케줄링 오버헤드를 가지지만 유연하지 못하다.__    
    - 즉, 프로세스가 다른 queue로 이동할 수 없다.   
    
  - __Multilevel Feedback Queue Scheduling__ :star:   
    - __queue사이에 이동이 가능하다.__    
      - __CPU 버스트의 특성에 따라서 프로세스를 분리하는 것이다.__   
      - 프로세스가 CPU 시간을 너무 많이 사용하면, 더 낮은 우선순위 큐로 이동된다.   
      - 입출력 중심과 대화형 프로세스가 높은 우선순위를 가진다.   
      - 프로세스가 낮은 우선순위 큐에서 너무 오랫동안 CPU를 기다리면 더 높은 우선순위 큐로 이동하게 된다.   
        - 기아 현상(Starvation) 예방   
        - ex) queue 0 : 시간 할당 8ms, queue 1 : 시간 할당 16ms, queue 3 : FCFS 있다고 가정할 경우   
          - queue 0에 있던 프로세스가 시간 할당량 8ms을 초과하면 queue 1의 끝에 추가된다.   
          - queue 0이 비고, queue 1에 있는 프로세스가 시간 할당량 16ms을 초과하면 queue 2의 끝에 추가된다.   
          - queue 0, 1이 비어있다면, queue 2에 있는 프로세스는 FCFS에 기반하여 실행된다.   
          
      - __다단계 피드백 큐가 정의되는 파라미터__   
        - 큐의 수   
        - 각 큐를 위한 스케줄링 알고리즘   
        - 프로세스를 높은 우선순위 큐로 올려주는 시기를 결정하는 방법   
        - 프로세스를 낮은 우선순위 큐로 강등시키는 시기를 결정하는 방법   
        - 프로세스가 서비스를 필요로 할 때 프로세스가 들어갈 큐를 결정하는 방법   
        
      - __가장 일반적인 CPU 스케줄링 알고리즘이지만 모든 파라미터에 대한 값을 선택하기 때문에 가장 복잡한 알고리즘이다.__    
