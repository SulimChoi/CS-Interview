# :bookmark_tabs: Operating System Concepts 9th edition      

* [1.Introduction](#1-introduction)   
   - [1.1 What Operating Systems do](#11-what-operating-systems-doos가-하는-일)   
      - [1.1.1 User View(사용자 관점)](#111-user-view사용자-관점)   
      - [1.1.2 System View(시스템 관점)](#112-system-view시스템-관점)   
      - [1.1.3 Defining Operating Systems(OS 정의)](#113-defining-operating-systemsos-정의)   
   - [1.2 Computer-System Organization](#12-computer-system-organization컴퓨터-시스템-구성)   
      - [1.2.1 Computer-System Operation(컴퓨터 시스템 동작)](122-computer-system-operation컴퓨터-시스템-)   
      - [1.2.2 Storage Structure(저장 장치 구조)](#122-storage-structure저장-장치-구조)   
      - [1.2.3 I/O Structure(입출력 구조)](#123-io-structure입출력-구조)
   - [1.3 Computer-System Architecture](#13-computer-system-architecture컴퓨터-시스템-구조)
      - [1.3.1 Single-Processor Systems(단일 프로세서 시스템)](#131-single-processor-systems단일-프로세서-시스템)
      - [1.3.2 Multiprocessor Systems(멀티 프로세서 시스템)](#132-multiprocessor-systems멀티-프로세서-시스템)
      - [](#)
      
* [2.](#2)   
   - [](#)   
   - [](#)   
   - [](#)   
   - [](#)   
   
   
## 1. Introduction   
   - __Operating System__   
      - 컴퓨터의 하드웨어를 관리하는 프로그램   
      - 컴퓨터 사용자와 하드웨어 사이의 중개자 역할을 하며 응용프로그램을 위한 기초를 제공   
      - OS mainframe은 주로 하드웨어의 이용률을 최대한으로 하기 위해 설계되었다.   
 
### 1.1 What Operating Systems do(OS가 하는 일)   
   - __컴퓨터 시스템을 대략 4가지 구성요소로 나눌 수 있다.__   
      - __Hardware__    
         - 시스템을 위한 기본적인 컴퓨터 자원들을 제공한다.    
         - CPU(Central Processing Unit), Memory, I/O devices   
      - __Application programs__   
         - 사용자의 컴퓨팅 문제를 해결하기 위해 자원들을 사용하는 방식을 정의한다.   
         - ex) Word processor, spreadsheets...   
      - __Operating system__   
         - 하드웨어를 통제하고 다양한 사용자들을 위한 다양한 app 사이에 하드웨어 사용을 조정한다.  
      - __Users__   
      
#### 1.1.1 User View(사용자 관점)   
   - __사용자를 위한 시스템은 보통 한 유저가 시스템 자원을 독점할 수 있게 설계되어진다.__   
      - __목표는 사용자가 실행하는 작업을 최대화하는 것이다.__   
      - __이 경우, OS는 자원의 이용보다 성능에 중점을 두면서 대부분 사용의 용의함을 위해 설계된다.__   
      - __다수 사용자의 요구 사항보다 한 사용자에 경험에 더 최적화 되어있다.__   
   
   - __사용자는 mainframe 또는 minicomputer에 연결된 터미널에 있을 수 있다.__   
      - __다른 사용자들은 다른 터미널을 통해 같은 컴퓨터에 접근한다.__    
         - __사용자들은 자원을 공유하고 정보를 교환할 수도 있다.__   
      - __이 경우, OS는 자원 활용을 극대화하기 위해 설계되어있다.__   
      
   - __사용자는 서버와 다른 워크스테이션의 네트워크에 연결된 워크스테이션에 있을 수 있다.__    
      - __사용자가 마음대로 사용할 수 있게 자원들을 할당한다.__   
      - __파일, 프린트 서버를 포함하는 서버와 네트워킹같은 자원을 공유한다.__   
    
#### 1.1.2 System View(시스템 관점)   
   - __OS는 하드웨어와 가장 밀접하게 연관된 프로그램이며 자원 관리자의 역할을 한다.__   
   - __OS는 다양한 사용자 프로그램과 I/O 장치를 통제하기 위한 Control Program이다.__   
   - __Control program__   
      - 컴퓨터의 부적절한 사용과 에러를 예방하기 위해 사용자 프로그램의 실행을 관리한다.   

#### 1.1.3 Defining Operating Systems(OS 정의)   
   - __일반적인 OS의 정의는 컴퓨터에서 항상 실행되는 하나의 프로그램이다. = Kernel   
   - __커널의 2가지 종류 프로그램__   
      - __System program__   
         - OS와 관련이 있지만 커널의 필수적인 부분은 아니다.   
      - __Application program__   
         - 시스템의 작동과 관련되지 않은 모든 프로그램    
   - __Mobile OS는 핵심 커널뿐만 아니라 middleware도 포함할때도 있다.__   
      - __Middleware__   
         - app 개발자에게 추가적인 서비스를 제공해주는 소프트웨어 프레임워크의 집합   
         - ex) IOS, Android   

### 1.2 Computer-System Organization(컴퓨터 시스템 구성)    
#### 1.2.1 Computer-System Operation(컴퓨터 시스템 동작)      
   - __일반 컴퓨터 시스템은 하나 이상의 CPU와 공유 메모리에 접근하는 것을 제공해야 하는 공통 버스와 연결된 다수의 장치관리자들로 구성된다.__   
   - __각 장치관리자는 특정 종류의 장치를 담당한다.__   
      - ex) 디스크 드라이브, 오디오 장치, 비디오 플레이어    
   - __CPU와 장치관리자들은 메모리 Cycle을 위해 경쟁하면서 동시에 실행할 수 있다.__    
   - __공유 메모리에 순차적으로 접근을 보장하기 위해서, 메모리 관리자는 메모리에 대한 접근을 동기화(Synchronize)한다.__   
   - __컴퓨터가 시작될 때 초기 프로그램 또는 bootstrap 프로그램이 실행되어야만 한다.__   
      - __이러한 초기 프로그램 또는 부트스트랩 프로그램은 ROM(Read-only-memory) 또는 EEPROM(Erasable programmable read-only memeory)에 있는 컴퓨터 하드웨어내에 저장되어 있으며 일반적인 용어로 Firmware라고 한다.__   
      - __CPU 레지스터부터 장치관리자까지 모든 시스템의 측면을 초기 설정한다.__   
      - __부트스트랩 프로그램은 반드시 OS를 불러오고 실행시키는 방법을 알고있어야만 한다.__   
      - __이러한 목표를 달성하기 위해서, 부트스트랩 프로그램은 반드시 OS 커널의 위치를 찾아내어 메모리에 적재되어야 한다.__   
   
   - __커널이 적재되고 실행되면, 시스템과 사용자에게 서비스 제공을 시작할 수 있다.__   
      - __일부 서비스는 커널이 실행되는 동안 내내 실행되는 시스템 프로세스 또는 시스템 데몬이 되기 위해서 부트 시간에 메모리로 적재되는 시스템 프로그램에 의해서 제공된다. 즉, 커널 외부에서 제공된다.__   
      - ex) UNIX에서 첫번째 시스템 프로세스는 "init"이며 init은 다른 데몬들을 실행시킨다. 이 단계가 완료되면, 시스템은 완벽하게 부트되었고 이벤트가 발생하기를 기다린다.      
      
   - __이벤트의 발생은 보통 소프트웨어 또는 하드웨어로부터의 인터럽트에 의한 신호를 받는다.__   
      - __하드웨어는 주로 시스템 버스를 거쳐 CPU로 신호를 보냄으로써 언제든지 인터럽트를 발생시킬 수 있다.__   
      - __소프트웨어는 System call(= Monitor call)을 호출하는 특별한 명령어를 실행시킴으로써 인터럽트를 발생시킬 수 있다.__   
   
   - __CPU가 인터럽트 될 경우__ :star:   
      1. 하던 일을 중단하고 즉시 특정 위치로 실행을 전달한다.   
         - 특정 위치는 보통 해당 인터럽트를 위한 서비스 루틴이 위치해있는 시작 주소를 가지고 있다.   
      2. 인터럽트 서비스루틴이 실행된다.   
      3. 인터럽트 서비스루틴이 완료될 시, CPU는 인터럽트에 의해 중단됐던 작업을 재개한다.   
      
   - __인터럽트__ :star:     
      - 각 컴퓨터 디자인은 자신만의 인터럽트 메카니즘을 가지고 있다.   
      - __인터럽트는 적합한 인터럽트 서비스 루틴에 통제권을 전달해야 한다.__   
         - 이러한 전달을 다루기 위한 쉬운 방법은 인터럽트 정보를 검사하기 위한 포괄적인 루틴을 호출하는 것이다.   
         - 해당 루틴은 결국, 특정 인터럽트 핸들러를 호출한다.   
      - __인터럽트는 반드시 빨리 처리되야 한다.__   
         - 미리 정의된 수만큼의 인터럽트만 처리 가능하기 때문에, 인터럽트 루틴을 위한 포인터 테이블은 필요한 스피드를 충족시키기 위해 사용될 수 있다.   
      - __인터럽트 루틴은 중간 루틴의 필요없이 포인터 테이블을 통해 간접적으로 호출된다.__    
      - __보통, 포인터 테이블은 low memory에 저장된다.(처음 백개 정도)__   
         - 이러한 위치에는 다양한 장치들을 위한 인터럽트 서비스 루틴의 주소들이 들어있다.   
         - 주소의 배열 또는 인터럽트 벡터는 장치 고유 번호에 의해 색인되며, 인터럽트를 일으킨 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해서 인터럽트 요청과 함께 장치 고유 번호가 주어진다.   
      - __인터럽트 구조는 반드시 인터럽트된 명령어의 주소를 저장해야한다.__   
         - 많은 오래된 설계에서는 고정된 위치나 장치 번호에 의해 색인된 위치에 인터럽트 주소를 저장했다.   
         - 최근 구조에서는 시스템 스택에서 반환 주소를 저장한다.   
            - ex) 만약 인터럽트 루틴이 프로세서 상태를 수정해야할 필요가 있을 경우   
               - 레지스터 값을 수정함으로써, 현재 상태를 저장하고 반환하기 전에 저장해놓은 상태를 복구해야만 한다.    
               - 인터럽트가 서비스 된 후, 저장된 반환 주소가 프로그램 카운터로 적재되고 인터럽트되었던 작업은 재개된다.   

#### 1.2.2 Storage Structure(저장 장치 구조)   
   - __CPU는 오직 메모리에서 명령을 불러올 수 있다.__   
      - 그래서 실행시킬 모든 프로그램은 메모리에 저장되어 있어야만 한다.   

   - __일반용 컴퓨터는 다시쓰기(rewritable)가 가능한 메모리라 불리는 Main memory (Random-Access Memory or RAM)로부터 대다수의 프로그램을 실행한다.__    
      - Main memory는 일반적으로 Dynamic Random-Access Memory (DRAM)으로 불리는 반도체 기술에서 구현된다.   
   
   - __ROM(Read-Only Memory)은 변경할수가 없다.__   
      - 그러므로 부트스트랩 프로그램과 같은 정적인 프로그램만 ROM에 저장된다.   
   
   - __EEPROM(Electrically Erasable Programmable Read-Only Memory)은 변경할 수 있지만, 빈번하게 변경할 수는 없다.__     
      - ROM과 마찬가지로 대부분 정적 프로그램을 포함한다.   
      - ex) 스마트폰은 출하 시 설치된 프로그램을 저장시키기 위해서 EEPROM을 사용한다.   
      
   - __모든 메모리의 유형은 byte로 구성된 배열을 제공한다.__    
      - 각 byte는 자신만의 주소를 가지고 있다.   
      - 상호작용은 특정 메모리 주소에 대한 load 또는 store의 연속을 통해 이루어진다.   
         - __load__   
            - 하나의 byte 또는 word를 메인 메모리로부터 CPU내의 내부 레지스터로 이동시킨다.   
         - __store__   
            - 레지스터의 내용을 메인 메모리로 이동시킨다.   
      - CPU는 실행을 위해 자동으로 메인 메모리로부터 명령어들을 load 한다.   
      
   - __von Neumann architecture 실행 cycle__ :star:   
      1. 메모리로부터 명령을 불러온다(Fetch).         
      2. 해당 명령을 명령 레지스터에 저장한다.    
      3. 해당 명령은 해독(Decode)되어지고, 피연산자가 메모리로부터 불러와(Fetch)질 수도 있다.    
      4. 일부 내부 레지스터에 해당 명령이 저장된다.   
      5. 피연산자를 가지고 해당 명령이 실행된 후, 결과는 메모리에 저장이 된다.   
      
      - 각 메모리 단위는 오직 하나의 일련의 메모리 주소만을 본다.   
      - 하나의 메모리 주소가 어떻게 생성되었고 무엇을 위한 것인지 알 수 없다.  
         - 즉, 우리는 메모리 주소가 프로그램에 의해 어떻게 생성되었는지 신경 쓸 필요가 없고 오직 실행되는 프로그램에 의해 생성된 일련의 메모리 주소에만 관심을 두면 된다.   
     
   - __보통 프로그램과 데이터를 메인 메모리에 영구적으로 보관하고 싶어하지만 불가능하다.__   
      - 이유 1. 메인 메모리가 모든 필요한 프로그램과 데이터를 영구적으로 저장하기에 너무 작다.   
      - 이유 2. 메인 메모리가 volatile(휘발성) 저장 장치이기 때문에 전원이 나가거나 꺼졌을 때 내용물을 잃게 된다.   
   
   - __대부분의 컴퓨터가 메인 메모리의 연장선으로서 Second storage를 제공한다.__   
      - 2차 저장 장치의 주요 요건은 많은 양의 데이터를 영구적으로 보관할 수 있어야 한다는 것이다.   
      - 가장 일반적인 2차 저장 장치는 프로그램과 데이터 둘다를 위해 저장공간을 제공하는 자기 디스크(magnetic disk)다.   
      - 대다수 프로그램(system and applications)은 메모리에 불러와지기 전까지 디스크에 저장되어 있다.   
         - 많은 프로그램이 자신의 처리 과정의 시작과 끝에 디스크를 사용한다.  
      - 적절한 디스크 용량 관리는 컴퓨터 시스템에서 중요한 부분이다.   
     
   - __메인 메모리, 자기 디스크, 캐시 메모리, 자기 테이프 등의 저장 구조는 많은 가능한 저장 시스템의 하나일 뿐이다.__   
      - 각 저장 시스템은 데이터(datum)를 저장하고, 차후에 검색되어질때까지 그 데이터를 유지하는 기본 기능을 제공한다.   
      - 다양한 저장 시스템 사이에 주요 차이점은 속소, 비용, 크기, 휘발성에 있다.   
      
   - __저장 장치 계층__   
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_4_StorageDeviceHierarchy.jpg" width="450px" height="450px" title="1_4_StorageDeviceHierarchy" alt="1_4_StorageDeviceHierarchy"></img></p>     
   
      - 상위 4개의 메모리는 반도체 메모리를 사용하여 제작된다.   
      - 비싼 배터리와 백업 시스템 생성기의 존재로, 데이터는 반드시 비휘발성 저장 장치에 기록되야만 한다.   
         - 비휘발성 저장 장치의 또 다른 유형은 NVRAM이다.   
            - 백업 전원 배터리를 가진 DRAM으로 배터리가 지속하는한 DRAM보다 빠르고 비휘발성이다.   
   
   - __solid-state disk는 보통 magnetic disk보다 빠르고 비휘발성이다.__ :star:   
      - 유형 1. 동작하는 동안 데이터를 큰 DRAM 배열에 저장한다.    
         - 백업 파워를 위해서 배터리와 숨겨진 자기 하드디스크를 가지고 있다.   
         - 외부 전원이 중단될 경우, SSD 컨트롤러가 데이터를 RAM에서 자기 디스크로 복사한다.   
         - 외부 전원이 복구될 경우, SSD 컨트롤러가 자기 디스크로부터 데이터를 다시 RAM으로 복사한다.   
      - 유형 2. Flash Memory   
         - 카메라와 Personal Digital Assistants(PDAs)에서 많이 사용된다.   
         - DRAM보다 느리지만 내용물을 유지하기 위해 전원이 필요없다.   

   - __완벽한 메모리 시스템의 설계는 모든 요소들이 균형을 이뤄야 한다.__   
      - 더 비싼 메모리를 사용해야하지만 가능한 덜 비싸고 비휘발성인 메모리   

   - __캐시는 비용과 비휘발성 두 요소 사이에 존재하는 전송률 또는 접근 시간에 큰 차이가 있는 성능을 향상시키기 위해 설치되어진다.__    
   
#### 1.2.3 I/O Structure(입출력 구조)    

   - __저장 장치는 컴퓨터내의 많은 입출력 장치 종류 중 하나일 뿐이다.__   
      - 일반용 컴퓨터 시스템은 CPU와 다수의 장치 관리자로 구성되어 있고 공동 버스로 연결되어 있다.   
      - 하나의 장치 관리자는 하나 이상의 장치가 연결되어질 수 있다.   
         - ex) 7개 이상의 장치가 SCSI(Small Computer-System Interface) 관리자에 연결될 수 있다.   
      - 장치 관리자는 지역 버퍼 저장 공간과 특수 목적용 레지스터 집합을 관리한다.   
      - 장치 관리자는 자신이 관리하는 주변 장치와 자신의 지역 버퍼 저장 공간 사이에 데이터를 이동시키는 것을 담당한다.   
      - 일반적으로 OS는 장치 관리자를 위한 장치 드라이버를 가지고 있다.   
         - 장치 드라이버는 장치 관리자를 이해하고 장치를 위한 동일한 인터페이스를 OS에 제공한다.   
      
   - __입출력 작업 실행 순서__ :star:      
      1. 장치 드라이버가 장치 관리자내에 있는 적합한 레지스터를 불러온다.   
      2. 장치 관리자는 어떤 동작을 수행할건지 확인하기 위해 레지스터의 내용을 검사한다.   
      3. 장치 관리자는 데이터를 장치로부터 자신의 지역 버퍼 공간으로 전송을 시작한다.   
      4. 데이터 전송이 끝나면, 장치 관리자는 장치 드라이버에게 인터럽트를 통해 해당 작업이 완료되었음을 알린다.   
      5. 장치 드라이버는 OS에 해당 장치에 대한 통제권을 반환한다.   
         - 작업이 읽기였다면 데이터를 가르키는 포인터나, 데이터를 반환하는 것도 가능하다.   
         - 다른 작업일경우, 장치 드라이버는 상태 정보를 반환한다.   
   
   - __인터럽트를 사용한 입출력은 작은 양의 데이터를 이동시키기 위해서 사용해도 된다.__   
      - 하지만 대용량의 데이터 이동을 위해 사용되었을 때 큰 오버헤드를 만들어낼 수 있다.   
      - 이러한 문제를 해결하기 위해서 DMA(Direct Memory Access)를 사용한다.   
         - 입출력 장치를 위해 카운터, 포인터, 버퍼를 설정한 뒤 장치 관리자는 데이터의 모든 블록을 직접적으로 메모리로 전송하거나 장치 관리자의 버퍼 공간에서 메모리로 전송한다. 이 때 cpu의 개입은 없다.   
         - 동작이 완료되었다는 것을 장치 드라이버에게 전하기 위해서 블록당 오직 하나의 인터럽트만 생성된다.   
            - low-speed 장치를 위해 생성된 byte당 하나의 인터럽트를 사용하기 보다는 위의 방식을 사용한다.   
         - 장치 관리자가 동작들을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있다.   
   
   - __일부 최신 시스템은 버스 구조를 사용하기 보다는 스위치를 사용한다.__   
      - 이러한 시스템에서는 여러 구성요소가 공유 버스의 cycle을 경쟁하기보다는 동시에 다른 요소와 통신할 수 있다.   
      - 이러한 경우, DMA가 더 효율적이다.   
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_5_HowModernComputerWorks.jpg" width="450px" height="400px" style="display: block; margin: 0 auto" title="1_5_HowModernComputerWorks" alt="1_5_HowModernComputerWorks"></p>
   
### 1.3 Computer-System Architecture(컴퓨터 시스템 구조)   
#### 1.3.1 Single-Processor Systems(단일 프로세서 시스템)    
   - __거의 모든 단일 프로세서 시스템은 특수 목적용 프로세서도 가지고 있다.__   
      1. 특정 장치(디바이스 종속) 프로세서 - 메인 프레임에 있는 디스크, 키보드, 그래픽 관리자 등의 형태   
      2. 더 일반용 프로세서 - 시스템 구성요소 사이에 빠르게 데이터를 이동시키는 입출력 프로세서 형태     
      - 모든 특수 목적용 프로세서는 사용자 프로세스를 제외한 제한된 명령들만 수행한다.   
      - 가끔 OS에 의해 관리되며, OS가 다음 작업에 대한 정보를 프로세서에 전송하고 프로세서의 상태를 모니터한다.   
         - ex) 디스크 관리자 마이크로 프로세서는 메인 CPU로부터 일련의 요청을 받게되고 자신의 디스크 큐와 스케줄링 알고리즘을 구현한다.   
         - 이러한 방식은 메인 CPU의 디스크 스케줄링 부담을 덜어준다.   
      - PC는 CPU에 키보드의 키 누름을 코드로 전달하기 위해서 키 누름을 코드로 변환시켜주는 키보드에 있는 마이크로 프로세서도 포함한다.   
      - 다른 시스템의 경우, 특수 목적용 프로세서가 하드웨어에 내장되어 있는 low-level 요소이다.  
         - 이 경우 OS가 이러한 특수 목적용 프로세서와 통신할 수 없다.   
         - 이러한 특수 목적용 프로세서는 자신의 일을 자율적으로 한다.   
      - 특수 목적용 마이크로 프로세서의 사용은 흔하지만 단일 프로세서 시스템을 멀티 프로세서로 바꾸지는 않는다.   
      
#### 1.3.2 Multiprocessor Systems(멀티 프로세서 시스템)      

   - __멀티 프로세서(멀티 코어 시스템 or 병행 시스템)는 컴퓨터 버스를 공유하면서 두 개 이상의 프로세서가 긴밀히 통신한다.__   
      - 가끔 주변 장치, 메모리, clock도 공유하기도 한다.  
      
   - __멀티 프로세서 시스템의 3가지 이점__ :star:     
   
      __1. 처리량 증가__   
      - __프로세서의 수가 증가함으로써 더 적은 시간에 많은 작업을 끝낼 수 있다.__   
      - 다수의 프로세서가 하나의 작업을 수행할 때, 모든 부분을 정확하게 수행되게하면서 일정량의 오버헤드만 발생된다.   
      - N개의 프로세스의 처리 속도 비율은 N이 아니다.   
         - 유사하게, N명의 프로그래머가 작업을 같이 하더라도 한 명의 프로그래머가 생산하는 작업의 양의 N배를 생산하지는 않는다.   
            
      __2. 경제 규모(비용 절감)__   
      - __멀티 프로세서 시스템은 동등한 수의 단일 프로세서 시스템보다 비용이 적게 든다.__   
         - __주변 장치, 거대한 저장 공간, 전원 공급을 공유하기 때문이다.__   
      - 여러 프로그램이 같은 데이터의 집합에서 동작할 경우, 하나의 디스크에 데이터를 저장하고 모든 프로세서가 데이터를 공유하게 하는 것이 다수의 컴퓨터 각자 디스크에 데이터를 복사하는 것보다 훨씬 더 비용이 적게 든다.   
         
      __3. 신뢰성 증가__   
      - __여러 프로세서 사이에 기능이 적절하게 분배될 수 있으면, 하나의 프로세스가 실패가 시스템을 중단시키지 않고 느리게만 만든다.__    
      - ex) 10개의 프로세서 중 하나가 실패하는 경우    
         - 남아있는 9개의 각각의 프로세스가 실패한 프로세서의 작업의 일부분을 가져올 수 있다. 결국, 전체 시스템은 10% 느리게만 동작할 뿐이다.   
            
   - __신뢰성은 APP에서 중요하다.__   
   
      - __살아남은 하드웨어의 단계에 서비스를 부분적으로 계속 제공하는 것을 능력을 "Graceful degradation(우아한 성능저하)"이라고 한다.__   
         - __일부 다른 시스템은 "Fault tolerant(장애 허용)" 이라고도 부른다.__   
            - 하나의 요소의 실패가 하더라도 계속해서 작업을 진행하게 할 수 있기 때문이다.   
            - 실패를 탐지할 수 있고 이를 진단할 수 있고 가능하다면 고치는 것까지 할 수 있는 메카니즘이 필요하다.   
            
   - __현대 멀티 프로세서 시스템 2가지 종류__ :star:     
   
      __1. Asymmetric Multiprocessing(비대칭 멀티 프로세싱)__    
      - 각 프로세서가 특정 작업을 할당받는다.   
      - __Boss 프로세서가 시스템을 통제한다.__   
      - __다른 프로세서는 Boss의 명령을 기다리거나 미리 정의되어 있는 작업을 수행한다.__     
      - __Boss-Worker 관계라고 한다.__   
      - __Boss 프로세서가 스케줄하고 작업을 Worker 프로세스에 할당한다.__   
         
      __2. Symmetric Multiprocessing(대칭 멀티 프로세싱)__   
      - 대다수 일반 시스템 SMP를 사용한다.   
      - __OS 내에서 각 프로세서가 모든 작업을 수행한다.__   
      - __모든 프로세서가 친구다. No Boss, No Worker__   
      - __각 프로세서는 private 또는 local 캐시와 자신 고유의 레지스터 집합을 가진다.__   
      - __모든 프로세서는 물리적 메모리를 공유한다.__   
      - __많은 프로세스가 동시에 실행할 수 있다.__   
         - N개의 CPU가 있다면 N개의 프로세서는 큰 성능 저하를 일으키지 않고 실행할 수 있다.   
      - 데이터가 적합한 프로세서에 도달하는 것을 보장하기 위해서 입출력을 조심히 통제해야 한다.   
      - __CPU가 분리되어 있기 때문에 하나가 과부하되는 반면 다른 하나는 Idle 상태에 있을 수도 있어 비효율적인 결과를 낳을 수 있다.__   
      - 이러한 비효율성은 프로세서들이 특정 자료구조를 공유하면 방지할 수 있다.   
      - __메모리와 같은 자원과 프로세스를 많은 프로세서 사이에 동적으로 공유되어지게하고 프로세서간의 차이를 낮출 수 있다.__   
      - 거의 모든 현대 OS는 SMP를 지원한다.   
         - ex) Windows, Linux, Mac OS X   
         
      - __Symmetric과 Asymmetric 멀티 프로세싱의 차이점__   
         - __차이점은 하드웨어 또는 소프트웨어 때문일 수 있다.__   
            __1. 특수한 하드웨어는 멀티프로세서를 구분할 수도 있다.__    
            __2. 소프트웨어는 오직 하나의 Boss와 다수의 Worker만 있게 작성될 수도 있다.__    
            - ex) Sun Microsystem의 SunOS   
            version 4는 asymmentric이지만   
            version 5는 같은 하드웨어지만 symmentric이다.   
      
   - __멀티 프로세싱은 연산 능력을 높이기 위해 CPU를 추가한다.__    
      - CPU가 integrated memory controller를 가진다면, CPU를 추가하는 것은 시스템에서 the amount of memory addressable을 증가시킬 수 있다.   
      
   - __멀티 프로세싱은 시스템이 자신의 메모리 접근 모델을 UMA(Uniform Memory Access)에서 NUMA(Non-Uniform Memory Access)로 바꿀 수 있게 한다.__   
      - __UMA(Uniform Memory Access)__   
         - 모든 CPU에서 모든 RAM에 접근하는데 걸리는 시간이 같다.  
      - __NUMA(Non-Uniform Memory Access)__   
         - 메모리의 일부분이 다른 부분보다 접근하는데 더 오래 걸린다.   
         - 성능 저하를 일으킨다.   
         
   - ____   
   - ____   
   

####
   - ____   
   - ____  
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   
   
####
   - ____   
   - ____  
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   
####
   - ____   
   - ____  
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   
####
   - ____   
   - ____  
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   
####
   - ____   
   - ____  
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   
####
   - ____   
   - ____  
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   
