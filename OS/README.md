# :bookmark_tabs: Operating System Concepts 9th edition      

* [1.Introduction](#1-introduction)   
   - [1.1 What Operating Systems do](#11-what-operating-systems-doos가-하는-일)   
      - [1.1.1 User View(사용자 관점)](#111-user-view사용자-관점)   
      - [1.1.2 System View(시스템 관점)](#112-system-view시스템-관점)   
      - [1.1.3 Defining Operating Systems(OS 정의)](#113-defining-operating-systemsos-정의)   
   - [1.2 Computer-System Organization](#12-computer-system-organization컴퓨터-시스템-구성)   
      - [1.2.1 Computer-System Operation(컴퓨터 시스템 동작)](122-computer-system-operation컴퓨터-시스템-) :star:   
      - [1.2.2 Storage Structure(저장 장치 구조)](#122-storage-structure저장-장치-구조) :star:     
      - [1.2.3 I/O Structure(입출력 구조)](#123-io-structure입출력-구조) :star:  
   - [1.3 Computer-System Architecture](#13-computer-system-architecture컴퓨터-시스템-구조)   
      - [1.3.1 Single-Processor Systems(단일 프로세서 시스템)](#131-single-processor-systems단일-프로세서-시스템)   
      - [1.3.2 Multiprocessor Systems(멀티 프로세서 시스템)](#132-multiprocessor-systems멀티-프로세서-시스템) :star:    
      - [1.3.3 Clustered Systems(클러스터 시스템)](#133-clustered-systems클러스터-시스템) :star:       
   - [1.4 Operationg-System Structure](#14-operationg-system-structure운영체제-구조) :star:       
   - [1.5 Operationg-System Operations](#15-operationg-system-operationsos-동작) :star:       
      - [1.5.1 Dual-Mode and Multiple Operation(듀얼 모드와 여러 동작)](#151-dual-mode-and-multiple-operation듀얼-모드와-여러-동작) :star:       
      - [1.5.2 Timer(타이머)](#152-timer타이머)    
   - [1.6 Process Management](#16-process-management)   
   - [1.7 Memory Management](#17-memory-management)   
   - [1.8 Storage Management](#18-storage-management)   
      - [1.8.1 File-System Management(파일 시스템 관리)](#181-file-system-management파일-시스템-관리)   
      - [1.8.2 Mass-Storage Management(거대 저장 장치 관리)](#182-mass-storage-management거대-저장-장치-관리)   
      - [1.8.3 Caching(캐싱)](#183-caching캐싱-star) :star:   
      - [1.8.4 I/O Systems(입출력 시스템)](#184-io-systems입출력-시스템)
   - [1.9 Protection and Security](#19-protection-and-security)   
   - [1.10 Kernel Data Structures](#110-kernel-data-structures) :star:      
      - [1.10.1 Lists, Stacks, and Queues(리스트, 스택, 큐)](#1101-lists-stacks-and-queues리스트-스택-큐))   
      - [1.10.2 Tree(트리)](#1102-tree트리)   
      - [1.10.3 Hash Functions and Maps(해시 함수와 맵)](1103-hash-functions-and-maps해시-함수와-맵)
      - [1.10.4 Bitmap(비트맵)](#1104-bitmap비트맵)     
   - [1.11 Computing Environments](#111-computing-environments)   
      - [1.11.1 Traditional Computing(전통적인 컴퓨팅)](#1111-traditional-computing전통적인-컴퓨팅)   
      - [1.11.2 Mobile Computing(모바일 컴퓨팅)](#1112-mobile-computing모바일-컴퓨팅)   
      - [1.11.3 Distributed Systems(분산 시스템)](#1113-distributed-systems분산-시스템)   
      - [1.11.4 Client-Server Computing(클라이언트-서버 컴퓨팅)](#1114-client-server-computing클라이언트-서버-컴퓨팅)   
      - [1.11.5 Peer-to-Peer Computing(Peer-to-Peer 컴퓨팅)](#1115-peer-to-peer-computingpeer-to-peer-컴퓨팅)   
      - [1.11.6 Virtualization(가상화)](#1116-virtualization가상화)   
      - [](#)
      - [](#)
   - [](#)
      - [](#)
      - [](#)
      - [](#)
* [2.](#2)   
   - [](#)   
   - [](#)   
   - [](#)   
   - [](#)   
   
   
## 1. Introduction   
   - __Operating System__   
      - 컴퓨터의 하드웨어를 관리하는 프로그램   
      - 컴퓨터 사용자와 하드웨어 사이의 중개자 역할을 하며 응용프로그램을 위한 기초를 제공   
      - OS mainframe은 주로 하드웨어의 이용률을 최대한으로 하기 위해 설계되었다.   
 
### 1.1 What Operating Systems do(OS가 하는 일)   
   - __컴퓨터 시스템을 대략 4가지 구성요소로 나눌 수 있다.__   
      - __Hardware__    
         - 시스템을 위한 기본적인 컴퓨터 자원들을 제공한다.    
         - CPU(Central Processing Unit), Memory, I/O devices   
      - __Application programs__   
         - 사용자의 컴퓨팅 문제를 해결하기 위해 자원들을 사용하는 방식을 정의한다.   
         - ex) Word processor, spreadsheets...   
      - __Operating system__   
         - 하드웨어를 통제하고 다양한 사용자들을 위한 다양한 app 사이에 하드웨어 사용을 조정한다.  
      - __Users__   
      
#### 1.1.1 User View(사용자 관점)   
   - __사용자를 위한 시스템은 보통 한 유저가 시스템 자원을 독점할 수 있게 설계되어진다.__   
      - __목표는 사용자가 실행하는 작업을 최대화하는 것이다.__   
      - __이 경우, OS는 자원의 이용보다 성능에 중점을 두면서 대부분 사용의 용의함을 위해 설계된다.__   
      - __다수 사용자의 요구 사항보다 한 사용자에 경험에 더 최적화 되어있다.__   
   
   - __사용자는 mainframe 또는 minicomputer에 연결된 터미널에 있을 수 있다.__   
      - __다른 사용자들은 다른 터미널을 통해 같은 컴퓨터에 접근한다.__    
         - __사용자들은 자원을 공유하고 정보를 교환할 수도 있다.__   
      - __이 경우, OS는 자원 활용을 극대화하기 위해 설계되어있다.__   
      
   - __사용자는 서버와 다른 워크스테이션의 네트워크에 연결된 워크스테이션에 있을 수 있다.__    
      - __사용자가 마음대로 사용할 수 있게 자원들을 할당한다.__   
      - __파일, 프린트 서버를 포함하는 서버와 네트워킹같은 자원을 공유한다.__   
    
#### 1.1.2 System View(시스템 관점)   
   - __OS는 하드웨어와 가장 밀접하게 연관된 프로그램이며 자원 관리자의 역할을 한다.__   
   - __OS는 다양한 사용자 프로그램과 I/O 장치를 통제하기 위한 Control Program이다.__   
   - __Control program__   
      - 컴퓨터의 부적절한 사용과 에러를 예방하기 위해 사용자 프로그램의 실행을 관리한다.   

#### 1.1.3 Defining Operating Systems(OS 정의)   
   - __일반적인 OS의 정의는 컴퓨터에서 항상 실행되는 하나의 프로그램이다. = Kernel   
   - __커널의 2가지 종류 프로그램__   
      - __System program__   
         - OS와 관련이 있지만 커널의 필수적인 부분은 아니다.   
      - __Application program__   
         - 시스템의 작동과 관련되지 않은 모든 프로그램    
   - __Mobile OS는 핵심 커널뿐만 아니라 middleware도 포함할때도 있다.__   
      - __Middleware__   
         - app 개발자에게 추가적인 서비스를 제공해주는 소프트웨어 프레임워크의 집합   
         - ex) IOS, Android   

### 1.2 Computer-System Organization(컴퓨터 시스템 구성)    
#### 1.2.1 Computer-System Operation(컴퓨터 시스템 동작)      
   - __일반 컴퓨터 시스템은 하나 이상의 CPU와 공유 메모리에 접근하는 것을 제공해야 하는 공통 버스와 연결된 다수의 장치관리자들로 구성된다.__   
   - __각 장치관리자는 특정 종류의 장치를 담당한다.__   
      - ex) 디스크 드라이브, 오디오 장치, 비디오 플레이어    
   - __CPU와 장치관리자들은 메모리 Cycle을 위해 경쟁하면서 동시에 실행할 수 있다.__    
   - __공유 메모리에 순차적으로 접근을 보장하기 위해서, 메모리 관리자는 메모리에 대한 접근을 동기화(Synchronize)한다.__   
   - __컴퓨터가 시작될 때 초기 프로그램 또는 bootstrap 프로그램이 실행되어야만 한다.__   
      - __이러한 초기 프로그램 또는 부트스트랩 프로그램은 ROM(Read-only-memory) 또는 EEPROM(Erasable programmable read-only memeory)에 있는 컴퓨터 하드웨어내에 저장되어 있으며 일반적인 용어로 Firmware라고 한다.__   
      - __CPU 레지스터부터 장치관리자까지 모든 시스템의 측면을 초기 설정한다.__   
      - __부트스트랩 프로그램은 반드시 OS를 불러오고 실행시키는 방법을 알고있어야만 한다.__   
      - __이러한 목표를 달성하기 위해서, 부트스트랩 프로그램은 반드시 OS 커널의 위치를 찾아내어 메모리에 적재되어야 한다.__   
   
   - __커널이 적재되고 실행되면, 시스템과 사용자에게 서비스 제공을 시작할 수 있다.__   
      - __일부 서비스는 커널이 실행되는 동안 내내 실행되는 시스템 프로세스 또는 시스템 데몬이 되기 위해서 부트 시간에 메모리로 적재되는 시스템 프로그램에 의해서 제공된다. 즉, 커널 외부에서 제공된다.__   
      - ex) UNIX에서 첫번째 시스템 프로세스는 "init"이며 init은 다른 데몬들을 실행시킨다. 이 단계가 완료되면, 시스템은 완벽하게 부트되었고 이벤트가 발생하기를 기다린다.      
      
   - __이벤트의 발생은 보통 소프트웨어 또는 하드웨어로부터의 인터럽트에 의한 신호를 받는다.__   
      - __하드웨어는 주로 시스템 버스를 거쳐 CPU로 신호를 보냄으로써 언제든지 인터럽트를 발생시킬 수 있다.__   
      - __소프트웨어는 System call(= Monitor call)을 호출하는 특별한 명령어를 실행시킴으로써 인터럽트를 발생시킬 수 있다.__   
   
   - __CPU가 인터럽트 될 경우__ :star:   
      1. 하던 일을 중단하고 즉시 특정 위치로 실행을 전달한다.   
         - 특정 위치는 보통 해당 인터럽트를 위한 서비스 루틴이 위치해있는 시작 주소를 가지고 있다.   
      2. 인터럽트 서비스루틴이 실행된다.   
      3. 인터럽트 서비스루틴이 완료될 시, CPU는 인터럽트에 의해 중단됐던 작업을 재개한다.   
      
   - __인터럽트__ :star:     
      - 각 컴퓨터 디자인은 자신만의 인터럽트 메카니즘을 가지고 있다.   
      - __인터럽트는 적합한 인터럽트 서비스 루틴에 통제권을 전달해야 한다.__   
         - 이러한 전달을 다루기 위한 쉬운 방법은 인터럽트 정보를 검사하기 위한 포괄적인 루틴을 호출하는 것이다.   
         - 해당 루틴은 결국, 특정 인터럽트 핸들러를 호출한다.   
      - __인터럽트는 반드시 빨리 처리되야 한다.__   
         - 미리 정의된 수만큼의 인터럽트만 처리 가능하기 때문에, 인터럽트 루틴을 위한 포인터 테이블은 필요한 스피드를 충족시키기 위해 사용될 수 있다.   
      - __인터럽트 루틴은 중간 루틴의 필요없이 포인터 테이블을 통해 간접적으로 호출된다.__    
      - __보통, 포인터 테이블은 low memory에 저장된다.(처음 백개 정도)__   
         - 이러한 위치에는 다양한 장치들을 위한 인터럽트 서비스 루틴의 주소들이 들어있다.   
         - 주소의 배열 또는 인터럽트 벡터는 장치 고유 번호에 의해 색인되며, 인터럽트를 일으킨 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해서 인터럽트 요청과 함께 장치 고유 번호가 주어진다.   
      - __인터럽트 구조는 반드시 인터럽트된 명령어의 주소를 저장해야한다.__   
         - 많은 오래된 설계에서는 고정된 위치나 장치 번호에 의해 색인된 위치에 인터럽트 주소를 저장했다.   
         - 최근 구조에서는 시스템 스택에서 반환 주소를 저장한다.   
            - ex) 만약 인터럽트 루틴이 프로세서 상태를 수정해야할 필요가 있을 경우   
               - 레지스터 값을 수정함으로써, 현재 상태를 저장하고 반환하기 전에 저장해놓은 상태를 복구해야만 한다.    
               - 인터럽트가 서비스 된 후, 저장된 반환 주소가 프로그램 카운터로 적재되고 인터럽트되었던 작업은 재개된다.   

#### 1.2.2 Storage Structure(저장 장치 구조)   
   - __CPU는 오직 메모리에서 명령을 불러올 수 있다.__   
      - 그래서 실행시킬 모든 프로그램은 메모리에 저장되어 있어야만 한다.   

   - __일반용 컴퓨터는 다시쓰기(rewritable)가 가능한 메모리라 불리는 Main memory (Random-Access Memory or RAM)로부터 대다수의 프로그램을 실행한다.__    
      - Main memory는 일반적으로 Dynamic Random-Access Memory (DRAM)으로 불리는 반도체 기술에서 구현된다.   
   
   - __ROM(Read-Only Memory)은 변경할수가 없다.__   
      - 그러므로 부트스트랩 프로그램과 같은 정적인 프로그램만 ROM에 저장된다.   
   
   - __EEPROM(Electrically Erasable Programmable Read-Only Memory)은 변경할 수 있지만, 빈번하게 변경할 수는 없다.__     
      - ROM과 마찬가지로 대부분 정적 프로그램을 포함한다.   
      - ex) 스마트폰은 출하 시 설치된 프로그램을 저장시키기 위해서 EEPROM을 사용한다.   
      
   - __모든 메모리의 유형은 byte로 구성된 배열을 제공한다.__    
      - 각 byte는 자신만의 주소를 가지고 있다.   
      - 상호작용은 특정 메모리 주소에 대한 load 또는 store의 연속을 통해 이루어진다.   
         - __load__   
            - 하나의 byte 또는 word를 메인 메모리로부터 CPU내의 내부 레지스터로 이동시킨다.   
         - __store__   
            - 레지스터의 내용을 메인 메모리로 이동시킨다.   
      - CPU는 실행을 위해 자동으로 메인 메모리로부터 명령어들을 load 한다.   
      
   - __von Neumann architecture 실행 cycle__ :star:   
      1. 메모리로부터 명령을 불러온다(Fetch).         
      2. 해당 명령을 명령 레지스터에 저장한다.    
      3. 해당 명령은 해독(Decode)되어지고, 피연산자가 메모리로부터 불러와(Fetch)질 수도 있다.    
      4. 일부 내부 레지스터에 해당 명령이 저장된다.   
      5. 피연산자를 가지고 해당 명령이 실행된 후, 결과는 메모리에 저장이 된다.   
      
      - 각 메모리 단위는 오직 하나의 일련의 메모리 주소만을 본다.   
      - 하나의 메모리 주소가 어떻게 생성되었고 무엇을 위한 것인지 알 수 없다.  
         - 즉, 우리는 메모리 주소가 프로그램에 의해 어떻게 생성되었는지 신경 쓸 필요가 없고 오직 실행되는 프로그램에 의해 생성된 일련의 메모리 주소에만 관심을 두면 된다.   
     
   - __보통 프로그램과 데이터를 메인 메모리에 영구적으로 보관하고 싶어하지만 불가능하다.__   
      - 이유 1. 메인 메모리가 모든 필요한 프로그램과 데이터를 영구적으로 저장하기에 너무 작다.   
      - 이유 2. 메인 메모리가 volatile(휘발성) 저장 장치이기 때문에 전원이 나가거나 꺼졌을 때 내용물을 잃게 된다.   
   
   - __대부분의 컴퓨터가 메인 메모리의 연장선으로서 Second storage를 제공한다.__   
      - 2차 저장 장치의 주요 요건은 많은 양의 데이터를 영구적으로 보관할 수 있어야 한다는 것이다.   
      - 가장 일반적인 2차 저장 장치는 프로그램과 데이터 둘다를 위해 저장공간을 제공하는 자기 디스크(magnetic disk)다.   
      - 대다수 프로그램(system and applications)은 메모리에 불러와지기 전까지 디스크에 저장되어 있다.   
         - 많은 프로그램이 자신의 처리 과정의 시작과 끝에 디스크를 사용한다.  
      - 적절한 디스크 용량 관리는 컴퓨터 시스템에서 중요한 부분이다.   
     
   - __메인 메모리, 자기 디스크, 캐시 메모리, 자기 테이프 등의 저장 구조는 많은 가능한 저장 시스템의 하나일 뿐이다.__   
      - 각 저장 시스템은 데이터(datum)를 저장하고, 차후에 검색되어질때까지 그 데이터를 유지하는 기본 기능을 제공한다.   
      - 다양한 저장 시스템 사이에 주요 차이점은 속소, 비용, 크기, 휘발성에 있다.   
      
   - __저장 장치 계층__   
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_4_StorageDeviceHierarchy.jpg" width="450px" height="450px" title="1_4_StorageDeviceHierarchy" alt="1_4_StorageDeviceHierarchy"></img><br><strong>1.4 저장 장치</strong> 
      </p>     
   
      - 상위 4개의 메모리는 반도체 메모리를 사용하여 제작된다.   
      - 비싼 배터리와 백업 시스템 생성기의 존재로, 데이터는 반드시 비휘발성 저장 장치에 기록되야만 한다.   
         - 비휘발성 저장 장치의 또 다른 유형은 NVRAM이다.   
            - 백업 전원 배터리를 가진 DRAM으로 배터리가 지속하는한 DRAM보다 빠르고 비휘발성이다.   
   
   - __solid-state disk는 보통 magnetic disk보다 빠르고 비휘발성이다.__ :star:   
      - 유형 1. 동작하는 동안 데이터를 큰 DRAM 배열에 저장한다.    
         - 백업 파워를 위해서 배터리와 숨겨진 자기 하드디스크를 가지고 있다.   
         - 외부 전원이 중단될 경우, SSD 컨트롤러가 데이터를 RAM에서 자기 디스크로 복사한다.   
         - 외부 전원이 복구될 경우, SSD 컨트롤러가 자기 디스크로부터 데이터를 다시 RAM으로 복사한다.   
      - 유형 2. Flash Memory   
         - 카메라와 Personal Digital Assistants(PDAs)에서 많이 사용된다.   
         - DRAM보다 느리지만 내용물을 유지하기 위해 전원이 필요없다.   

   - __완벽한 메모리 시스템의 설계는 모든 요소들이 균형을 이뤄야 한다.__   
      - 더 비싼 메모리를 사용해야하지만 가능한 덜 비싸고 비휘발성인 메모리   

   - __캐시는 비용과 비휘발성 두 요소 사이에 존재하는 전송률 또는 접근 시간에 큰 차이가 있는 성능을 향상시키기 위해 설치되어진다.__    
   
#### 1.2.3 I/O Structure(입출력 구조)    

   - __저장 장치는 컴퓨터내의 많은 입출력 장치 종류 중 하나일 뿐이다.__   
      - 일반용 컴퓨터 시스템은 CPU와 다수의 장치 관리자로 구성되어 있고 공동 버스로 연결되어 있다.   
      - 하나의 장치 관리자는 하나 이상의 장치가 연결되어질 수 있다.   
         - ex) 7개 이상의 장치가 SCSI(Small Computer-System Interface) 관리자에 연결될 수 있다.   
      - 장치 관리자는 지역 버퍼 저장 공간과 특수 목적용 레지스터 집합을 관리한다.   
      - 장치 관리자는 자신이 관리하는 주변 장치와 자신의 지역 버퍼 저장 공간 사이에 데이터를 이동시키는 것을 담당한다.   
      - 일반적으로 OS는 장치 관리자를 위한 장치 드라이버를 가지고 있다.   
         - 장치 드라이버는 장치 관리자를 이해하고 장치를 위한 동일한 인터페이스를 OS에 제공한다.   
      
   - __입출력 작업 실행 순서__ :star:      
      1. 장치 드라이버가 장치 관리자내에 있는 적합한 레지스터를 불러온다.   
      2. 장치 관리자는 어떤 동작을 수행할건지 확인하기 위해 레지스터의 내용을 검사한다.   
      3. 장치 관리자는 데이터를 장치로부터 자신의 지역 버퍼 공간으로 전송을 시작한다.   
      4. 데이터 전송이 끝나면, 장치 관리자는 장치 드라이버에게 인터럽트를 통해 해당 작업이 완료되었음을 알린다.   
      5. 장치 드라이버는 OS에 해당 장치에 대한 통제권을 반환한다.   
         - 작업이 읽기였다면 데이터를 가르키는 포인터나, 데이터를 반환하는 것도 가능하다.   
         - 다른 작업일경우, 장치 드라이버는 상태 정보를 반환한다.   
   
   - __인터럽트를 사용한 입출력은 작은 양의 데이터를 이동시키기 위해서 사용해도 된다.__   
      - 하지만 대용량의 데이터 이동을 위해 사용되었을 때 큰 오버헤드를 만들어낼 수 있다.   
      - 이러한 문제를 해결하기 위해서 DMA(Direct Memory Access)를 사용한다.   
         - 입출력 장치를 위해 카운터, 포인터, 버퍼를 설정한 뒤 장치 관리자는 데이터의 모든 블록을 직접적으로 메모리로 전송하거나 장치 관리자의 버퍼 공간에서 메모리로 전송한다. 이 때 cpu의 개입은 없다.   
         - 동작이 완료되었다는 것을 장치 드라이버에게 전하기 위해서 블록당 오직 하나의 인터럽트만 생성된다.   
            - low-speed 장치를 위해 생성된 byte당 하나의 인터럽트를 사용하기 보다는 위의 방식을 사용한다.   
         - 장치 관리자가 동작들을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있다.   
   
   - __일부 최신 시스템은 버스 구조를 사용하기 보다는 스위치를 사용한다.__   
      - 이러한 시스템에서는 여러 구성요소가 공유 버스의 cycle을 경쟁하기보다는 동시에 다른 요소와 통신할 수 있다.   
      - 이러한 경우, DMA가 더 효율적이다.   
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_5_HowModernComputerWorks.jpg" width="450px" height="400px" style="display: block; margin: 0 auto" title="1_5_HowModernComputerWorks" alt="1_5_HowModernComputerWorks"><br><strong>1.5 현대 컴퓨터가 작동하는 방식</strong></p>
   
### 1.3 Computer-System Architecture(컴퓨터 시스템 구조)   
#### 1.3.1 Single-Processor Systems(단일 프로세서 시스템)    
   - __거의 모든 단일 프로세서 시스템은 특수 목적용 프로세서도 가지고 있다.__   
      1. 특정 장치(디바이스 종속) 프로세서 - 메인 프레임에 있는 디스크, 키보드, 그래픽 관리자 등의 형태   
      2. 더 일반용 프로세서 - 시스템 구성요소 사이에 빠르게 데이터를 이동시키는 입출력 프로세서 형태     
      - 모든 특수 목적용 프로세서는 사용자 프로세스를 제외한 제한된 명령들만 수행한다.   
      - 가끔 OS에 의해 관리되며, OS가 다음 작업에 대한 정보를 프로세서에 전송하고 프로세서의 상태를 모니터한다.   
         - ex) 디스크 관리자 마이크로 프로세서는 메인 CPU로부터 일련의 요청을 받게되고 자신의 디스크 큐와 스케줄링 알고리즘을 구현한다.   
         - 이러한 방식은 메인 CPU의 디스크 스케줄링 부담을 덜어준다.   
      - PC는 CPU에 키보드의 키 누름을 코드로 전달하기 위해서 키 누름을 코드로 변환시켜주는 키보드에 있는 마이크로 프로세서도 포함한다.   
      - 다른 시스템의 경우, 특수 목적용 프로세서가 하드웨어에 내장되어 있는 low-level 요소이다.  
         - 이 경우 OS가 이러한 특수 목적용 프로세서와 통신할 수 없다.   
         - 이러한 특수 목적용 프로세서는 자신의 일을 자율적으로 한다.   
      - 특수 목적용 마이크로 프로세서의 사용은 흔하지만 단일 프로세서 시스템을 멀티 프로세서로 바꾸지는 않는다.   
      
#### 1.3.2 Multiprocessor Systems(멀티 프로세서 시스템)      

   - __멀티 프로세서(멀티 코어 시스템 or 병행 시스템)는 컴퓨터 버스를 공유하면서 두 개 이상의 프로세서가 긴밀히 통신한다.__   
      - 가끔 주변 장치, 메모리, clock도 공유하기도 한다.  
      
   - __멀티 프로세서 시스템의 3가지 이점__ :star:     
   
      __1. 처리량 증가__   
      - __프로세서의 수가 증가함으로써 더 적은 시간에 많은 작업을 끝낼 수 있다.__   
      - 다수의 프로세서가 하나의 작업을 수행할 때, 모든 부분을 정확하게 수행되게하면서 일정량의 오버헤드만 발생된다.   
      - N개의 프로세스의 처리 속도 비율은 N이 아니다.   
         - 유사하게, N명의 프로그래머가 작업을 같이 하더라도 한 명의 프로그래머가 생산하는 작업의 양의 N배를 생산하지는 않는다.   
            
      __2. 경제 규모(비용 절감)__   
      - __멀티 프로세서 시스템은 동등한 수의 단일 프로세서 시스템보다 비용이 적게 든다.__   
         - __주변 장치, 거대한 저장 공간, 전원 공급을 공유하기 때문이다.__   
      - 여러 프로그램이 같은 데이터의 집합에서 동작할 경우, 하나의 디스크에 데이터를 저장하고 모든 프로세서가 데이터를 공유하게 하는 것이 다수의 컴퓨터 각자 디스크에 데이터를 복사하는 것보다 훨씬 더 비용이 적게 든다.   
         
      __3. 신뢰성 증가__   
      - __여러 프로세서 사이에 기능이 적절하게 분배될 수 있으면, 하나의 프로세스가 실패가 시스템을 중단시키지 않고 느리게만 만든다.__    
      - ex) 10개의 프로세서 중 하나가 실패하는 경우    
         - 남아있는 9개의 각각의 프로세스가 실패한 프로세서의 작업의 일부분을 가져올 수 있다. 결국, 전체 시스템은 10% 느리게만 동작할 뿐이다.   
            
   - __신뢰성은 APP에서 중요하다.__   
   
      - __살아남은 하드웨어의 단계에 서비스를 부분적으로 계속 제공하는 것을 능력을 "Graceful degradation(우아한 성능저하)"이라고 한다.__   
         - __일부 다른 시스템은 "Fault tolerant(장애 허용)" 이라고도 부른다.__   
            - 하나의 요소의 실패가 하더라도 계속해서 작업을 진행하게 할 수 있기 때문이다.   
            - 실패를 탐지할 수 있고 이를 진단할 수 있고 가능하다면 고치는 것까지 할 수 있는 메카니즘이 필요하다.   
            
   - __현대 멀티 프로세서 시스템 2가지 종류__ :star:     
   
      __1. Asymmetric Multiprocessing(비대칭 멀티 프로세싱)__    
      - 각 프로세서가 특정 작업을 할당받는다.   
      - __Boss 프로세서가 시스템을 통제한다.__   
      - __다른 프로세서는 Boss의 명령을 기다리거나 미리 정의되어 있는 작업을 수행한다.__     
      - __Boss-Worker 관계라고 한다.__   
      - __Boss 프로세서가 스케줄하고 작업을 Worker 프로세스에 할당한다.__   
         
      __2. Symmetric Multiprocessing(대칭 멀티 프로세싱)__   
      - 대다수 일반 시스템 SMP를 사용한다.   
      - __OS 내에서 각 프로세서가 모든 작업을 수행한다.__   
      - __모든 프로세서가 친구다. No Boss, No Worker__   
      - __각 프로세서는 private 또는 local 캐시와 자신 고유의 레지스터 집합을 가진다.__   
      - __모든 프로세서는 물리적 메모리를 공유한다.__   
      - __많은 프로세스가 동시에 실행할 수 있다.__   
         - N개의 CPU가 있다면 N개의 프로세서는 큰 성능 저하를 일으키지 않고 실행할 수 있다.   
      - 데이터가 적합한 프로세서에 도달하는 것을 보장하기 위해서 입출력을 조심히 통제해야 한다.   
      - __CPU가 분리되어 있기 때문에 하나가 과부하되는 반면 다른 하나는 Idle 상태에 있을 수도 있어 비효율적인 결과를 낳을 수 있다.__   
      - 이러한 비효율성은 프로세서들이 특정 자료구조를 공유하면 방지할 수 있다.   
      - __메모리와 같은 자원과 프로세스를 많은 프로세서 사이에 동적으로 공유되어지게하고 프로세서간의 차이를 낮출 수 있다.__   
      - 거의 모든 현대 OS는 SMP를 지원한다.   
         - ex) Windows, Linux, Mac OS X   
         
         </br><p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_6_SMP_Architecture.jpg" width="400px" height="300px" style="display: block; margin: 0 auto" title="1_6_SMP_Architecture.jpg" alt="1_6_SMP_Architecture.jpg"><br><strong>1.6 SMP 구조</strong></p>
         
      - __Symmetric과 Asymmetric 멀티 프로세싱의 차이점__   
         - __차이점은 하드웨어 또는 소프트웨어 때문일 수 있다.__   
            __1. 특수한 하드웨어는 멀티프로세서를 구분할 수도 있다.__    
            __2. 소프트웨어는 오직 하나의 Boss와 다수의 Worker만 있게 작성될 수도 있다.__    
            - ex) Sun Microsystem의 SunOS   
            version 4는 asymmentric이지만   
            version 5는 같은 하드웨어지만 symmentric이다.   
      
   - __멀티 프로세싱은 연산 능력을 높이기 위해 CPU를 추가한다.__    
      - CPU가 integrated memory controller를 가진다면, CPU를 추가하는 것은 시스템에서 the amount of memory addressable을 증가시킬 수 있다.   
      
   - __멀티 프로세싱은 시스템이 자신의 메모리 접근 모델을 UMA(Uniform Memory Access)에서 NUMA(Non-Uniform Memory Access)로 바꿀 수 있게 한다.__   
      - __UMA(Uniform Memory Access)__   
         - 모든 CPU에서 모든 RAM에 접근하는데 걸리는 시간이 같다.  
      - __NUMA(Non-Uniform Memory Access)__   
         - 메모리의 일부분이 다른 부분보다 접근하는데 더 오래 걸린다.   
         - 성능 저하를 일으킨다.   
      
   - __최신 CPU 설계 트렌드는 하나의 칩에 다수의 코어를 포함하는 것이다.__   
      - 이러한 멀티 프로세서 시스템을 "멀티코어"라고 한다.   
      - __여러 코어를 가진 하나의 칩이 하나의 코어를 가진 여러 칩보다 훨씬 효율적이다.__   
         - on-chip 통신이 between-chip 통신보다 훨씬 빠르기 때문이다.   
         - 여러 코어를 가진 하나의 칩이 하나의 코어를 가진 여러 칩보다 훨씬 더 적은 양의 파워를 사용한다.   
      - __멀티코어 시스템은 멀티 프로세서 시스템이지만, 모든 멀티 프로세서 시스템이 멀티코어는 아니다.__   
         - 일반적으로, 일부의 멀티 프로세서 시스템을 제외하고는 보통 멀티코어라고 부른다.   
      - __하나의 칩에 2개의 코어가 있는 경우, 각 코어는 고유 레지스터와 지역 캐시를 가진다.__   
         - 이러한 멀티코어 CPU는 OS에게 N개의 일반 프로세서처럼 보인다.   
         - 이러한 특성은 OS 설계자나 앱 개발자에게 이러한 코어들을 사용하게 만드는 부담을 준다.   
            
      </br><p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_7_DualCore.jpg" width="400px" height="300px" style="display: block; margin: 0 auto" title="1_7_DualCore.jpg" alt="1_7_DualCore.jpg"><br><strong>1.7 하나의 칩에 두 코어를 놓은 듀얼 코어 디자인</strong></p>   
         
   - __Blade server(고밀도 서버)__    
      - 같은 chassis에 위치한 다수의 프로세서 보드, 입출력 보드, 네트워킹 보드를 가지고 최근 개발되었다.   
      - 전통적인 멀티프로세서 시스템과 이러한 블레이드 서버와 다른점은 각 blade-processor 보드가 독립적으로 부트되고 자신 고유의 OS를 실행시키는 것이다.   
      - 이러한 블레이드 서버는 다수의 독립적인 멀티 프로세서 시스템으로 구성되어있다.   

#### 1.3.3 Clustered Systems(클러스터 시스템)   

   - __Cluster System__ :star:   
      - 다수의 CPU가 모여있는 멀티 프로세서 시스템의 한 유형이다.   
      - __멀티 프로세서와 다른 점은 두 개 이상의 개별 시스템 또는 노드가 결합되어 구성되어 있고 "loosely coupled" 되어 있다.__     
      - 각 노드는 단일 프로세서 시스템이거나 멀티코어 시스템일 수도 있다.   
      - __일반적 정의는 저장 공간을 공유하고 LAN 또는 InfiniBand 같은 더 빠른 상호연결을 통해 밀접하게 연결되어 있다는 것이다.__    
      - __고가용성을 제공하기 위해 사용된다.__   
         - __집단에서 하나 이상의 시스템이 실패하더라도 계속 서비스를 수행한다.__   
         - __시스템에 중복을 추가함으로써 고가용성을 얻게 된다.__   
         - 클러스터 소프트웨어의 한 계층은 클러스터 노드에서 실행된다.   
            - __각 노드는 LAN을 통해 하나 이상의 다른 노드들을 감시할 수 있다.__   
            - __감시된 머신이 실패하면, 모니터하고 있는 머신은 감시된 머신의 저장 공간의 소유권을 가져오고 실패한 머신에서 실행되고 있던 앱을 재실행시킬 수 있다.__    
            - 앱의 사용자와 고객은 단지 아주 짧은 멈춤 현상만 보게 된다.   
            
      - __Cluster 2가지 구성 방법__   
         - __Asymmetric clustering__   
            - __하나의 기계는 다른 기계가 앱을 실행하는 동안 hot-standby(상시 대기)모드에 있다.__       
            - __상시 대기 모드에 있는 기계는 활성화된 서버를 감시하는 것외에는 다른 작업을 수행하지 않는다.__   
            - __활성화된 서버가 실패한다면, 상시 대기 모드에 있는 것이 활성화된 서버가 된다.__   
            
         - __Symmetric clustering__    
            - __두 개 이상의 기계가 앱을 실행하고 서로 감시한다.__    
            - __이용가능한 하드웨어를 모두 사용하기 때문에 더 효율적인 구조이지만 하나 이상의 앱이 실행 가능한 실행 가능한 상태여야만 한다.__    
      - __Cluster는 네트워크를 통해 연결된 다수의 컴퓨터로 구성되어 있기 때문에 고성능 연산 환경을 제공하기 위해 사용될 수도 있다.__    
         - __Cluster안에 있는 모든 컴퓨터에서 동시에 하나의 앱을 실행시킬 수 있기 때문에, SMP 시스템 또는 단일 프로세서보다 더 큰 연산 능력을 제공할 수 있다.__   
            - __앱은 반드시 클러스터의 이점을 이용하기 위해 작성되어야하지만 하나의 프로그램을 클러스터에 있는 각각의 컴퓨터가 병행으로 실행할 수 있게 분리된 요소로 나누는 "병렬화"라는 기술과 관련이 있다.__   
            - __이러한 앱은 클러스터에 있는 각 연산 노드가 문제의 자신의 할당량을 해결하면, 모든 노드가 최종 해답으로 결합되게 설계된다.__   
      - __Parallel cluster__    
         - __다수의 호스트가 공유 저장 공간에서 같은 데이터에 접근할 수 있다.__   
         - __대부분 OS가 다수의 호스트에 의한 동시적인 데이터의 접근을 제공하지 않기 때문에 Parallel cluster는 특별 배포된 앱과 특별 버전의 소프트웨어가 필요하다.__   
         - __공유 접근을 제공하기 위해서, 시스템은 반드시 충돌하는 작업이 없는 것을 보장하기 위해서 락킹 또는 접근 제한을 제공해야한다.__    
            - 이러한 기능은 Distributed Lock Manager(DLM)이라 알려져있고 일부 클러스터 기술에 포함되어 있다.   
            
      - __Cluster 기술의 발전이 가능했던 이유__   
         - __Storage-Area Networks(SANs)__   
            - __많은 시스템을 저장공간의 저장소(pool)에 연결한다.__   
            - __앱과 앱 데이터가 SAN에 저장되어 있으면, Cluster 소프트웨어는 앱을 SAN에 붙어있는 any 호스트에서나 실행할 수 있게 할당할 수 있다.__   
            - __만약 해당 호스트가 실패 시, 다른 호스트가 넘겨받는다.__   
            </br><p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_8_ClusteredSystem.jpg" width="400px" height="300px" style="display: block; margin: 0 auto" title="1_8_ClusteredSystem.jpg" alt="1_8_ClusteredSystem.jpg"><br><strong>1.8 클러스터 시스템의 일반적인 구조</strong></p>
   
   
### 1.4 Operationg-System Structure(운영체제 구조)   
   - __멀티 프로그래밍은 CPU가 항상 실행시킬 수 있는 작업을 가질 수 있게 하기 위해 작업(code and data)을 체계화함으로써 CPU 이용률을 증가시킨다.__   
   
   - __메인 메모리는 모든 작업을 담기에는 너무 작기 때문에 모든 작업은 처음에 디스크에 있는 job pool(작업 저장소)에 저장된다.__ :star:   
      - __job pool은 디스크에 상주하면서 메인 메모리의 할당을 기다리는 모든 프로세스로 구성되어 있다.__   
      - 메모리에 있는 job의 집합은 job pool에 저장된 job들의 부분 집합일수도 있다.   
      - __OS는 job들 중 하나를 메모리로 가져와 수행하는데 선택된 job은 입출력같은 동작이 끝날때까지 기다려야할 수도 있다.__   
         - __Non-multiprogrammed system__   
            - CPU는 첫 번째 job의 입출력같은 동작이 끝날때까지 idle 상태로 있다.   
         - __Multiprogrammed system__    
            - OS가 첫 번째 job의 입출력같은 동작이 수행되는 동안, 다른 job을 가져와 실행시킨다.   
            - 두 번째 job도 입출력같은 동작이 끝나기를 기다려야만 할 때, CPU는 다른 job으로 변경하고 이러한 과정을 반복한다.   
            - 결국, 첫 번째 작업이 기다리는 것을 끝내면, CPU를 다시 되찾아온다.   
            - 적어도 실행할 작업이 하나라도 있는한, CPU는 절대 idle 상태가 되지 않는다.    
            
            <br><p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_9_MemoryLayout.jpg" width="250px" height="300px" style="display: block; margin: 0 auto" title="1_9_MemoryLayout.jpg" alt="1_9_MemoryLayout.jpg"><br><strong>1.9 멀티 프로그래밍을 위한 메모리 </strong></p>
            
   - __Time sharing(Multitasking)__ :star:   
      - __멀티 프로그래밍의 논리적인 연장이다.__    
      - __시분할 시스템에서 CPU는 여러 작업사이에서 전환함으로써 다수의 작업을 실행할 수 있다.__    
         - 작업 전환이 아주 빈번하게 일어나서 사용자들은 각 프로그램이 실행되는 동안 각 프로그램과 상호작용할 수 있다.   
      - 사용자와 시스템 사이에서 직접 통신을 제공하는 대화식 컴퓨터 시스템이 필요하다.    
      - 사용자는 키보드, 마우스, 터치스크린같은 입력장치를 사용하여 OS나 프로그램에 직접적으로 명령을 내리고 출력장치의 즉각적인 결과를 기다린다.   
         - 응답 시간은 보통 1초 이하여야 한다.   
         
      - __시분할 OS는 많은 사용자들이 컴퓨터를 동시에 공유할 수 있게 한다.__     
         - 시분할 시스템에서 각 명령 또는 행동이 짧은 경향이 있기 때문에, 각 사용자를 위해서 오직 적은 CPU 시간만 필요하다.   
         - 시분할 시스템은 다른 사용자로 빠르게 전환하기 때문에, 각 사용자는 전체 컴퓨터 시스템이 많은 사용자 사이에 공유됨에도 불구하고 자신에게만 집중하는 것 같은 인상을 받는다.   
         
      - __각 사용자에게 시분할 컴퓨터의 작은 양을 제공하기 위해 CPU 스케줄링과 멀티프로그래밍을 사용한다.__      
         - 각 사용자는 메모리에 적어도 하나의 개별 프로그램을 가지고 있다.   
         - __프로세스 = 메모리에 적재되고 실행되고 있는 프로그램__   
         - 시분할과 멀티 프로그래밍은 여러 작업들이 동시에 메모리에 적재되어야 한다.   
            - __작업들이 메모리로 적재될 준비가 됐지만 메모리에 충분한 공간이 없을 경우__   
               - 시스템이 무엇을 적재할지 선택해야 한다. = Job Scheduling    
               
            - __작업들이 같은 시점에 실행할 준비가 된 경우__   
               - 시스템이 무엇을 먼저 실행시킬지 선택해야 한다. = CPU Scheduling   
               
      - __시분할 시스템에서 OS는 반드시 합리적인 반응 속도를 보장해야 한다.__       
         - 프로세스들이 메모리 <-> 디스크로 swapping되면서 보장될 때도 있다.   
         - 이러한 합리적인 반응 속도를 보장하는 일반적인 방법은 가상 메모리이다.   
            - 메모리에 완벽하게 적재되지 않은 프로세스의 실행이 가능하다.   
            - 가상 메모리의 주 이점은 사용자들이 실제 물리적 메모리보다 더 큰 프로그램을 실행가능하게 하는 것이다.   
            - 메인 메모리를 크고 균일한 저장 공간의 배열로 추상화하여 물리 메모리를 사용자에게 보이는 것과 같은 논리 메모리로 분리한다.   
            - 프로그래머들에게 메모리 저장 공간 한계로부터 자유로워질 수 있게 해준다.   
            - 시간 분할 시스템은 파일 시스템을 반드시 제공해야하고 디스크 관리도 제공되어야 한다.    
               - 파일 시스템은 디스크에 들어있다.   
            - 시간 분할 시스템은 부적절한 사용자로부터 자원을 보호하기 위한 메카니즘을 제공한다.   
            - 순차적인 실행을 보장하기 위해서 작업 동기화와 통신을 위한 메카니즘을 제공해야 한다.   
               - 작업이 데드락 상태에 빠지지 않게 보장해줄 수 있다.   
               
   
### 1.5 Operationg-System Operations(OS 동작)   

   - __현대 OS는 interrupt driven이다.__ :star:   
      - 실행할 프로세스가 없고, 서비스할 입출력 장치가 없고, 응답할 사용자가 없다면, OS는 무언가 발생할때까지 조용히 기다린다.   
      - 이벤트는 거의 항상 trap이나 인터럽트의 발생에 의해 발생한다.   
      - __trap(= exception)__   
         - 오류(예를 들어, 0으로 나누기, 잘못된 메모리 접근)에 의해 발생하거나 수행되어야 할 OS 서비스인 사용자 프로그램으로부터 특별한 요청의 의해 발생하는 소프트웨어적 인터럽트이다.   
    
   - __OS와 사용자는 하드웨어와 컴퓨터 시스템의 소프트웨어 자원을 공유하기 때문에, 사용자 프로그램에서 발생하는 에러가 실행되고있는 프로그램에 대해서만 문제를 야기하는지 확실히 해야한다.__   
      - 자원 공유로 인해 많은 프로세스들은 하나의 프로그램의 버그에 의해 영향을 받을 수 있다.   
         - ex) 하나의 프로세스가 무한 루프에 빠졌을 경우, 이 무한 루프는 다른 프로세스의 실행을 방해할 수도 있다.   
      - 더 감지하기 힘든 오류는 멀티 프로그래밍 시스템에서 발생할 수 있다.   
         - 하나의 오류적인 프로그램이 다른 프로그램과 다른 프로그램의 데이터 수정 또는 OS 자체를 수정할 수 있다.   
      - 이러한 에러들에 대한 보호가 없으면 컴퓨터는 항상 하나의 프로세스만 실행하거나 모든 결과물을 의심해야만 한다.   
      
   - __적절하게 설계된 os는 반드시 악성 또는 잘못된 프로그램이 다른 프로그램을 부적절하게 실행시킬 수 없게 보장해야만 한다.__   
   
   
#### 1.5.1 Dual-Mode and Multiple Operation(듀얼 모드와 여러 동작)    

   - __OS의 적절한 실행을 보장하기 위해서, OS 코드의 실행과 사용자 정의 코드의 실행을 구분할 수 있어야만 한다.__   
      - 대다수 컴퓨터 시스템에서 선택한 방식은 다양한 실행 모드를 구별할 수 있게 하는 하드웨어 지원을 제공하는 것이다.   
      
   - __적어도, 2개의 분리된 동작 모드가 필요하다.__ :star:     
      - __사용자 모드__   
      - __커널 모드__   
      - __`mode bit`라고 불리는 비트는 현재 모드를 나타내기 위해서 하드웨어에 추가된다.__   
         - 커널 모드 = 0   
         - 사용자 모드 = 1   
         - mode bit를 통해 OS 또는 사용자를 위해 실행되는 작업들을 구별할 수 있게 된다.   
            - ex) 컴퓨터 시스템이 사용자 app을 위해서 실행되고 있을 경우, 시스템은 사용자 모드에 있다.   
            - 하지만 사용자 app이 시스템 호출을 통하여 OS에 서비스를 요청할 때, 시스템은 요청된 서비스를 수행하기 위해 반드시 사용자 모드에서 커널 모드로 전환해야 한다.   
               
            <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_10_UserToKernelMode.jpg" width="800px" height="200px" title="1_10_UserToKernelMode" alt="1_10_UserToKernelMode"></img><br><strong>1.10 사용자 모드에서 커널 모드로 전환</strong></p>
         
   - __시스템 부트 시간에 하드웨어는 커널 모드에서 시작한다.__   
      - OS는 사용자 모드에서 불러와지고 사용자 app을 실행시킨다.   
      - trap이나 인터럽트 발생시마다 하드웨어는 사용자 모드 -> 커널 모드로 전환한다. 1 -> 0   
      - OS는 컴퓨터의 통제권을 얻을 때마다, 커널 모드에 있다.   
         - OS는 항상 사용자 프로그램을 통제하기 전에 사용자 모드로 전환한다.   
   
   - __Dual-mode는 부적절한 사용자로부터 OS를 보호한다.__   
      - 특권 명령(priviledged instruction)같이 악영향을 끼칠 수 있는 일부 기계 명령어를 설계함으로써 이러한 보호를 수행할 수 있다.   
      - 하드웨어는 특권 명령이 오직 커널 모드에서만 실행될 수 있게만 허락한다.   
         - 만약 사용자 모드에서 특권 명령을 실행시키려는 시도가 있을 경우, 하드웨어는 그 명령을 수행하지 않고 오히려 불법적인 것으로 간주하고 OS로 trap(exception)을 일으킨다.   
      - 커널 모드로 전환하는 명령어도 특권 명령의 예이며, 입출력 통제, 타이머 관리, 인터럽트 관리 등이 포함된다.   
   
   - __모드의 개념은 확장 될 수 있다.__   
      - 가상화를 제공하는 CPU들은 시스템의 통제 안에 있는 Virtual Machine Manage(VMM)과 Virtual Management Software(VMS)를 나타내기 위한 개별 모드를 가지고 있다.   
      - 이러한 모드에서, VMM은 사용자 프로세서보다는 더 많은 특권을 가지지만 커널 보다는 적은 특권을 가진다.   
      - CPU 상태를 변경하면서 가상 머신을 생성하고 관리할 수 있게 할 수 있는 특권 레벨이 필요하다.   
    
   - __컴퓨터 시스템에서 명령어 수행 라이프 사이클__   
      1. 명령어들이 커널 모드에서 실행되는 OS에 초기 통제가 존재한다.   
      2. 통제가 사용자 app으로 넘어갈 때, 모드는 사용자 모드가 된다.   
      3. 통제가 시스템 호출 또는 trap 또는 인터럽트를 통해 OS로 넘어온다.   
      
   - __시스템 호출은 OS의 기능을 요청하기 위해서 프로세스에 의해 사용되는 수단이다.__   
      - 시스템 호출은 보통 인터럽트 벡터에서 특정 위치에 trap의 형식을 가지고 있다.   
         - __인터럽트 벡터__   
            - 인터럽트가 발생했을 때, 그 인터럽트를 처리할 수 있는 서비스 루틴들의 주소를 가지고 있는 공간   
      - 해당 trap은 generic trap 명령에 의해 수행되어질 수 있지만, 일부의 시스템은 시스템 호출을 일으키기 위한 특정 'syscall' 명령어를 가진다.   
      
   - __시스템 호출이 실행될 때, 하드웨어는 시스템 호출을 소프트웨어 인터럽트로 취급한다.__   
      - 통제는 인터럽트 벡터를 통해 OS의 서비스 루틴으로 이동하고 mode bit는 커널 모드(0)로 설정된다.   
      - 서비스 호출 서비스 루틴은 OS의 한 부분이다.   
      - 커널은 어느 시스템 호출이 발생했는지 확인하기 위해서 인터럽트 명령어를 조사한다.   
      - 파라미터는 사용자 프로그램이 어떤 종류의 서비스를 요청하는 것인지 나타낸다.   
      - 요청을 위해 필요한 추가적인 정보는 레지스터에 스택형식으로 전달되거나 메모리에 전달될 수도 있다.   
      - 커널은 파라미터가 정확하고 올바른지 확인하고, 요청을 수행하며, 시스템 호출로 이어지는 명령어에 통제를 반환한다.   
   
   - __하드웨어가 듀얼 모드를 지원하지 않는 것은 OS의 큰 단점으로 이어질 수 있다.__   
      - 현대 CPU는 모두 듀얼 모드를 지원하고, 대부분 현대 OS는 듀얼 모드의 특성을 잘 이용하고, OS를 위한 더 큰 보호를 제공한다.   
     
   - __하드웨어 보호가 발생하면 모드를 위반하는 에러를 탐지한다.__  
      - 이러한 오류는 보통 OS에서 처리한다.   
      - 부적절한 명령어 실행이나 잘못된 메모리 주소에 접근할 경우 하드웨어는 OS에 trap을 발생시킨다.   
         - trap은 통제를 인터럽트 벡터를 통해서 OS로 전달한다.   
      - 프로그램이 에러를 발생시킬 때, OS는 비정상적으로 프로그램을 종료시킨다.   
         - 이러한 상황은 사용자 요청 비정상적인 종료와 같은 코드에 의해 처리된다.    
         - 적절한 에러 메세지가 주어지고 프로그램의 메모리는 제거될 수 있다.   
         - 메모리 덤프는 사용자 또는 프로그래머가 에러를 검사하고 수정하고 프로그램을 재시작하기 위해서 파일에 작성된다.   
         - __메모리 덤프__   
            - 시스템의 물리 메모리를 파일 형태로 저장하는 방법으로, 해당 파일의 구조는 실제 물리 메모리 구조와 동일하다.   
   
   
#### 1.5.2 Timer(타이머)   

   - __OS가 CPU를 통해서 통제를 유지할 수 있게 보장해야만 한다.__   
      - 보통 사용자 프로그램이 무한 루프에 갇히거나, 시스템 서비스 호출하는 것을 실패하거나, OS로 통제를 반환하지 않는 것은 허락되지 않는다   
      - 이러한 목표를 성취하기 위해서 타이머를 사용한다.   
         - 타이머는 특정 시간 후 컴퓨터를 인터럽트하기 위해 설정될 수 있다.   
         - 시간은 고정될 수도 있지만 변경도 가능하다.   
      - 타이머 변수는 보통 고정된 비율의 시계와 카운터에 의해 구현된다.   
         1. OS가 카운터 설정   
         2. 시간이 흐르면서 카운터 감소   
         3. 카운터 0이 될 때, 인터럽트 발생   
   
   - __사용자에게 통제를 반환하기전에 OS는 타이머가 인터럽트하기 위해 설정되어 있다는 것을 보장해야한다.__   
      - 타이머가 인터럽트 할 때, 통제는 자동으로 OS로 넘어가고 OS는 해당 인터럽트를 심각한 오류로 처리하거나 프로그램에 시간을 더 줄 수도 있다.   
      - 타이머의 내용을 수정하는 명령어는 privileged다.   
      
   - __사용자 프로그램이 너무 오래 실행되는 것을 예방하기 위해 타이머를 사용할 수 있다.__    
      - 카운터를 프로그램에 허락된 시간만큼 설정한다.   
         - ex) 7분짜리 프로그램은 카운터가 420으로 초기화되고, 매초마다 타이머는 인터럽트하고 카운터는 1씩 줄어든다.   
         - 양수면 사용자 프로그램으로 통제 반환, 음수면 OS가 프로그램 종료한다.   
   
### 1.6 Process Management    
   
   - __프로그램은 자신의 명령어가 CPU에 의해 실행되는 것을 제외하고는 아무것도 하지 않는다.__   
     
   - __프로세스는 CPU 시간, 메모리, 파일, 입출력 장치 등 특정 자원이 필요하다.__   
      - 프로세스가 생성될 때나 프로세스가 실행되는동안 자원이 할당된다.   
      
   - __프로그램은 디스크에 저장된 파일의 내용과 같은 수동적 개체__   
   - __프로세스는 능동적 개체__   
      - 단일 스레드 프로세스는 실행할 다음 명령어를 명시하는 하나의 프로그램 카운터를 가진다.   
         - 이러한 프로세스의 실행은 반드시 순차적이여야 한다.   
      - 멀티 스레드 프로세스는 주어진 하나의 스레드에서 실행할 다음 명령어를 가르키는 다수의 프로그램 카운터를 가진다.   
   
   - __프로세스는 시스템에서 작업의 단위이다.__   
      - 시스템은 프로세스들의 집합체로 구성되어 있고, 일부 프로세스는 OS 프로세스(시스템 코드 실행), 나머지는 사용자 프로세스(사용자 코드 실행)이다.   
      - 모든 프로세스는 단일 CPU에서 멀티플렉싱에 의해 동시에 실행될 수 있다.   
      
   - __OS가 프로세스 관리에 관련해서 책임이 있는 활동__   
      - 여러 CPU에서 스레드와 프로세스 스케줄링   
      - 사용자, 시스템 프로세스의 생성과 삭제   
      - 프로세스 중단, 재개   
      - 프로세스 동기화를 위한 메카니즘 제공   
      - 프로세스 통신을 위한 메카니즘 제공   

### 1.7 Memory Management    

   - __메인 메모리는 거대한 byte 배열이다.__   
      - 각 byte는 자신 고유 주소를 가진다.      
      - CPU와 입출력 장치에 의해 공유된 빠르게 접근 가능한 데이터의 저장소이다.   
   
   - __중앙 프로세서는 명령어 fetch 사이클 동안 메인 메인 메모리에서 명령어를 읽어오고 데이터 fetch 사이클 동안 메인 메모리에서 데이터를 읽고 쓴다.__    
       
   - __메인 메모리는 CPU가 직접적으로 다루고 접근 할 수 있는 단 하나의 큰 저장 장치이다.__   
      - 디스크에 있는 데이터를 CPU가 처리해야 할 경우, 데이터는 반드시 CPU가 발생시킨 입출력 호출에 의해 메인 메모리로 전송되야 한다.      
      - 같은 방식에서, CPU가 명령어를 실행시키려면 명령어도 반드시 메모리에 있어야 한다.      
      
   - __프로그램이 실행되기 위해서 반드시 절대적인 주소로 매핑되고 메모리로 적재되야 한다.__   
      - 프로그램을 실행하면서 프로그램 데이터와 명령어들의 절대적인 주소를 생성함으로써 프로그램이 메인 메모리로부터 명령어와 데이터에 접근할 수 있다.   
      - 결과적으로 프로그램이 종료되면, 종료된 프로그램의 메모리 공간은 이용 가능하다고 선언되어 다음 프로그램이 적재되고 실행될 수 있다.      
   - __CPU 이용률과 사용자에 대한 컴퓨터 반응속도를 향상시키기 위해서 일반 컴퓨터는 반드시 메모리 관리에 대한 요구를 생성하면서 메모리에 여러 프로그램을 가지고 있어야 한다.__    
   
   - __특정 시스템을 위한 메모리 관리 구조를 정할 때, 특히 시스템의 하드웨어 설계를 고려해야 한다.__   
      - 각 알고리즘은 자신 고유의 하드웨어 지원이 필요하기 때문이다.   
      
   - __OS가 메모리 관리에 관련해서 책임이 있는 활동__   
      - 메모리의 어느 부분이 현재 사용되고 누가 사용하는지 추적하기      
      - 어느 프로세스와 데이터가 메모리로 적재되거나 해제되어야할 지 결정하기   
      - 필요한 만큼의 메모리 공간 할당, 해제   


### 1.8 Storage Management        

   - __사용자를 위해서 컴퓨터 시스템을 편리하게 만들기 위해, OS는 저장 공간 정보의 균일하고 논리적안 관점을 제공해야 한다.__      
   - __OS는 논리적 저장 단위인 파일을 정의하기 위해 저장 장치의 물리적 특성을 추상화한다.__    
   - __OS는 파일을 물리적 매체(저장 장치)에 매핑하고 저장 장치를 통해 이러한 파일에 접근한다.__      
      
#### 1.8.1 File-System Management(파일 시스템 관리)    

   - __컴퓨터는 자기 디스크, 광 디스크, 자기 테이프 같은 물리적 장치에 정보를 저장할 수 있다.__   
      - 각 장치마다 접근 속도, 수용량, 데이터 전송률, 접근 방법 등 자신만의 특성을 가진다.      
      
   - __파일은 프로그램과 데이터를 나타낸다.__    
      - 데이터 파일은 nemeric, alphabetic, alphanumeric, binary 일 수 있다.      
      - 파일은 자유 형식(text)이나 엄격한 형식으로 되어 있을 수 있다.   
      - 파일은 사용하기 쉽게 하기 위해 디렉토리로 체계화된다.   
      
   - __OS가 파일 관리에 관련해서 책임이 있는 활동__   
      - 파일들을 체계화하기 위해 디렉토리 생성, 삭제   
      - 파일과 디렉토리를 조작하기 위한 기본 요소 제공 
      - 파일들을 2차 저장 장치에 매핑   
      - 안전한(비휘발성) 저장 장치에 파일 백업   
      
#### 1.8.2 Mass-Storage Management(거대 저장 장치 관리)     
       
   - __데이터는 전원이 나가면 사라지기 때문에, 컴퓨터 시스템은 반드시 메인 메모리를 백업하기 위해 2차 저장 장치를 제공해야만 한다.__   
      - 대부분 프로그램은 메모리로 적재될 때 까지 디스크에 저장되어 있다.   
      - 프로그램은 처리의 시작과 종착지로 디스크를 사용한다.   
      
   - __OS가 디스크 관리에 관련해서 책임이 있는 활동__ 
      - 빈 공간(Free-space) 관리   
      - 저장 공간 할당 
      - 디스크 스케줄링      
      
   - __2차 저장 장치는 자주 사용되기 때문에 반드시 효율적이게 사용되어야 한다.__   
      - 컴퓨터의 전체 작업 속도는 디스크 서브 시스템의 속도와 서브 시스템을 조작하는 알고리즘에 달려있다.   
      
   - __2차 저장 장치보다 싸고 느린 저장 장치도 많이 사용한다.__   
      - ex) 디스크 데이터 백업, 좀처럼 사용하지 않는 데이터의 저장, 장기 기록용 저장 공간 등  
      
   - __자기 테이브 드라이브, Tape, CD, DVD, Platter는 제 3의 저장 장치이다.__   
      - WOMR(Write-Once, Read-Many) 과 RW(Read-Write) 형식 사이에 다양하게 존재한다.   
      - 시스템 성능에 중요하지는 않지만 반드시 관리되야 한다.       
     
#### 1.8.3 Caching(캐싱) :star:    
   
   - __정보는 일반적으로 메인 메모리와 같은 일부 저장 시스템에 저장되어 있다.__   
      - 정보가 사용될 떄, 임시로 더 빠른 저장 시스템인 Cache에 복사된다.      
      - 정보의 특정 부분이 팔요할 때, 먼저 Cache에 있는지 확인한다.   
         - Cache에 있을 경우, 바로 사용   
         - Cache에 없을 경우, 원래 저장 시스템에서 해당 정보를 가져와 사용하고 해당 정보를 곧 다시 필요로 할 것이라는 가정하에 Cache에 복사해 놓는다.   
         
   - __인덱스 레지스터와 내부 프로그램이 가능한 레지스터는 메인 메모리를 위한 고속 Cache를 제공한다.__   
      - 프로그래머(또는 컴파일러)는 어느 정보를 레지스터에 저장하고 어느 정보를 메인 메모리에 저장하는 지를 결정하기 위한 레지스터 할당, 레지스터 교체 알고리즘을 구현한다.      
      - 다른 Cache들은 완전히 하드웨어에서 구현된다.   
         - 대부분 시스템은 다음에 실행될거라 예상된 명령어를 수용하기 위한 명령어 Cache를 가지고 있다.     
         - 이러한 Cache가 없으면, 명령어가 메인 메모리로부터 fetch되는 동안 CPU는 여러 사이클을 기다려야만 할 것이다.      
         - 비슷한 이유로, 대부분 시스템은 메모리 계층에서 하나 이상의 고속 데이터 Cache를 가지고 있다.   
         
   - __Cache는 크기가 제한되어 있기 때문에, Cache 관리는 중요한 설계 문제이다.__   
      - Cache 크기와 교체 정책의 주의 깊은 선택은 매우 향상된 성능을 가져올 수 있다.      
      
      <p align = "center"><img src = "https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_11_StoragePerformance.jpg" width="600px" height="300px" title="1_11_StoragePerformance" alt="1_11_StoragePerformance"></img><br><strong>1.11 저장 장치 성능</strong></p>
      
   - __메인 메모리를 2차 저장 장치를 위한 빠른 Cache로 볼 수도 있다.__   
      - __2차 저장 공간에 있는 데이터는 사용을 위해 반드시 메인 메모리로 복사되어지기 때문에, 데이터는 보호를 위해 2차 저장 공간으로 옮겨지기 전에 반드시 메인 메모리에 있어야 한다.__     
      - 2차 저장 공간에 영구적으로 존재하는 파일 시스템 데이터는 저장 장치 계층의 여러 단계에서 보여질 수 있다.   
         - 가장 높은 단계에서, OS는 메인 메모리에 파일 시스템의 Cache를 유지시킬 수도 있다.   
         - 대부분의 2차 저장 공간은 자기 디스크에 있다.   
            - 자기 디스크 저장 공간은 하드디스크 실패할 경우 데이터 손실을 막기 위해 자기 테이프나 이동 가능한 디스크(usb, card reader 등)에 백업되기도 한다.   
         - 일부 시스템은 저장 내용을 줄이기 위해 오래된 파일 데이터를 2차 저장 공간에서 tape jukebox 같은 제 3의 저장 장치로 옮겨 보관한다.   
         
   - __저장 계층 사이에 정보의 이동은 하드웨어 설계와 OS 소프트웨어 통제에 따라 명확히 보이거나 아닐 수도 있다.__   
      - Cache -> CPU, Register로 데이터 전송은 보통 OS 개입이 없는 하드웨어의 기능이다.       
      - Disk -> Memory로 데이터 전송은 보통 OS에 의해 통제된다.   
      
   - __계층적인 저장 구조에서 동일한 데이터가 다른 저장 시스템 단계에 있을 수도 있다.__ :star:     
      - ex) 1씩 증가하는 정수 A가 파일 B에 위치해있고 파일 B는 자기 디스크에 있다.   
         - 증가 연산은 디스크 블록을 A가 있는 메인 메모리에 복사하기 위해 입출력 명령을 발행함으로써 진행된다.   
         - A를 Cache와 내부 레지스터에 복사한다.   
         - A의 복사본은 내부 레지스터, Cache, 메인 메모리, 자기 디스크 등 여러 곳에서 발견된다.   
         
         <p align = "center"><img src = "https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_12_IntegerMigration.jpg" title="1_12_IntegerMigration" alt="1_12_IntegerMigration"></img><br><strong>1.12 디스크에서 레지스터로 정수 A의 이동</strong></p>   
         
         - 증가가 내부 레지스터에서 발생하면, 다양한 저장 시스템에 있는 A의 값은 다르다.   
         - A의 새로운 값이 내부 레지스터에서 자기 디스크로 다시 기록된 후에만 A의 값이 같은 값으로 변한다.   
         - 프로세스가 한번에 하나씩 실행되는 컴퓨팅 환경에서는 정수 A에 대한 접근이 항상 계층의 가장 높은 단계에 있는 복사본이 되기 때문에 이러한 방법을 사용하는데 있어 어떠한 어려움이 없다.
         - __CPU가 여러 프로세스 사이에 전환되는 멀티태스킹 환경에서는 아주 세심한 주의가 필요하다.__   
            - 여러 프로세스가 A에 접근하길 원한다면, 각 프로세스는 가장 최근에 업데이트된 A를 가져와야 한다.   
            - 내부 레지스터를 유지할뿐만 아니라 각 CPU가 지역 Cache를 포함하고 있는 이러한 멀티태스킹 환경에서는 위의 상황이 더 복잡해진다.   
               - A의 복사본은 동시에 여러 Cache에 존재한다.   
               - 다양한 CPU가 모두 병렬로 실행할 수 있기 때문에, 하나의 Cache에 있는 A의 값의 업데이트는 반드시 A가 있는 다른 모든 Cache에 즉시 반영되어야 한다.   
               - 이것을 "Cache Coherency"라고 하고 보통 하드웨어가 처리한다.         
               
         - __분산된 환경에서는 훨씬 더 복잡해질 수 있다.__   
            - 같은 파일의 여러 복사본들이 다른 컴퓨터에 저장될 수 있다.   
            - 다양한 복사본들이 동시에 업데이트, 접근될 수도 있기 때문에 한 장소에서 복사본이 업데이트 되었을 때, 모든 다른 복사본들도 가능한한 빨리 최신으로 업데이트 되야한다.   
               
#### 1.8.4 I/O Systems(입출력 시스템)    
   
   - __OS의 목적 중 하나는 사용자로부터 특정 하드웨어 장치의 특성을 감추는 것이다.__   
      - ex) UNIX에서는 입출력 서브시스템에 의해 입출력 장치들의 특성들이 가려진다.   
  
   - __입출력 서브시스템 구성 요소__    
      - 버퍼링, 캐싱, 스풀링을 포함하는 메모리 관리 요소  
      - 공용 장치 드라이버 인터페이스   
      - 특종 하드웨어 장치를 위한 드라이브     
   
   - __오직 장치 드라이버만이 장치에 할당된 특성을 안다.__   
   
### 1.9 Protection and Security    

   - __컴퓨터 시스템이 여러 사용자를 가지고 있고 다수의 프로세스의 동시 실행을 허락한다면 데이터에 대한 접근은 반드시 제한되야 한다.__   
      - 파일, 메모리 세그먼트, CPU 등 자원들은 반드시 OS로부터 적절한 권한을 얻은 프로세스에 의해서만 작동되는 것을 보장해야 한다.       
         - ex) Memory-addressing hardware는 프로세스가 자신의 주소 공간에서만 실행할 수 있도록 보장한다.   
      - 타이머는 어떠한 프로세스도 결국에는 CPU의 권한을 내주는 것 없이는 CPU의 권한를 얻을 수 없는 것을 보장한다.   
      - Device-Control 레지스터에는 사용자가 접근할 수 없어서, 다양한 주변 장치의 무결성(완전성)이 보호된다.   
      
   - __보호는 컴퓨터 시스템에 의해 정의된 자원들에 사용자나 프로세스의 접근을 통제하기 위한 메카니즘이다.__   
      - 반드시 권한를 강화하고 부여된 권한를 명시하기 위한 수단을 제공해야 한다.    
   
   - __구성 요소 서브 시스템 사이에 있는 인터페이스에 잠복해있는 에러를 감지함으로써 의존성을 향상시킬 수 있다.__   
      - 인터페이스 에러의 초기 감지는 제대로 기능하지 않는 서브 시스템에 의한 건강한 시스템의 오염을 방지할 수 있다.    
      - 보호되지 않은 자원은 무능하거나 권한을 얻지 못한 사용자에 의한 사용을 보호할 수 없다.       
      - 보호 지향 시스템은 권한을 얻거나 얻지 못한 사용을 구별할 수 있는 수단을 제공한다.   
   
   - __시스템은 적절한 보호를 가지고 있음에도 불구하고 부적절한 접근을 허락하거나 보호를 실패하는 경향이 있다.__    
      - ex) 시스템에 있는 자신의 신원 정보가 훔쳐졌을 경우, 파일과 메모리 보호가 작동하는데도 불구하고 해당 정보가 복사되거나 삭제될 수 있다.     
      - 보안은 내외부 공격으로부터 시스템을 보호하는 일을 한다.   
         - 공격에는 virus, worm, denial-of-service, identity theft, theft of service가 있다.   
         - 일부 시스템에서 공격의 예방은 OS의 기능으로 할 수 있다고 고려된다.   
            - 보안 사고를 경보(알람)을 하기 때문에, OS 보안 특징은 급성장하는 조사, 실행 영역에서 나타난다.   
   
   - __보호와 보안은 시스템이 모든 사용자를 구별할 수 있는 것을 필요로 한다.__    
      - 대부분 OS는 사용자 이름과 관련된 User Identification(User IDs)의 목록을 가지고 있다.   
      - Window 용어로는 Security ID(SID)라고 한다.   
      - 사용자가 시스템에 로그인 할 때, 인증 단계에서 해당 사용자에 대한 적절한 사용자 ID를 결정한다.   
         - 해당 사용자 ID는 해당 사용자의 모든 프로세스, 스레드와 관련되어 있다.   
      - ID가 사용자에 의해 읽혀져야 할 때, ID는 사용자 이름 목록을 통해 사용자 이름으로 번역된다.   
      
   - __일부 상황에서는, 각각의 사용자보다 사용자 그룹을 구분하기를 원할 수 있다.__    
      - Unix에서는 각각의 사용자가 아니라 그룹을 구별하기 위해 그룹 이름과 해당 그룹에 속한 사용자들의 집합을 정의한다.      
      - 그룹 기능은 전체 시스템의 그룹 이름의 목록과 그룹 식별자로 구현될 수 있다.   
      - 사용자는 하나 이상의 그룹에 있을 수 있고 해당 사용자의 그룹 ID는 모든 관련된 프로세스, 스레드를 포함한다.       
      
   - __사용자는 가끔 어떤 작업을 하기 위해 권한을 확대시킬 필요가 있다.__   
      - ex) Unix에서 'setid'는 현재 사용자 ID가 아니라 파일 소유자의 사용자 ID로 프로그램을 작동시킬 수 있다.  
      - 이러한 프로세스는 추가 권한이 사라지거나 종료될 때까지 효율적인 UID로 작동한다.      
 
 ### 1.10 Kernel Data Structures         
 #### 1.10.1 Lists, Stacks, and Queues(리스트, 스택, 큐)        
 
   - __Array(배열)__   
      - 각 요소가 직접적으로 접근될 수 있는 간단한 데이터 자료구조   
      - ex) Main memory는 배열로 구성되어 있다.     
      - 저장될 item의 data가 1 byte보다 클 때, 다수의 byte가 해당 item에 할당될 수 있고, 해당 item은 (item 넘버 ~ item 넘버 * item 크기) 주소를 가진다.   
      
   - __List(리스트)__   
      - 각 요소가 특정 순서에 의해 접근되는 가장 기본적인 자료구조       
      - 연속적인 데이터 값의 모음을 나타낸다.   
      - 구현하기 위한 가장 흔한 방법은 linked list이다.   
      <p align = "center"><img src = "https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_13_SinglyLinkedList.jpg" title = 1_13_SinglyLinkedList.jpg alter = 1_13_SinglyLinkedList.jpg></img><br><strong>1.13 단일 링크드 리스트</strong></p>   
      - 단일 링크드 리스트는 각 아이템의 바로 뒤를 가르킨다.   
      <p align = "center"><img src = "https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_14_DoublyLinkedList.jpg" title = 1_14_DoublyLinkedList.jpg alter = 1_14_DoublyLinkedList.jpg></img><br><strong>1.14 이중 링크드 리스트</strong></p>   
      - 이중 링크드 리스트는 주어진 아이템의 이전이나 뒤를 참조할 수 있다.
      <p align = "center"><img src = "https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_15_CircularlyLinkedList.jpg" title = 1_15_CircularlyLinkedList.jpg alter = 1_15_CircularlyLinkedList.jpg></img><br><strong>1.15 순환 링크드 리스트</strong></p>    
      - 순환 링크드 리스트는 마지막 요소가 처음 요소를 가르킨다.   
      
      - __링크드 리스트는 다양한 크기의 아이템을 수용하고 아이템의 삽입, 삭제가 쉽다.__    
         - 잠재적인 단점은 검색 시 시간복잡도 = O(n)    
         - 커널 알고리즘에 의해 직접적으로 사용될 때도 가끔 있지만, 스택과 큐 같은 더 강력한 자료구조를 구성하기 위해 자주 사용된다.    
         
   - __Stack(스택)__   
      - __LIFO 구조로 순차적으로 정돈된 자료구조__    
      - Push, Pop 기능을 가지고 있다.   
      - __주로 OS에서 함수 호출 시 스택 사용__ :star:    
         - 함수 호출되었을 때 지역 변수, 파라미터, 반환 주소가 스택에 Push된다.   
         - 함수 반환 시 지역 변수, 파라미터, 반환 주소를 스택에서 Pop한다.  
         
   - __Queue(큐)__   
      - __FIFO 구조로 순차적으로 정돈된 자료구조__   
      - 쇼핑몰 대기, 은행 업무 대기 등 실생활에서 많은 예가 있다.      '
      - OS에서 프린터가 요청한 순서대로 프린트를 한다.   
      - __이용 가능한 CPU에서 실행되기를 기다리는 작업들은 큐에 저장되어 있다.__ :star:

#### 1.10.2 Tree(트리)    

   - __Tree(트리)__    
      - 계층적으로 데이터를 표현할 수 있는 자료구조   
      - 데이터 값들은 부모, 자식 관계를 통해 연결되어 있다.   
      - 일반적으로 트리에서는 부모가 무제한의 자식들을 가질 수도 있다.   
      - __이진 트리에서는 부모가 최대 2개의 자식을 가질 수 있다.__      
         - 왼쪽 자식, 오른쪽 자식   
      - __이진 검색 트리는 왼쪽 자식 <= 오른쪽 자식 이라는 규칙을 요구한다.__ :star:   
         - 최악의 시간복잡도는 O(n)으로 한 쪽으로 극단적으로 노드가 생길 경우이다.   
         - __이러한 문제를 해결하기 위해 Balanced binary search tree를 만들어 사용한다.__   
            - n 개의 아이템을 가질 경우 최대 log n 높이를 가진다.   
            - __최악의 경우 시간복잡도 = O(log n)__    
            - Linux에서 CPU 스케줄링 알고리즘 부분으로 Balanced binary search tree을 사용한다.   
            
      <p align = "center"><img src = "https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_16_BinarySearchTree.jpg" title = 1_16_BinarySearchTree.jpg alter = 1_16_BinarySearchTree.jpg></img><br><strong>1.16 이진 검색 트리</strong></p>   

#### 1.10.3 Hash Functions and Maps(해시 함수와 맵)   

   - __Hash Function(해시 함수)__   
      - input으로 데이터가 필요하고 해당 데이터를 가지고 숫자 연산을 수행하고 숫자 값을 반환한다.   
      - 반환된 숫자 값은 데이터를 빠르게 검색하기 위해 테이블(일반적으로 배열)의 인덱스로 사용될 수 있다.        
      - __테이블에서 데이터를 검색하기 위해 Hash Function을 사용하면 최악의 경우에서도 시간복잡도 = O(1)__   
      - 이러한 이유로 OS에서 광범위하게 사용된다.    
      
   - __해시 함수의 잠재적인 문제점은 두 개의 input이 같은 output 값을 가질 수 있다는 것이다. = 해시 충돌__ :star:      
      - 두 output 값이 같은 테이블 위치에 연결되어 있다는 뜻이다.     
      - __같은 hash값을 가지는 모든 아이템을 가지고 있는 테이블 위치에 링크드 리스트를 가지게 함으로써 이러한 hash collision을 해결할 수 있다.__     
        
   - __해시 함수의 사용법 중 하나는 해시 함수를 사용하여 [key, value] 쌍을 연관짓는 Hash map을 구현하는 것이다.__ :star:       
      - ex) key : Operating 을 value : System 에 map할 수 있다.   
         - 매핑이 성립되면, hash map으로부터 value를 얻기 위해서 hash function를 key에 적용할 수 있다.    
      - ex) key : User id 가 value: Password가 map되었을 경우   
         - 사용자 id, 비밀번호를 입력하면 hash function을 사용자 id에 적용하여 매핑된 비밀번호를 검색하고 검색된 비밀번호를 입력된 비밀번호와 비교한다.   
      
      <p align = "center"><img src = "https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_17_HashMap.jpg" title = 1_17_HashMap.jpg alter = 1_17_HashMap.jpg></img><br><strong>1.17 Hash map</strong></p>

#### 1.10.4 Bitmap(비트맵)   

   - __Bitmap(비트맵)__   
      - __n개의 아이템의 상태를 나타내기 위해 사용될 수 있는 일련의 n개의 이진수이다.__   
      - ex) 여러 개의 자원이 있을 경우, 각 자원의 이용 가능은 이진수의 값에 의해 보여진다.   
         - 0 : 이용 가능, 1 : 이용 불가능 또는  0 : 이용 불가능, 1 : 이용 가능   
      - __i번째 위치의 값은 i번째 자원과 관련되어 있다.__   
         - ex) 0 0 1 0 1 1 1 0 1   
            - 이용 가능한 자원 : 2, 4, 5, 6, 8    
            - 이용 불가능한 자원 : 0, 1, 3, 7   
      - __비트맵의 강점은 공간 효율성을 고려할 때 나타난다.__   
         - 단일 비트 사용 대신 8비트 boolean 값을 사용한다면, 자료구조는 8배 커질 것이다.   
      - __일반적으로 많은 자원들의 이용가능성을 나타낼경우 사용된다.__    
         - ex) 디스크 드라이브   
            - 중간 크기의 디스크 드라이브는 디스크 블록이라고 불리는 수천 개의 개별 유닛으로 나뉠 수도 있고, 비트맵은 각 디스크 블록의 이용가능 상태를 나타내는데 사용될 수 있다.   

        
### 1.11 Computing Environments    
#### 1.11.1 Traditional Computing(전통적인 컴퓨팅)   

   - __Web 기술과 증가하는 WAN 대역푝이 전통적인 컴퓨팅의 경계를 무너뜨리고 있다.__    
      - 회사는 web 접근성을 회사 내부 서버에 제공하는 Portal을 만든다.      
  
   - __네트워크 컴퓨터는 유지보수가 더 쉽고 더 많은 보안이 필요한 전통적인 작업환경 대신 사용된다.__   
      
   - __모바일 컴퓨터는 회사 정보의 사용을 쉽게 하기 위해 PC와 동기화 된다.__   
      - 회사의 web portal을 이용하기 위해 무선 네트워크나 무선 데이터 네트워크에 연결할 수 있다.        
        
   - __많은 집에서 보안 위반으로부터 네트워크를 보호하기 위해 방화벽 사용한다.__    
   
   - __Batch 시스템은 파일이나 다른 데이터 자원으로터 미리 결정된 입력을 가지고 대량으로 작업을 처리한다.__       
      - Interactive 시스템은 사용자로부터 입력을 기다린다.     
        
   - __다수의 사용자들의 공유, 컴퓨터 자원의 사용을 최적화하기 위해서 시간 분할 시스템은 자원의 공유를 각 사용자에게 주면서 CPU를 통해 빠르게 프로세스를 순환시키기 위해 타이머와 스케줄링 알고리즘을 사용했다.__    
      - 전통적인 시간 분할 시스템은 흔하진 않지만 같은 스케줄링 기술은 데스크탑 컴퓨터, 랩탑, 서버, 모바일 컴퓨터에서 여전히 사용된다.   
      - 하지만 모든 프로세스는 같은 사용자에 의해서만 소유되어졌다.   
      - 사용자 프로세스와 시스템 프로세스는 컴퓨터 시간의 일부분을 자주 얻기 위해서 관리된다.    
      - 윈도우가 생성되어있을 경우 여러 작업을 동시에 수행하고 있을 수 있다.     
         - 심지어 웹 브라우저도 여러 프로세스로 구성될 수 있다.   
            - 시간 분할을 이용하여 현재 접속한 각 웹사이트에 대한 처리를 한다.   

#### 1.11.2 Mobile Computing(모바일 컴퓨팅)   

   - __온라인 서비스 접근 제공을 위해 모바일 장치는 보통 IEEE 표준 802.11 무선 또는 무선 데이터 네트워크 사용한다.__    
        
   - __PC에 비해 처리 속도와 메모리 수용량이 제한적이다.__   
      - 모바일 장치는 전력 소모를 고려해야하고 더 작고 느리고 더 적은 코어를 가진 프로세서를 사용한다.         

#### 1.11.3 Distributed Systems(분산 시스템)      

   - __시스템이 유지하고 있는 다양한 자원에 대한 접근을 사용자에게 제공하기 위해 네트워크로 연결된 다차원적이고 물리적으로 분리된 컴퓨터 시스템의 종합이다.__   
      - 공유 자원에 대한 접근은 계산 속도, 기능성, 데이터 이용가능성, 의존성을 증가시킨다.          
        
   - __일부 OS는 네트워크 인터페이스의 장치 드라이버에 들어있는 네트워크의 세부사항을 가지고 파일 접근의 형식으로 네트워크 접근을 일반화한다.__    
        
   - __다른 OS는 사용자가 네트워크 함수를 호출하게 한다.__   
      - FTP, NFS 두 모드가 있고 시스템의 유용성과 인기의 큰 영향을 줄 수 있다.      
      
   - __Network__   
      - 두 개 이상의 시스템 사이의 통신로이다.      
      - 분산 시스템의 기능성은 네트워크에 달려있다.   
      - 전송 매체, 노드 사이의 거리, 사용된 프로토콜에 의해 다양하다.   
        
   - __TCP/IP__    
      - 가장 흔한 네트워크 프로토콜      
      - 인터넷의 본질적인 구조를 제공한다.   
      - 대부분의 OS는 TCP/IP를 지원한다.   
      
   - __LAN(Local-Area Network)__   
      - 지역 네트워크로 캠퍼스, 건물, 방 내부의 컴퓨터 연결      
      
   - __WAN(Wide-Area Network)__   
      - 전역 네트워크로 나라, 도시, 건물을 연결     

   - __블루투스와 802.11 기계들은 일정거리 내에서 통신하기 위해 무선 기술 사용한다.__    
      - 휴대폰과 헤드셋 또는 스마트폰과 PC 사이에 PAN(Personal-Area Network)를 생성하면서 통신한다.      
    
   - __네트워크 전달을 위한 매체__   
      - 라디오, 마이크로웨이브 접시 안테나, 인공위성 사이에 무선 전송, 섬유가닥, 구리선을 포함한다.      
         
   - __컴퓨터 장치가 무선 휴대폰에 연결될 때, 네트워크를 만든다.__   
      - 단거리 적외선 통신도 네트워크에 사용될 수 있다.       
      - 가장 기초적인 단계에서 컴퓨터가 통신할 때마다 네트워크를 사용하거나 만든다.     
        
   - __Network Operating System__    
      - 메세지를 교환하기 위해 다른 컴퓨터들에서 다른 프로세스를 허용하게 하는 통신 구조를 가지고 네트워크를 통해 파일을 공유하게 하는 특성을 제공하는 OS       
      - 네트워크 OS를 실행시키는 컴퓨터는 네트워크를 인식하고 네트워크로 연결된 다른 컴퓨터와 통신할 수 있음에도 불구하고 네트워크에 있는 모든다른 컴퓨터들로부터 자율적으로 행동한다.      
      
   - __분산된 OS는 덜 자율적인 환경을 제공한다.__   
      - 다른 컴퓨터들이 오직 하나의 OS가 네트워크를 통제한다는 착각을 가지게 할 정도로 밀접하게 통신한다.      

#### 1.11.4 Client-Server Computing(클라이언트-서버 컴퓨팅)   

   - __오늘날의 많은 시스템은 Client 시스템에 의해 발생된 요청을 만족시키기 위한 Server 시스템처럼 동작한다.__     
        
   - __Compute-Server System__    
      - Client가 어떤 행동을 할 수 있게 요청을 보내는 인터페이스 제공한다.   
      - Server는 해동을 수행하고 결과를 Client에 보낸다.   
      
   - __File-Server System__   
      - Client가 파일을 CRUD 할 수 있는 파일 시스템 인터페이스 제공한다.   
      
   <p align = "center"><img src = "https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_18_ClientServer.jpg" title = 1_18_ClientServer.jpg alter = 1_18_ClientServer.jpg></img><br><strong>1.18 Client-Server 시스템의 일반적인 구조</strong></p>      
        
#### 1.11.5 Peer-to-Peer Computing(Peer-to-Peer 컴퓨팅)    

   - __시스템 내의 모든 노드가 Peer로 고려되고 각 Peer는 서비스를 요청하는지 또는 제공하는지에 따라 Client 또는 Server로 동작한다.__    
       
   - __오래된 Client-Server 시스템에 이점을 제공한다.__ :star:      
      - Client-Server 시스템에서 Server는 병목적이지만 Peer-to-Peer 시스템에서는 네트워크를 통해 분산된 여러 노드에 의해 서비스가 제공될 수 있다.      
       
   - __Peer-to-Peer 시스템에 참여하기 위해서는 노드가 먼저 네트워크에 연결해야 한다.__   
      - 노드가 네트워크에 연결되면, 네트워크에 다른 노드들로부터 서비스 제공과 요청을 시작할 수 있다.      
        
   - __어떤 Service가 이용가능한지 알아내는 2가지 방법__    
      - __첫 번째 방법__
         - 노드가 네트워크에 연결될 때, 노드는 네트워크에 있는 중앙 검색 서비스에 자신의 서비스를 등록한다.   
         - 특정 서비스를 원하는 노드는 먼저 어느 노드가 서비스를 제공하는지 알아내기 위해 중앙 검색 서비스에 연락한다.   
         - 통신의 나머지는 Client와 서비스 제공자 사이에서 발생한다.   
         - ex) Napster 시스템 for 파일 공유 서비스
         
      - __두 번째 방법__    
         - 중앙 검색 서비스를 사용하지 않는다.   
         - Client로 동작하는 Peer는 네트워크에 있는 다른 모든 노드에 원하는 서비스에 대한 요청을 broadcast 함으로써 어떤 노드가 원하는 서비스를 제공하는지 알아내야 한다.   
         - 해당 서비스를 제공하는 노드들은 요청을 한 Peer에 응답한다.   
         - 이러한 방식을 제공하기 위해서, peer가 네트워크에 있는 다른 peer에 의해 제공되는 서비스를 발견하게 할 수 있는 discovery protocol가 반드시 제공되야 한다.    
         - ex) Gnutella 시스템 for 파일 공유 서비스
         
   - __대표적인 Peer-to-Peer 컴퓨팅은 Skype다__    
      - Voice over IP(VoIP)를 사용하여 인터넷을 통해 통화, 메세지 가능하다.   
      - 중앙 집권화된 로그인 서버와 분권화된 peer를 포함하며 두 peer가 통신할 수 있게 하는 hybrid peer-to-peer 방식을 사용한다.    

#### 1.11.6 Virtualization(가상화)   

   - __Virtualization__    
      - OS를 다른 OS내에서 app처럼 실행할 수 있게 하는 기술   
      - emulation을 포함하는 소프트웨어 클래스의 하나의 일부이다.   
      
   - __Emulation__ :star:      
      - CPU 타입이 목표 CPU 타입과 다를 때 사용된다.       
      - ex) Apple이 데스크탑, 랩탑 컴퓨터를 IMB Power CPU에서 Intel x86 CPU로 바꿨을 때   
         - IBM CPU를 위해 컴파일된 app을 Intel CPU에서도 작동시키게 하는 "Rosetta" 라고 불리는 emulation facility가 Intel CPU에 포함되어 있다.   
        
   - __이러한 emulation 개념은 하나의 플랫폼을 위해 쓰여진 전체 OS를 다른 플랫폼에서 실행시키게 허용하는 것으로 확대될 수 있다.__    
      -     
      -   
   - ____   
      -   
      -   
   - ____   
      -   
      -   
        
###
   - ____    
      -   
      -   
   - ____   
      -   
      -   
   - ____   
      -   
      -   
        
   - ____    
      -   
      -   
   - ____   
      -   
      -   
   - ____   
      -   
      -   
        
   - ____    
      -   
      -   
   - ____   
      -   
      -   
   - ____   
      -   
      -   
        
