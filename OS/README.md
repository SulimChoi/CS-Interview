# :bookmark_tabs: Operating System Concepts 9th edition      

* [1.Introduction](#1-introduction)   
   - [1.1 What Operating Systems do](#11-what-operating-systems-doos가-하는-일)   
      - [1.1.1 User View(사용자 관점)](#111-user-view사용자-관점)   
      - [1.1.2 System View(시스템 관점)](#112-system-view시스템-관점)   
      - [1.1.3 Defining Operating Systems(OS 정의)](#113-defining-operating-systemsos-정의)   
   - [1.2 Computer-System Organization](#12-computer-system-organization컴퓨터-시스템-구성)   
      - [1.2.1 Computer-System Operation(컴퓨터 시스템 동작)](122-computer-system-operation컴퓨터-시스템-)   
      - [1.2.2 Storage Structure(저장 장치 구조)](#122-storage-structure저장-장치-구조)   
      - [1.2.3 I/O Structure(입출력 구조)](#123-io-structure입출력-구조)
* [2.](#2)   
   - [](#)   
   - [](#)   
   - [](#)   
   - [](#)   
   
   
## 1. Introduction   
   - __Operating System__   
      - 컴퓨터의 하드웨어를 관리하는 프로그램   
      - 컴퓨터 사용자와 하드웨어 사이의 중개자 역할을 하며 응용프로그램을 위한 기초를 제공   
      - OS mainframe은 주로 하드웨어의 이용률을 최대한으로 하기 위해 설계되었다.   
 
### 1.1 What Operating Systems do(OS가 하는 일)   
   - __컴퓨터 시스템을 대략 4가지 구성요소로 나눌 수 있다.__   
      - __Hardware__    
         - 시스템을 위한 기본적인 컴퓨터 자원들을 제공한다.    
         - CPU(Central Processing Unit), Memory, I/O devices   
      - __Application programs__   
         - 사용자의 컴퓨팅 문제를 해결하기 위해 자원들을 사용하는 방식을 정의한다.   
         - ex) Word processor, spreadsheets...   
      - __Operating system__   
         - 하드웨어를 통제하고 다양한 사용자들을 위한 다양한 app 사이에 하드웨어 사용을 조정한다.  
      - __Users__   
      
#### 1.1.1 User View(사용자 관점)   
   - __사용자를 위한 시스템은 보통 한 유저가 시스템 자원을 독점할 수 있게 설계되어진다.__   
      - __목표는 사용자가 실행하는 작업을 최대화하는 것이다.__   
      - __이 경우, OS는 자원의 이용보다 성능에 중점을 두면서 대부분 사용의 용의함을 위해 설계된다.__   
      - __다수 사용자의 요구 사항보다 한 사용자에 경험에 더 최적화 되어있다.__   
   
   - __사용자는 mainframe 또는 minicomputer에 연결된 터미널에 있을 수 있다.__   
      - __다른 사용자들은 다른 터미널을 통해 같은 컴퓨터에 접근한다.__    
         - __사용자들은 자원을 공유하고 정보를 교환할 수도 있다.__   
      - __이 경우, OS는 자원 활용을 극대화하기 위해 설계되어있다.__   
      
   - __사용자는 서버와 다른 워크스테이션의 네트워크에 연결된 워크스테이션에 있을 수 있다.__    
      - __사용자가 마음대로 사용할 수 있게 자원들을 할당한다.__   
      - __파일, 프린트 서버를 포함하는 서버와 네트워킹같은 자원을 공유한다.__   
    
#### 1.1.2 System View(시스템 관점)   
   - __OS는 하드웨어와 가장 밀접하게 연관된 프로그램이며 자원 관리자의 역할을 한다.__   
   - __OS는 다양한 사용자 프로그램과 I/O 장치를 통제하기 위한 Control Program이다.__   
   - __Control program__   
      - 컴퓨터의 부적절한 사용과 에러를 예방하기 위해 사용자 프로그램의 실행을 관리한다.   

#### 1.1.3 Defining Operating Systems(OS 정의)   
   - __일반적인 OS의 정의는 컴퓨터에서 항상 실행되는 하나의 프로그램이다. = Kernel   
   - __커널의 2가지 종류 프로그램__   
      - __System program__   
         - OS와 관련이 있지만 커널의 필수적인 부분은 아니다.   
      - __Application program__   
         - 시스템의 작동과 관련되지 않은 모든 프로그램    
   - __Mobile OS는 핵심 커널뿐만 아니라 middleware도 포함할때도 있다.__   
      - __Middleware__   
         - app 개발자에게 추가적인 서비스를 제공해주는 소프트웨어 프레임워크의 집합   
         - ex) IOS, Android   

### 1.2 Computer-System Organization(컴퓨터 시스템 구성)    
#### 1.2.1 Computer-System Operation(컴퓨터 시스템 동작)      
   - __일반 컴퓨터 시스템은 하나 이상의 CPU와 공유 메모리에 접근하는 것을 제공해야 하는 공통 버스와 연결된 다수의 장치관리자들로 구성된다.__   
   - __각 장치관리자는 특정 종류의 장치를 담당한다.__   
      - ex) 디스크 드라이브, 오디오 장치, 비디오 플레이어    
   - __CPU와 장치관리자들은 메모리 Cycle을 위해 경쟁하면서 동시에 실행할 수 있다.__    
   - __공유 메모리에 순차적으로 접근을 보장하기 위해서, 메모리 관리자는 메모리에 대한 접근을 동기화(Synchronize)한다.__   
   - __컴퓨터가 시작될 때 초기 프로그램 또는 bootstrap 프로그램이 실행되어야만 한다.__   
      - __이러한 초기 프로그램 또는 부트스트랩 프로그램은 ROM(Read-only-memory) 또는 EEPROM(Erasable programmable read-only memeory)에 있는 컴퓨터 하드웨어내에 저장되어 있으며 일반적인 용어로 Firmware라고 한다.__   
      - __CPU 레지스터부터 장치관리자까지 모든 시스템의 측면을 초기 설정한다.__   
      - __부트스트랩 프로그램은 반드시 OS를 불러오고 실행시키는 방법을 알고있어야만 한다.__   
      - __이러한 목표를 달성하기 위해서, 부트스트랩 프로그램은 반드시 OS 커널의 위치를 찾아내어 메모리에 적재되어야 한다.__   
   
   - __커널이 적재되고 실행되면, 시스템과 사용자에게 서비스 제공을 시작할 수 있다.__   
      - __일부 서비스는 커널이 실행되는 동안 내내 실행되는 시스템 프로세스 또는 시스템 데몬이 되기 위해서 부트 시간에 메모리로 적재되는 시스템 프로그램에 의해서 제공된다. 즉, 커널 외부에서 제공된다.__   
      - ex) UNIX에서 첫번째 시스템 프로세스는 "init"이며 init은 다른 데몬들을 실행시킨다. 이 단계가 완료되면, 시스템은 완벽하게 부트되었고 이벤트가 발생하기를 기다린다.      
      
   - __이벤트의 발생은 보통 소프트웨어 또는 하드웨어로부터의 인터럽트에 의한 신호를 받는다.__   
      - __하드웨어는 주로 시스템 버스를 거쳐 CPU로 신호를 보냄으로써 언제든지 인터럽트를 발생시킬 수 있다.__   
      - __소프트웨어는 System call(= Monitor call)을 호출하는 특별한 명령어를 실행시킴으로써 인터럽트를 발생시킬 수 있다.__   
   
   - __CPU가 인터럽트 될 경우__ :star:   
      1. 하던 일을 중단하고 즉시 특정 위치로 실행을 전달한다.   
         - 특정 위치는 보통 해당 인터럽트를 위한 서비스 루틴이 위치해있는 시작 주소를 가지고 있다.   
      2. 인터럽트 서비스루틴이 실행된다.   
      3. 인터럽트 서비스루틴이 완료될 시, CPU는 인터럽트에 의해 중단됐던 작업을 재개한다.   
      
   - __인터럽트__ :star:     
      - 각 컴퓨터 디자인은 자신만의 인터럽트 메카니즘을 가지고 있다.   
      - __인터럽트는 적합한 인터럽트 서비스 루틴에 통제권을 전달해야 한다.__   
         - 이러한 전달을 다루기 위한 쉬운 방법은 인터럽트 정보를 검사하기 위한 포괄적인 루틴을 호출하는 것이다.   
         - 해당 루틴은 결국, 특정 인터럽트 핸들러를 호출한다.   
      - __인터럽트는 반드시 빨리 처리되야 한다.__   
         - 미리 정의된 수만큼의 인터럽트만 처리 가능하기 때문에, 인터럽트 루틴을 위한 포인터 테이블은 필요한 스피드를 충족시키기 위해 사용될 수 있다.   
      - __인터럽트 루틴은 중간 루틴의 필요없이 포인터 테이블을 통해 간접적으로 호출된다.__    
      - __보통, 포인터 테이블은 low memory에 저장된다.(처음 백개 정도)__   
         - 이러한 위치에는 다양한 장치들을 위한 인터럽트 서비스 루틴의 주소들이 들어있다.   
         - 주소의 배열 또는 인터럽트 벡터는 장치 고유 번호에 의해 색인되며, 인터럽트를 일으킨 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해서 인터럽트 요청과 함께 장치 고유 번호가 주어진다.   
      - __인터럽트 구조는 반드시 인터럽트된 명령어의 주소를 저장해야한다.__   
         - 많은 오래된 설계에서는 고정된 위치나 장치 번호에 의해 색인된 위치에 인터럽트 주소를 저장했다.   
         - 최근 구조에서는 시스템 스택에서 반환 주소를 저장한다.   
            - ex) 만약 인터럽트 루틴이 프로세서 상태를 수정해야할 필요가 있을 경우   
               - 레지스터 값을 수정함으로써, 현재 상태를 저장하고 반환하기 전에 저장해놓은 상태를 복구해야만 한다.    
               - 인터럽트가 서비스 된 후, 저장된 반환 주소가 프로그램 카운터로 적재되고 인터럽트되었던 작업은 재개된다.   

#### 1.2.2 Storage Structure(저장 장치 구조)   
   - __CPU는 오직 메모리에서 명령을 불러올 수 있다.__   
      - 그래서 실행시킬 모든 프로그램은 메모리에 저장되어 있어야만 한다.   

   - __일반용 컴퓨터는 다시쓰기(rewritable)가 가능한 메모리라 불리는 Main memory (Random-Access Memory or RAM)로부터 대다수의 프로그램을 실행한다.__    
      - Main memory는 일반적으로 Dynamic Random-Access Memory (DRAM)으로 불리는 반도체 기술에서 구현된다.   
   
   - __ROM(Read-Only Memory)은 변경할수가 없다.__   
      - 그러므로 부트스트랩 프로그램과 같은 정적인 프로그램만 ROM에 저장된다.   
   
   - __EEPROM(Electrically Erasable Programmable Read-Only Memory)은 변경할 수 있지만, 빈번하게 변경할 수는 없다.__     
      - ROM과 마찬가지로 대부분 정적 프로그램을 포함한다.   
      - ex) 스마트폰은 출하 시 설치된 프로그램을 저장시키기 위해서 EEPROM을 사용한다.   
      
   - __모든 메모리의 유형은 byte로 구성된 배열을 제공한다.__    
      - 각 byte는 자신만의 주소를 가지고 있다.   
      - 상호작용은 특정 메모리 주소에 대한 load 또는 store의 연속을 통해 이루어진다.   
         - __load__   
            - 하나의 byte 또는 word를 메인 메모리로부터 CPU내의 내부 레지스터로 이동시킨다.   
         - __store__   
            - 레지스터의 내용을 메인 메모리로 이동시킨다.   
      - CPU는 실행을 위해 자동으로 메인 메모리로부터 명령어들을 load 한다.   
      
   - __von Neumann architecture 실행 cycle__ :star:   
      1. 메모리로부터 명령을 불러온다(Fetch).         
      2. 해당 명령을 명령 레지스터에 저장한다.    
      3. 해당 명령은 해독(Decode)되어지고, 피연산자가 메모리로부터 불러와(Fetch)질 수도 있다.    
      4. 일부 내부 레지스터에 해당 명령이 저장된다.   
      5. 피연산자를 가지고 해당 명령이 실행된 후, 결과는 메모리에 저장이 된다.   
      
      - 각 메모리 단위는 오직 하나의 일련의 메모리 주소만을 본다.   
      - 하나의 메모리 주소가 어떻게 생성되었고 무엇을 위한 것인지 알 수 없다.  
         - 즉, 우리는 메모리 주소가 프로그램에 의해 어떻게 생성되었는지 신경 쓸 필요가 없고 오직 실행되는 프로그램에 의해 생성된 일련의 메모리 주소에만 관심을 두면 된다.   
     
   - __보통 프로그램과 데이터를 메인 메모리에 영구적으로 보관하고 싶어하지만 불가능하다.__   
      - 이유 1. 메인 메모리가 모든 필요한 프로그램과 데이터를 영구적으로 저장하기에 너무 작다.   
      - 이유 2. 메인 메모리가 volatile(휘발성) 저장 장치이기 때문에 전원이 나가거나 꺼졌을 때 내용물을 잃게 된다.   
   
   - __대부분의 컴퓨터가 메인 메모리의 연장선으로서 Second storage를 제공한다.__   
      - 2차 저장 장치의 주요 요건은 많은 양의 데이터를 영구적으로 보관할 수 있어야 한다는 것이다.   
      - 가장 일반적인 2차 저장 장치는 프로그램과 데이터 둘다를 위해 저장공간을 제공하는 자기 디스크(magnetic disk)다.   
      - 대다수 프로그램(system and applications)은 메모리에 불러와지기 전까지 디스크에 저장되어 있다.   
         - 많은 프로그램이 자신의 처리 과정의 시작과 끝에 디스크를 사용한다.  
      - 적절한 디스크 용량 관리는 컴퓨터 시스템에서 중요한 부분이다.   
     
   - __메인 메모리, 자기 디스크, 캐시 메모리, 자기 테이프 등의 저장 구조는 많은 가능한 저장 시스템의 하나일 뿐이다.__   
      - 각 저장 시스템은 데이터(datum)를 저장하고, 차후에 검색되어질때까지 그 데이터를 유지하는 기본 기능을 제공한다.   
      - 다양한 저장 시스템 사이에 주요 차이점은 속소, 비용, 크기, 휘발성에 있다.   
      
   - __저장 장치 계층__   
   <img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/1_4_StorageDeviceHierarchy.jpg" width="450px" height="450px" title="1_4_StorageDeviceHierarchy" alt="1_4_StorageDeviceHierarchy"></img><br/>   
      - 상위 4개의 메모리는 반도체 메모리를 사용하여 제작된다.   
      - 비싼 배터리와 백업 시스템 생성기의 존재로, 데이터는 반드시 비휘발성 저장 장치에 기록되야만 한다.   
         - 비휘발성 저장 장치의 또 다른 유형은 NVRAM이다.   
            - 백업 전원 배터리를 가진 DRAM으로 배터리가 지속하는한 DRAM보다 빠르고 비휘발성이다.   
   
   - __solid-state disk는 보통 magnetic disk보다 빠르고 비휘발성이다.__ :star:   
      - 유형 1. 동작하는 동안 데이터를 큰 DRAM 배열에 저장한다.    
         - 백업 파워를 위해서 배터리와 숨겨진 자기 하드디스크를 가지고 있다.   
         - 외부 전원이 중단될 경우, SSD 컨트롤러가 데이터를 RAM에서 자기 디스크로 복사한다.   
         - 외부 전원이 복구될 경우, SSD 컨트롤러가 자기 디스크로부터 데이터를 다시 RAM으로 복사한다.   
      - 유형 2. Flash Memory   
         - 카메라와 Personal Digital Assistants(PDAs)에서 많이 사용된다.   
         - DRAM보다 느리지만 내용물을 유지하기 위해 전원이 필요없다.   

   - __완벽한 메모리 시스템의 설계는 모든 요소들이 균형을 이뤄야 한다.__   
      - 더 비싼 메모리를 사용해야하지만 가능한 덜 비싸고 비휘발성인 메모리   

   - __캐시는 비용과 비휘발성 두 요소 사이에 존재하는 전송률 또는 접근 시간에 큰 차이가 있는 성능을 향상시키기 위해 설치되어진다.__    
   
#### 1.2.3 I/O Structure(입출력 구조)    

   - __저장 장치는 컴퓨터내의 많은 입출력 장치 종류 중 하나일 뿐이다.__   
      - 일반용 컴퓨터 시스템은 CPU와 다수의 장치 관리자로 구성되어 있고 공동 버스로 연결되어 있다.   
      - 하나의 장치 관리자는 하나 이상의 장치가 연결되어질 수 있다.   
         - ex) 7개 이상의 장치가 SCSI(Small Computer-System Interface) 관리자에 연결될 수 있다.   
      - 장치 관리자는 지역 버퍼 저장 공간과 특수 목적용 레지스터 집합을 관리한다.   
      - 장치 관리자는 자신이 관리하는 주변 장치와 자신의 지역 버퍼 저장 공간 사이에 데이터를 이동시키는 것을 담당한다.   
      - 일반적으로 OS는 장치 관리자를 위한 장치 드라이버를 가지고 있다.   
         - 장치 드라이버는 장치 관리자를 이해하고 장치를 위한 동일한 인터페이스를 OS에 제공한다.   
      
   - __입출력 작업 실행 순서__ :starL      
      1. 장치 드라이버가 장치 관리자내에 있는 적합한 레지스터를 불러온다.   
      2. 장치 관리자는 어떤 동작을 수행할건지 확인하기 위해 레지스터의 내용을 검사한다.   
      3. 장치 관리자는 데이터를 장치로부터 자신의 지역 버퍼 공간으로 전송을 시작한다.   
      4. 데이터 전송이 끝나면, 장치 관리자는 장치 드라이버에게 인터럽트를 통해 해당 작업이 완료되었음을 알린다.   
      5. 장치 드라이버는 OS에 해당 장치에 대한 통제권을 반환한다.   
         - 작업이 읽기였다면 데이터를 가르키는 포인터나, 데이터를 반환하는 것도 가능하다.   
         - 다른 작업일경우, 장치 드라이버는 상태 정보를 반환한다.   
         
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   

####

   - ____   
   - ____  
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   - ____   
   

####
