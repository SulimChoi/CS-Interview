# :bookmark_tabs: Operating System Concepts 9th edition      
## 6장 Synchronization      
__중요하다고 생각되는 목차에는 :star: 표시해놓았습니다.__   
__:star:되어 있는 목차를 클릭하시면 클릭하신 목차의 내용이 있는 페이지로 넘어가며__   
__해당 페이지 내에 있는 중요 개념 옆에 :star: 표시해놓았습니다.__   

__혹시 잘못된 내용이 있거나 보완해야할 점이 있으면 `issue` 해주시거나 알려주시면 감사하겠습니다.:bow:__   

- [6. Synchronization](#6-synchronization)   
  - [6.1 Background](#61-background) :star:   
  - [6.2 The Critical-Section Problem](#62-the-critical-section-problem) :star:   
  - [6.3 Petersons's Solution]()   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  
## 6. Synchronization   

  - __Cooperating process__   
    - 하나의 프로세스가 다른 프로세스에 영향을 주거나 영향을 받을 수 있는 프로세스    
    - 논리적 주소 공간(code, data)을 직접적으로 공유하거나 메세지나 파일을 통해 data를 공유할 수 있다.   
    
### 6.1 Background   
  
  - __3.4.1장에서 생산자-소비자 문제에서 프로세스들이 메모리를 공유할 수 있게 하기 위해서 유한 버퍼가 사용되었고 이 유한 버퍼 사이즈-1 만큼의 아이템을 허용하도록 했다.__   
    - __유한 버퍼를 사용하는 결점을 해결하기 위해서 Counter를 사용하여 알고리즘을 수정할 수 있다.__   
      - Counter는 0으로 초기화되고 아이템이 추가될 때 증가하고, 제거될 때 감소한다.   
        - 하지만, 소비자의 count--, 생산자의 count++를 병행하게 수행시키게되면 올바른 값이 도출되지 않는다.   
          - ex) counter = 5이고 소비자 count--, 생산자 count++을 병행 수행하면 값은 4 또는 5 또는 6의 값이 나올것이며 올바른 값은 5다.   
        #### race condition
        - count++은 지역 CPU 레지스터 중 하나인 register1에 저장되고 register1 = count, register1 += 1을 한 뒤 counter = register1   
        - count--은 지역 CPU 레지스터 중 하나인 register2에 저장되고 register2 = count, register2 -= 1을 한 뒤 counter = register2   
        - register1, register2가 같은 물리적 레지스터(누산기)라고 하더라도 이러한 레지스터의 내용은 인터럽트 처리기에 의해 저장되고 회복된다.   
        - count++, count--를 병행 실행하면 위의 결과와 같이 생산자는 6, 소비자는 4라는 값을 얻게 된다.   
        
        - __이렇게 두 프로세스가 병행하게 counter 변수를 조작하게 했기 때문에 잘못된 값을 도출한다.__   
        
        - __경쟁 상태(Race condition)__ :star:   
          - 여러 프로세스가 동시에 같은 데이터를 조작하고 접근할 수 있고 접근이 발생하는 순서에 따라 실행의 결과가 달라질 수 있는 상황을 경쟁 상태라고 한다.   
          - 이러한 경쟁 상태를 방지하기 위해서 한 번에 하나의 프로세스만 Counter 변수를 조작하게 해야 한다.   
          - 이것을 보장하기 위해서 여러 방식에서 프로세스를 동기화해야 한다.   
          
#### 6.2 The Critical-Section Problem   

  - __임계 영역(Critical section)__ :star:   
    - n 개의 프로세스 {P0, P1, P2, … Pn}이 있는 시스템에서 각 프로세스는 임계 영역(critical section)이라고 부르는 코드 부분을 포함한다.   
      - 임계 영역안에서는 다른 프로세스와 공유하는 변수를 변경하거나 테이블을 갱신하거나 파일을 쓰거나 하는 등의 작업을 수행한다.   
    - __하나의 프로세스가 임계 영역에 실행중일 때, 다른 프로세스는 임계 영역에 들어갈 수 없다.__   
    
  - __임계 영역 문제(Critical-section problem)__ :star:   
  
    - __프로세스들이 협동하기 위해 사용할 수 있는 협약을 설계하는 것이다.__   
    
    - __각 프로세스는 반드시 임계 영역에 접근하기 위해서 진입 허가를 요청해야 한다.__
    
    - __진입 구역(Entry section)__   
      - 이러한 진입 요청을 구현하는 코드 부분   
      
    - __퇴출 구역(Exit section)__   
      - 임계 영역 뒤에 오는 코드 부분   
      
    - __나머지 구역(Reminder section)__   
      - 나머지 코드 부분   
      
    #### 6.1 프로세스 일반 구조   
    
  - __임계 영역 문제의 해결책이 만족시켜야하는 3가지 요소__ :star:   
    - __상호 배제(Mutual exclusion)__    
      - 하나의 프로세스가 임계 구역에서 실행된다면, 다른 프로세스들은 임계 구역에서 실행될 수 없다.   
    
    - __진행(Progress)__   
      - 임계 영역에서 실행되는 프로세스가 없고 다수의 프로세스가 임계 영역에 진입하기를 원한다면, 나머지 구역에서 실행되고 있지 않은 프로세스들만 어느 프로세스가 다음에 임계 영역으로 진입할 지 결정하는데 참여할 수 있으며 이러한 선택은 무기한적으로 연기될 수 없다.   
      
    - __한정된 대기(Bounded waiting)__   
      - 프로세스가 임계 영역에 진입 요청을 하고 그 요청이 승인되기 전까지 다른 프로세스들이 임계 영역에 진입하도록 허용되는 횟수에 제한이 있어야 한다.   
  
  - __한 순간에 많은 커널 모드 프로세스들이 OS 안에서 활성화 될 수 있다.__   
    - 그 결과, OS를 구현하는 코드(커널 코드)는 다수의 프로세스를 경쟁 상태로 만들 가능성이 있다.   
    
    - __OS에서 임계 영역을 다루기 위한 두 가지 방법__ :star:   
      - __1. 선점형 커널__   
        - 프로세스가 커널 모드에서 실행되는 동안 선점되는 것을 허용한다.   
        - 공유된 커널 자료구조가 경쟁 상태로부터 자유로워야 한다는 것을 보장할 수 있게 설계되어야 한다.   
          - 특히 SMP 구조를 위해 설계하는 것이 어렵다.   
      
      - __2. 비선점형 커널__   
        - 프로세스가 커널 모드에서 실행되는 동안 선점되는 것을 허용하지 않는다.   
          - 커널 모드 프로세스는 커널 모드를 빠져나가거나 block되거나 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 실행된다.   
        - 비선점형 커널은 한 순간에 커널 안에서 실행중인 프로세스는 하나밖에 없기 때문에 커널 자료구조에 대한 경쟁 상태로부터 자유롭다.   
        
      - __선점형 커널을 비선점형 커널보다 선호하는 이유__   
        - 선점형 커널은 응답이 더 빠를 수 있다.    
          - 커널 모드 프로세스가 대기중인 프로세스에게 프로세서를 양도하기 전에 오랫동안 실행할 위험이 적기 때문이다.   
            - 커널 모드 프로세스가 이런 식으로 행동하지 않도록 커널 코드를 설계하여 이러한 위험을 최소화 할 수 있다.   
        - 선점형 커널은 실시간 프로세스가 현재 커널에서 실행중인 프로세스를 선점할 수 있기 때문에 실시간 프로그래밍에 더 적당하다.   
        
### 6.3 Petersons's Solution   

  - ____   
    - 
    - 
      
