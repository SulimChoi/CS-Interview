# :bookmark_tabs: Operating System Concepts 9th edition      
## 6장 Synchronization      
__중요하다고 생각되는 목차에는 :star: 표시해놓았습니다.__   
__:star:되어 있는 목차를 클릭하시면 클릭하신 목차의 내용이 있는 페이지로 넘어가며__   
__해당 페이지 내에 있는 중요 개념 옆에 :star: 표시해놓았습니다.__   

__혹시 잘못된 내용이 있거나 보완해야할 점이 있으면 `issue` 해주시거나 알려주시면 감사하겠습니다.:bow:__   

- [6. Synchronization](#6-synchronization)   
  - [6.1 Background](#61-background) :star:   
  - [6.2 The Critical-Section Problem](#62-the-critical-section-problem) :star:   
  - [6.3 Petersons's Solution](#63-petersonss-solution)   
  - [6.4 Synchronization Hardware](#64-synchronization-hardware)   
  - [6.5 Mutex Locks](#65-mutex-locks) :star:    
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  - [](#)   
  
## 6. Synchronization   

  - __Cooperating process__   
    - 하나의 프로세스가 다른 프로세스에 영향을 주거나 영향을 받을 수 있는 프로세스    
    - 논리적 주소 공간(code, data)을 직접적으로 공유하거나 메세지나 파일을 통해 data를 공유할 수 있다.   
    
### 6.1 Background   
  
  - __3.4.1장에서 생산자-소비자 문제에서 프로세스들이 메모리를 공유할 수 있게 하기 위해서 유한 버퍼가 사용되었고 이 유한 버퍼 사이즈-1 만큼의 아이템을 허용하도록 했다.__   
    - __유한 버퍼를 사용하는 결점을 해결하기 위해서 Counter를 사용하여 알고리즘을 수정할 수 있다.__   
      - Counter는 0으로 초기화되고 아이템이 추가될 때 증가하고, 제거될 때 감소한다.   
        - 하지만, 소비자의 count--, 생산자의 count++를 병행하게 수행시키게되면 올바른 값이 도출되지 않는다.   
          - ex) counter = 5이고 소비자 count--, 생산자 count++을 병행 수행하면 값은 4 또는 5 또는 6의 값이 나올것이며 올바른 값은 5다.   
        #### race condition
        - count++은 지역 CPU 레지스터 중 하나인 register1에 저장되고 register1 = count, register1 += 1을 한 뒤 counter = register1   
        - count--은 지역 CPU 레지스터 중 하나인 register2에 저장되고 register2 = count, register2 -= 1을 한 뒤 counter = register2   
        - register1, register2가 같은 물리적 레지스터(누산기)라고 하더라도 이러한 레지스터의 내용은 인터럽트 처리기에 의해 저장되고 회복된다.   
        - count++, count--를 병행 실행하면 위의 결과와 같이 생산자는 6, 소비자는 4라는 값을 얻게 된다.   
        
        - __이렇게 두 프로세스가 병행하게 counter 변수를 조작하게 했기 때문에 잘못된 값을 도출한다.__   
        
        - __경쟁 상태(Race condition)__ :star:   
          - 여러 프로세스가 동시에 같은 데이터를 조작하고 접근할 수 있고 접근이 발생하는 순서에 따라 실행의 결과가 달라질 수 있는 상황을 경쟁 상태라고 한다.   
          - 이러한 경쟁 상태를 방지하기 위해서 한 번에 하나의 프로세스만 Counter 변수를 조작하게 해야 한다.   
          - 이것을 보장하기 위해서 여러 방식에서 프로세스를 동기화해야 한다.   
          
#### 6.2 The Critical-Section Problem   

  - __임계 영역(Critical section)__ :star:   
    - n 개의 프로세스 {P0, P1, P2, … Pn}이 있는 시스템에서 각 프로세스는 임계 영역(critical section)이라고 부르는 코드 부분을 포함한다.   
      - 임계 영역안에서는 다른 프로세스와 공유하는 변수를 변경하거나 테이블을 갱신하거나 파일을 쓰거나 하는 등의 작업을 수행한다.   
    - __하나의 프로세스가 임계 영역에 실행중일 때, 다른 프로세스는 임계 영역에 들어갈 수 없다.__   
    
  - __임계 영역 문제(Critical-section problem)__ :star:   
  
    - __프로세스들이 협동하기 위해 사용할 수 있는 협약을 설계하는 것이다.__   
    
    - __각 프로세스는 반드시 임계 영역에 접근하기 위해서 진입 허가를 요청해야 한다.__
    
    - __진입 영역(Entry section)__   
      - 이러한 진입 요청을 구현하는 코드 부분   
      
    - __퇴출 영역(Exit section)__   
      - 임계 영역 뒤에 오는 코드 부분   
      
    - __나머지 역(Reminder section)__   
      - 나머지 코드 부분   
      
    #### 6.1 프로세스 일반 구조   
    
  - __임계 영역 문제의 해결책이 만족시켜야하는 3가지 요소__ :star:   
    - __상호 배제(Mutual exclusion)__    
      - 하나의 프로세스가 임계 구역에서 실행된다면, 다른 프로세스들은 임계 구역에서 실행될 수 없다.   
    
    - __진행(Progress)__   
      - 임계 영역에서 실행되는 프로세스가 없고 다수의 프로세스가 임계 영역에 진입하기를 원한다면, 나머지 구역에서 실행되고 있지 않은 프로세스들만 어느 프로세스가 다음에 임계 영역으로 진입할 지 결정하는데 참여할 수 있으며 이러한 선택은 무기한적으로 연기될 수 없다.   
      
    - __한정된 대기(Bounded waiting)__   
      - 프로세스가 임계 영역에 진입 요청을 하고 그 요청이 승인되기 전까지 다른 프로세스들이 임계 영역에 진입하도록 허용되는 횟수에 제한이 있어야 한다.   
  
  - __한 순간에 많은 커널 모드 프로세스들이 OS 안에서 활성화 될 수 있다.__   
    - 그 결과, OS를 구현하는 코드(커널 코드)는 다수의 프로세스를 경쟁 상태로 만들 가능성이 있다.   
    
    - __OS에서 임계 영역을 다루기 위한 두 가지 방법__ :star:   
      - __1. 선점형 커널__   
        - 프로세스가 커널 모드에서 실행되는 동안 선점되는 것을 허용한다.   
        - 공유된 커널 자료구조가 경쟁 상태로부터 자유로워야 한다는 것을 보장할 수 있게 설계되어야 한다.   
          - 특히 SMP 구조를 위해 설계하는 것이 어렵다.   
      
      - __2. 비선점형 커널__   
        - 프로세스가 커널 모드에서 실행되는 동안 선점되는 것을 허용하지 않는다.   
          - 커널 모드 프로세스는 커널 모드를 빠져나가거나 block되거나 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 실행된다.   
        - 비선점형 커널은 한 순간에 커널 안에서 실행중인 프로세스는 하나밖에 없기 때문에 커널 자료구조에 대한 경쟁 상태로부터 자유롭다.   
        
      - __선점형 커널을 비선점형 커널보다 선호하는 이유__   
        - 선점형 커널은 응답이 더 빠를 수 있다.    
          - 커널 모드 프로세스가 대기중인 프로세스에게 프로세서를 양도하기 전에 오랫동안 실행할 위험이 적기 때문이다.   
            - 커널 모드 프로세스가 이런 식으로 행동하지 않도록 커널 코드를 설계하여 이러한 위험을 최소화 할 수 있다.   
        - 선점형 커널은 실시간 프로세스가 현재 커널에서 실행중인 프로세스를 선점할 수 있기 때문에 실시간 프로그래밍에 더 적당하다.   
        
### 6.3 Petersons's Solution   

  - __임계 영역 문제를 위한 소프트웨어 기반 해결책__   
    - 하지만, load, store 같은 기계언어 명령어를 수행하는 현대 컴퓨터 구조에서는 정확하게 동작한다는 보장이 없다.   
    
  - __임계 영역과 나머지 영역 사이에서 번갈아 실행되는 프로세스가 2개로 한정된다.__   
    - 두 프로세스는 두 데이터를 공유해야 한다.   
      - 두 프로세스는 Pi, Pj라고 표현하고 j = i - 1과 같다고 가정한다.   
      - turn   
        - 어느 프로세스가 임계 영역에 진입할 차례인지를 나타낸다.   
          - ex) if turn == i   
            - Pi가 임계 영역에서 실행되는 것이 허락된 것이다.      
      - boolean flag[2]   
        - 프로세스가 임계 영역에 진입할 준비가 되어있는지를 나타낸다.   
          - ex) if flag[i] == true   
            - Pi가 임계 영역에 진입할 준비가 되었다는 뜻이다.   
      
    #### 5.2 Pi 피터슨 솔루션 사진  
      - __Pi이 임계 영역에 진입하기 위해서는 먼저 flag[i] = true가 되야하고, turn = j로 설정해야 한다.__   
        - turn = j로 해주는 이유는 Pj가 임계 영역에 진입하기를 바랄 경우, 그렇게 할 수 있게 해주기 위해서이다.   
        - while문이 계속 실행될 경우, Pi는 Pj가 임계 영역에서 벗어날 때 까지 기다려야한다. = busy wating     
        - Pi가 임계 영역을 벗어난 후 flag[i] = false는 기다리고 있는 Pj가 임계 영역에 진입할 수 있게 한다.   
        
      - __두 프로세스가 동시에 접속하기를 시도할 경우__   
        - __turn은 거의 동시에 i, j로 설정된다.__   
          - __이러한 할당의 오직 하나만 지속된다.__   
            - __나머지 하나는 즉시 덮어씌어진다.__   
          - __turn의 최후의 값이 두 프로세스중 어느 프로세스가 임계 영역에 먼저 접근할지를 결정한다.__   
          
  - __피터슨 알고리즘이 정확하다고 증명하기 위해서 충족해야 할 3가지__   
    - __상호 배제가 보존되어야 한다.__   
      - Pi는 오직 flag[j] == false 이거나 turn == i일 경우에만, Pj는 flag[i] == false 이거나 turn == j일 경우에만 임계 영역에 접근이 가능하다.   
      - 두 프로세스가 동시에 임계 영역에서 실행되어질 수 있다면, flag[i] == true, flag[j] == true이다.   
      - 하지만 Pi, Pj에서 turn의 값이 i 또는 j로 통일되고 각자 다른 값을 가질 수 없기 때문에, 위의 두 의견은 Pi와 Pj는 동시에 자신의 while문을 벗어나지 못하게 된다는 것을 암시한다.   
      
      - __예를 들어 Pi,Pj가 동시에 실행되었는데 Pj가 while문을 벗어나서 임계 영역에 진입했다면, Pi는 flag[j] == true, turn == j 조건에서 계속 block된다.__      
      - __이 시점에서 Pi의 flag[j] == true, turn == j는 Pj가 임계 영역에 있는 동안 지속될 것이고 이로 인해 상호 배제는 보존된다.__      
      
    - __진행 요건이 만족되어야 한다.__   
      - __임계 영역에 어떤 프로세스의 접근도 없을 때 항상 접근이 가능해야 한다.__   
      - flag[j] == true, turn == j여야만 Pi가 임계 영역에 진입할 수 없다.   
      - Pj가 임계 영역에 진입할 준비가 되어있지 않다면 flag[j] == false이고 Pi는 임계 영역에 진입할 수 있다.   
      - Pj가 flag[j] = true로 설정하고 while문을 실행중이라면, turn == i 이거나 turn == j이다.   
        - turn == i일 경우 Pi는 임계 영역으로 진입한다.   
        - turn == j일 경우 Pj가 임계 영역으로 진입한다.   
          - 하지만, Pj가 임계 영역을 벗어나면 flag[j] = false가 되고 Pi가 임계 영역으로 진입할 수 있게 된다.   
          - Pj가 flag[j] = true로 바꾸면 turn = i로 바꿔야만 한다.   
          - Pi는 while문을 실행하는 동안 turn의 값을 변경하지 않기 때문에, Pi는 Pj에 의한 최대 한번의 과정 후에 임계 영역으로 진입할 수 있다. = 유한 대기  
    
    - __유한 대기 요건이 충족되어야 한다.__   
      - 무한 대기가 일어나지 않아야 한다.   
        - 일부의 프로세스만 계속 임계 영역에 진입할 경우, 그렇지 못한 프로세스가 생겨 고아 현상이 발생한다.   
    
    
### 6.4 Synchronization Hardware   

  - __Locking을 통해 임계 영역을 보호한다.__   
  
  - __싱글 프로세서에서는 공유되는 변수가 수정되는 동안 인터럽트 발생을 막음으로써 임계 영역을 보호할 수 있다.__   
    - 연속적인 명령어는 선점없이 순서대로 실행되어지기 때문에 예상치 못한 수정이 공유 변수에서 일어날 수 없다.   
    - 비선점 커널에서 종종 이러한 방법을 사용한다.   
    - 멀티 프로세서에서는 메세지가 모든 프로세서에 전달되기 때문에 인터럽트를 disable하는 것은 시간 소모가 커 이러한 방식을 사용하는 것이 거의 불가능하다.   
      - 메세지 전달은 각 임계 영역 진입을 지연시키고 시스템 효율성을 떨어뜨린다.   
      
  - __많은 현대 컴퓨터 시스템은 하나의 word의 내용을 수정하고 테스트하거나 두 개의 word의 내용을 atomically하게 교체하게 하는 특별한 하드웨어 명령어를 제공한다.__   
  
  #### test and set   
    - test_and_set() 명령어는 atomically하게 실행된다.   
    - 두 개의 test and set()이 다른 CPU에서 각각 동시에 실행되면, 무작위 순서로 연속하여 실행되어진다.   
    - lock 변수를 선언함으로써 상호 배제를 구현할 수도 있다.   
    
  #### compare and swap()   
    - test_and_set()과 달리 3개의 피연산로 작동한다.   
    - 항상 변수 value의 원래의 값만 반환한다.   
    - atomically하게 실행된다.   
    - 상호 배제는 전역 변수 lock을 선언하고 0으로 초기화 함으로써 제공될 수 있다.   
    - compare_and_swap()을 호출하는 첫 번째 프로세스는 lock의 원래 값이 예상된 0의 값과 같았기 때문에 lock을 1로 설정하고 임계 영역으로 진입한다.   
    - 이 후의 compare_and_swap() 호출은 lock이 0과 같지 않기 때문에 실행될 수 없다.   
    - 임계 영역에 진입한 프로세스가 임계 영역을 벗어날 때, lock을 0으로 설정하여 다른 프로세스가 임계 영역으로 진입할 수 있게 한다.   
    
  - __이러한 알고리즘이 상호 배제 요건을 충족하더라도, 유한 대기 요건을 만족시키지 못한다.__   
  
  #### bound-waiting mutual   
    - test_and_set()을 사용한 또 다른 알고리즘으로 모든 임계 영역 요건을 만족시킨다   
      #### wating[n], lock      
        - 이러한 공동 자료 구조는 false로 초기화된다.   
      - __상호 배제 요건이 충족되는 것을 증명하기 위해서, Pi는 waiting[i] == false 또는 key == false 일 경우에만 임계 영역에 진입할 수 있다고 알아두어야 한다.__   
        - key의 값은 test_and_set()이 실행될 경우에만 false로 변할 수 있다.   
      - test_and_set()을 실행할 첫 번째 프로세스는 key == false 인 것을 발견하고, 다른 프로세스는 모두 기다린다.   
      - waiting[i]는 다른 프로세스가 임계 영역을 벗어날 경우에만 false가 될 수 있다.   
        - 오직 하나의 waiting[i]만 false로 설정되어 있어 상호 배제 요건을 유지한다.   
      
      - __진행 요건이 충족되는 것을 증명하기 위해서, 임계 영역을 벗어나는 프로세스가 lock을 false로 또는 waiting[i]를 false로 설정하기 때문에 상호 배제를 위해서 표현된 주장들이 여기에서도 적용된다는 것을 알야야 한다.__   
        - lock과 waiting[i] 둘 다 임계 영역에 진입하기 위해 기다리고 있는 프로세스가 계속해서 진행될 수 있게 해준다.   
      - __유한 대기 요건이 충족되는 것을 증명하기 위해서, 프로세스가 임계 영역을 벗어날 때, 순환 순서(i+1, i+2, ..., n , 0, ..., i-1)로 waiting 배열을 스캔한다.__   
        - 이러한 순서에 있는 첫 번째 프로세스가 임계 영역에 진입하기 위한 다음 프로세스처럼 진입 영역에 있다는 것을 명시한다.   
          - 임계 영역에 진입하기 위해 기다리고 있는 모든 프로세스는 n - 1번 안에 진입할 수 있다.   
          
### 6.5 Mutex Locks   

  - ____    
    - 
    - 
