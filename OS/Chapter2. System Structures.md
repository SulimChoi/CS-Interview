# :bookmark_tabs: Operating System Concepts 9th edition      
## 2장 System Structures   
__중요하다고 생각되거나 알고 있으면 좋을 것 같다는 내용이 있던 챕터에는 :star: 표시를 해놓았고    
해당 챕터안에 중요 개념 옆에 :star: 표시 해놓습니다.   
혹시 잘못된 내용이 있거나 보완해야할 점이 있으면 `issue` 해주시거나 알려주시면 감사하겠습니다.:bow:__   

* [2.System Structures](#2system-structures)   
  - [2.1 Operating-System Services](#21-operating-system-services)   
  - [2.2 User and Operating-System Interface](#22-user-and-operating-system-interface)   
    - [2.2.1 Command Interpreters(명령어 해석기)](#221-command-interpreters명령어-해석기) :star:     
    - [2.2.2 Graphical User Interfaces(그래픽 사용자 인터페이스)](#222-graphical-user-interfaces그래픽-사용자-인터페이스)   
    - [2.2.3 Choice of Interface(인터페이스 선택)](#223-choice-of-interface인터페이스-선택)   
  - [2.3 System Call](#23-system-call)   
  - [2.4 Types of System Calls](#24-types-of-system-calls)   
    - [2.4.1 Process Control(프로세스 제어)](#241-process-control프로세스-제어)   
    - [2.4.2 File Management(파일 관리)](#242-file-management파일-관리)   
    - [2.4.3 Device Management(장치 관리)](#243-device-management장치-관리)   
    - [2.4.4 Information Maintenance(정보 유지)](#244-information-maintenance정보-유지)   
    - [2.4.5 Commuincation(통신)](#245-commuincation통신) :star:      
    - [2.4.6 Protection(보호)](#246-protection보호)   
  - [2.5 System Programs](#25-system-programs)   
  - [2.6 Operating-System Design and Implementation](#26-operating-system-design-and-implementation)   
    - [2.6.1 Design Goals(설계 목적)](#261-design-goals설계-목적)   
    - [2.6.2 Mechanisms and Policies(메카니즘과 정책)](#262-mechanisms-and-policies메카니즘과-정책)   
    - [2.6.3 Implementation(구현)](#263-implementation구현)   
  - [2.7 Operating-System Structure](#27-operating-system-structure)   
    - [2.7.1 Simple Structure(간단한 구조)](#271-simple-structure간단한-구조)   
    - [2.7.2 Layered Approach(계층적 접근)](#272-layered-approach계층적-접근)   
    - [2.7.3 Microkernels(마이크로커널)](#273-microkernels마이크로커널)   
    - [2.7.4 Modules(모듈)](#274-modules모듈)   
    - [2.7.5 Hybrid Systems(하이브리드 시스템)](#275-hybrid-systems하이브리드-시스템)   
  - [2.8 Operationg-System Debugging](#28-operationg-system-debugging)   
    - [2.8.1 Failure Analysis(실패 분석)](#281-failure-analysis실패-분석)   
    - [2.8.2 Peformance Tuning(성능 조정)](#282-peformance-tuning성능-조정)   
    - [2.8.3 DTrace](#283-dtrace)      
  - [2.9 Operating-System Generation](#29-operating-system-generation)    
  - [2.10 System Boot](#210-system-boot)    
    
## 2.System Structures   
### 2.1 Operating-System Services   

  - __User Interface(사용자 인터페이스)__   
    - 거의 모든 OS는 UI(User Interface)가 있다.   
    - UI 유형   
      - __1. Command-Line Interface(CLI)__   
        - 문자 명령을 사용한다.   
      - __2. Batch Interface(일괄 처리 인터페이스)__      
        - 명령과, 명령을 제어하는 지시들이 파일로 입력되며, 이러한 파일이 실행된다.   
      - __3. Graphical User Interface(GUI)__   
        - 입/출력을 가리키고 메뉴에서 고르거나 선택을 행하는 지시 장치를 가진 윈도우 시스템과 텍스트를 입력하는 키보드로 구성된다.   

  - __Program execution(프로그램 수행)__
    - 시스템은 반드시 프로그램을 메모리에 적재해 실행시킬 수 있어야 한다.   
    - 프로그램은 반드시 정상적으로 또는 비정상적으로(에러를 나타내면서) 자신의 실행을 종료시킬 수 있어야 한다.   

  - __I/O operations(입출력 연산)__   
    - 실행되고 있는 프로그램은 파일 또는 입출력 장치와 관련된 입출력을 요구할 수도 있다.   
    - 효율성과 보호를 위해 사용자들은 보통 입출력 장치를 직접 제어할 수 없다. 따라서 운영체제가 입출력 수행을 위한 수단을 제공해야 한다.   


  - __File-system manipulation(파일 시스템 조작)__   
    - 프로그램은 파일과 디렉토리를 읽고 쓸 뿐만 아니라 이름에 의한 생성, 삭제, 지정된 파일 검색, 파일 정보를 열거할 수 있어야 한다.   

  - __Communication(통신)__   
    - 프로세스간 정보를 교환해야할 상황이 있다.      
    - ex) 한 컴퓨터 내에 실행되는 프로세스들 또는 컴퓨터 네트워크로 연결된 다른 컴퓨터 시스템에서 실행되는 프로세스들   
    - __1. 공유 메모리 방법__   
      - 메모리의 공유된 영역에 두 개 이상의 프로세스가 읽고 쓸 수 있다.      
    - __2. 메세지 전달 방법__   
      - 미리 정의된 형식의 정보의 패킷이 OS에 의해 프로세스들 사이에 이동한다.   

  - __Error detection(오류 탐지)__   
    - OS는 항상 모든 가능한 오류를 감지하고 해결할 수 있어야 한다.      
    - __Error 종류__   
      - __CPU와 Memory hardware__   
        - 메모리 에러 또는 파워 문제  
      - __입출력 장치__   
        - 디스크 Parity 에러, 네트워크 연결 실패, 프린터 용지 부족 등   
      - __사용자 프로그램__   
        - 연산 오버플로우, 잘못된 메모리 위치 접근 시도, 너무 큰 CPU 사용 시간 등   
    - 오류에 대한 적절한 조취를 취해 정확하고 일관된 컴퓨터 사용을 보장해야 하지만, 시스템을 중단시켜야만 하는 경우도 있다.   
    - 오류를 야기하는 프로세스를 종료시키거나 프로세스가 오류를 감지하고 수정할 수 있게 프로세스에 에러 코드를 반환시킨다.   
    
  - __OS 효율성을 보장하는 기능__   
       
    - __Resource allocation(자원 할당)__   
      - 다수의 사용자나 다수의 작업이 동시에 실행 될 때 각각에 자원을 할당 해야 한다.   
      - CPU 사이클, 메인 메모리, 파일 저장 장치는 특병한 할당 코드를 가질 수도 있다.      
      - 입출력 장치는 더 일반적인 요청, 해제 코드를 가질 수 있다.   
      - CPU 사용을 가장 잘하는 방법을 결정하는데 있어서, OS는 CPU의 속도, 반드시 실행되어야하는 작업, 이용가능한 레지스터의 수 등을 고려하는 CPU 스케줄링 루틴을 가지고 있다.      

    - __Accounting(회계)__   
      - 어느 사용자가 얼마만큼 그리고 어떤 컴퓨터 자원을 사용하는지 알아야 한다.      
      - 이러한 사용 기록 저장은 회계나 사용량 통계를 축적하는데 사용된다.       
      - 사용량 통계는 컴퓨팅 서비스를 향상시키기 위해 시스템을 변경하기를 바라는 리서처들에게 좋은 수단이 될 수 있다.    
            
    - __Protection and security(보호와 보안)__   
      - 분리된 프로세스가 동시에 실행될 때, 하나의 프로세스가 다른 프로세스를 방해하거나 OS를 방해하지 않아야 한다.      
      - 보호는 시스템 자원에 모든 접근이 통제되도록 보장하는 것과 관련이 있다.    
      - 외부로부터 시스템 보안은 각 사용자가 시스템 자원 접근 권한을 얻기 위해 비밀번호와 같은 수단으로 자신을 시스템에 인증하는 것이다.       
      - 칩입을 감지하기 위해 모든 연결을 기록하고 부적절한 접근 시도로부터 네트워크 아답터를 포함한 외부 입출력 장치들을 보호하는 것까지 확대된다.      
      - 시스템이 안전하고 보호되려면, 예방조치가 시스템을 전체에 도입되어야 한다.       
      
    <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/2_1_OS_Services.jpg"  title="2_1_OS_Services" alt="2_1_OS_Services"></img><br><strong>2.1 OS 서비스 뷰</strong> 
      </p>   

### 2.2 User and Operating-System Interface   
#### 2.2.1 Command Interpreters(명령어 해석기)   

  - __일부 OS는 커널이 명령어 해석기를 포함한다.__   
  
  - __Window, UNIX와 같은 OS는 명령어 해석기를 사용자가 처음으로 로그인하거나 작업이 시작될 때 실행되는 특수한 프로그램으로 간주한다.__         
  - __Shell__ :star:   
    - __시스템에서 선택할 수 있는 여러 명령어 인터프리터를 말한다.__      
    - UNIX, Linux에서는 사용자가 Boorne shell, C shell, Bourne-Again shell, Korn shell 등을 포함하는 여러 shell 중 하나를 선택할 수 있다.   
    - __대부분 shell은 비슷한 기능들을 제공히고 어느 shell을 시용할지에 대한 사용자의 선택은 개인의 선호에 달려있다.__   
    - 명령어 해석기의 주요 기능은 명시된 다음 사용자 명령어을 얻고 실행하는 것이다.   
    - 이 단계에서 얻어진 대부분의 명령들은 파일을 조작한다.   
      - copy, delete, list, print, create, execute   
      
    - MS-DOS와 UNIX shell은 이러한 방식으로 동작하고 이러한 명령어들은 두 방법에 의해 수행될 수 있다.   
    
    - __1. 명령어 해석기 자체가 명령어를 실행하기 위한 코드를 가지고 있다.__   
      - 파일 삭제 명령어는 적절한 시스템 호출을 만들고 파라미터를 설정하는 코드의 영역으로 명령어 해석기가 이동하게 할 수 있다.   
      - 이러한 경우, 각 명령어가 자신만의 구현 코드를 필요로 하기 때문에 주어질 수 있는 명령어의 수가 명령어 해석기의 크기를 결정한다.   
      
    - __2. 시스템 프로그램을 통해 대부분의 명령어가 수행된다.__   
      - 명령어 해석기는 어떠한 방식에서든 명령어를 이해하지 못한다. 단지, 명령어를 메모리로 올리거나 실행될 파일을 확인하는데 사용한다.   
      - 파일 삭제를 위한 UNIX 명령어는 `rm`이라 불리는 파일을 검색하고 그 파일을 메모리로 적재하고 파라미터 `file.txt`를 가지고 실행한다.   
      - rm 명령어와 관련된 기능은 rm 파일에 있는 코드에 의해 완벽하게 정의되어 있다.   
      - 이러한 방식으로 프로그래머는 적절한 이름을 가진 새로운 파일들을 생성함으로써 시스템에 쉽게 새로운 명령어를 추가할 수 있다.   
      - 명령어 해석기 프로그램은 작을 수 잇지만, 추가되어진 새로운 명령어를 위해서 변화될 필요는 없다.   

#### 2.2.2 Graphical User Interfaces(그래픽 사용자 인터페이스)   

  - __사용자는 마우스 기반 데스크탑에 특성화된 윈도우 메뉴 시스템을 사용한다.__    
    - 프로그램, 파일, 폴더, 시스템 기능을 나타내는 아이콘이 있다.   
    - 1980년대 애플 맥킨토시 발매로 널리 퍼졌으며, 첫 GUI는 1973년 Xerox Alto 컴퓨터에 나왔다.   
    - 모바일 폰, 태블릿에서는 터치 스크린에서 gesture를 함으로써 동작한다.   
    
#### 2.2.3 Choice of Interface(인터페이스 선택)       

  - __개인 선호에 따라 선택된다.__      

  - __컴퓨터 관리하는 시스템 관리자, 시스템의 깊은 지식이 있는 Power 사용자는 CLI를 주로 사용한다.__    
    - CLI는 자신 고유의 프로그램 능력을 가지고 있기 때문에 반복적인 작업을 더 쉽게 만든다.    
    - 빈번한 작업은 명령어 라인의 집합을 필요로하고 이러한 집합은 파일에 기록될 수 있고, 이러한 파일은 프로그램처럼 실행될 수 있다.     
    - 이러한 프로그램은 실행가능한 코드로 컴파일된다기보다는 CLI에 의해 해석된다고 할 수 있다.   
    - 이러한 shell script는 Linux, UNIX 같은 CLI 지향적인 시스템에서 흔히 볼 수 있다.   
    
    
### 2.3 System Call   

  - __시스템 호출은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다.__   
    - 시스템 호출은 일반적으로 C, C++ 등과 같은 언어로 작성된 루틴 형태로 제공 된다.    
    - 하지만, 하드웨어에 직접 접근해야 하는 작업 등의 특정 ROW LEVEL 작업은 어셈블리 명령을 사용하여 작성되어야 한다.   
    
  - __시스템 호출이 사용되는 방식의 예__   
    - 한 파일로부터 데이터를 읽고 그것들을 다른 파일에 복사하는 프로그램 작성 시       
      - 프로그램이 필요할 첫 입력은 두 파일의 이름의 이름이다. 입력 파일, 출력 파일   
      - 이러한 이름들은 OS 설계에 따라 많은 방식에서 정해질 수 있다.   
      - 프로그램이 사용자에게 이름을 요청하는 방식   
        - 1. 인터렉티브 시스템에서 이러한 요청 방식은 연속적인 시스템 호출이 필요하다.   
          - 먼저 화면에 즉각적인 메세지를 작성하기위한 시스템 호출, 그 다음 두 파일을 정의하는 키보드 문자들로부터 읽어오기 위한 시스템 호출   
        - 2. 마우스 기반, 아이콭 기반 시스템에서는 파일 이름의 메뉴가 윈도우에 보인다.   
          - 사용자는 이름을 클릭하기 위해 마우스를 사용할 수 있고, 윈도우는 명시된 이름을 열 수 있다.   
          - 이러한 연속은 많은 입출력 시스템 호출이 필요하다.   
      - 두 파일의 이름을 얻게되면, 프로그램은 반드시 입력 파일을 열고 출력 파일을 생성해야 한다.   
      - 이러한 각 동작은 또다른 시스템 호출이 필요하다.   
      - 각 동작 동안 발생가능한 오류 조건은 추가적인 시스템 호출이 필요하다.   
        - 프로그램이 입력 파일을 열려고 할 때, 해당 이름의 파일이 없거나 접근이 불가할 수 있다.   
          - 콘솔(시스템 호출)에 메세지를 출력하고 비정상적인 종료(시스템 호출)을 한다.   
        - 출력 파일을 생성할 때, 같은 이름을 가진 출력 파일이 있을 수 있다.   
          - 프로그램을 중단(시스템 호출)시키거나 존재하는 파일을 삭제(시스템 호출)하고 새로운 파일 생성(시스템 호출)해야한다.   
          - 인터렉티브 시스템에서는 사용자에게 프로그램을 중단시킬건지 존재하는 파일을 교체할 것인지 물어보는 방법도 있다.   
      - 두 파일이 모두 준비되면, 입력 파일로부터 읽고(시스템 호출) 출력 파일에 쓰는(시스템 콜) 작업을 한다.   
      - 각 읽기와 쓰기는 반드시 발생가능한 에러 조건 관련한 상태 정보를 반환해야 한다.   
      - 입력에서는 파일의 끝에 도달했거나 읽기에서 하드웨어 실패(parity 에러)같은 것을 발견할 수 있고, 출력에서는 출력 장치에 따른 다양한 에러(디스크 공간 부족 등)를 마주할 수 있다.   
      - 모든 파일이 복사된 후, 프로그램은 두 파일을 종료(시스템 호출)하고 윈도우나 콘솔에 메세지를 작성(시스템 호출)하고 마지막으로 정상적으로 종료(시스템 호출)시킨다.   
      
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/2_6_Open%20system%20call.jpg" width = 800px height = 300px title="2_6_Open() system call" alt="2_6_Open() system call"></img><br><strong>2.6 사용자 프로그램의 open() 시스템 호출 처리 과정</strong></p>   
    
  - __간단한 프로그램이 OS를 많이 사용하게 만들수도 있다.__   
    - 시스템은 초당 수천 개의 시스템 호출을 실행한다.      
    - 대다수 프로그래머는 이러한 세부 사항을 보지 못한다.
    - 대부분의 응용 개발자들은 응용 프로그래밍 인터페이스(Application Programming Interface, API)에 따라 프로그램을 설계한다.   
    - API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다.    
    - __응용 프로그래머가 이용하는 가장 일반적인 API 3가지__   
      - Window 시스템을 위한 Window API    
      - POSIX 기반 시스템(Linux, Mac OS X, UNIX)을 위한 POSIX API   
      - Java 가상 머신에서 실행되는 프로그램을 위한 Java API   
    - Linux, UNIX에서 C언어로 쓰여진 프로그램을 위한 라이브러리는 `libc`다.   
    - 각 OS는 각 시스템 콜을 위한 자신 고유의 이름을 가진다.   
    
  - __응용 프로그래머가 시스템 호출을 사용하는 것보다 API에 따라 프로그래밍하는 것을 선호하는 이유__   
    - __프로그램 호환성__  
      - API에 따라 프로그램을 설계하는 응용 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서나 컴파일되고 실행되기 때문이다.   
      
  - __대부분 프로그래밍 언어에서 run-time 지원 시스템은 OS에 의해 이용가능하게 만들어진 시스템 호출에 연결을 하는 시스템 호출 인터페이스를 제공한다.__   
    - API에서 함수 호출을 막고, OS내에 있는 필요한 시스템 호출을 일으킨다.       
    - 각 시스템 호출과 연관된 숫자가 있고, 시스템 호출 인터페이스는 이러한 숫자들에 따른 색인 테이블을 가지고 있다.   
    - 시스템 호출 인터페이스는 OS커널에서 예정된 시스템 호출을 일으키고 시스템 호출의 상태와 반환 값을 반환한다.   
    - 호출자는 어떻게 시스템 호출이 구현되거나 동작하는 동안 무엇을 하는지 알 필요가 없으며, 오직 API를 따르고 OS가 시스템 호출의 결과로 무엇을 할 지를 이해하기만 하면 된다.   
    - OS 인터페이스의 세부 사항의 대부분은 API에 의해 프로그래머에게 비밀이고, run-time 지원 라이브러리에 의해 관리된다.    
        
  - __OS에 매개변수를 전달하는 3가지 방식__        
    __1. 레지스터에 매개변수를 전달__   
    __2. 레지스터보다 더 많은 매개변수가 있을 경우, 매개변수가 메모리 안 블록 또는 테이블에 저장되고, 블록의 주소를 레지스터의 매개변수로 전달__   
    __3. 스택__   
      - 매개변수는 프로그램에 의해 스택에 push되고 OS에 의해 pop된다.   
      - 일부 OS에서는 전달되는 매개변수의 수나 길이의 제한이 없는 블록 또는 스택 방법을 선호한다.   
      
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/2_7_PassingParameters.jpg"  title="2_7_PassingParameters" alt="2_7_PassingParameters"></img><br><strong>2.7 파라미터 전달</strong> 
      </p>   
    
### 2.4 Types of System Calls   

  - __시스템 호출을 대략 6가지 주요 범주로 그룹될 수 있다.__   
    __1. Process Control(프로세스 제어)__   
    __2. File Manipulation(파일 조작)__   
    __3. Device Management(장치 관리)__   
    __4. Information Maintenance(정보 유지)__   
    __5. Commuication(통신)__   
    __6. Protection(보호)__   

#### 2.4.1 Process Control(프로세스 제어)   

  - __실행 중인 프로그램은 수행을 정상(end()) 또는 비정상(abort())으로 끝낼 수 있어야 한다.__   
    - 현재 실행되는 프로그램을 비정상적으로 종료시키기위한 시스템 호출이 만들어 지거나, 프로그램에 문제가 발생해 오류 트랩(trap)을 유발할 경우 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다.   
    - 덤프는 디스크에 기록되고 문제의 원인을 밝혀내기 위해 디버거(Bebugger)에 의해 검사될 수 있다.   
    - 이러한 비정상적 또는 정상적 상황에서, OS는 반드시 명령어 해석기로 제어를 전달해야 한다. 명령어 해석기는 이어 다음 명령을 읽는다.   
    - 인터렉티브 시스템에서 명령어 해석기는 쉽게 다음 명령어를 계속한다.   
      - 시용자가 모든 에러에 반응하기 위해 적절한 명령을 발행할 수 있는 것을 가정한다.   
    - GUI 시스템에서 팝업 윈도우는 사용자에게 에러를 알려주고 지시를 요청한다.   
    - Batch 시스템에서 명령어 해석기는 모든 작업을 종료하고 다음 명령을 계속한다.   
    
  - __일부 시스템은 에러 발생 상황에 특별한 복구 동작을 할 수 있다.__   
    - 프로그램이 입력에서 에러를 발견하고 비정상적으로 종료시키기를 원할 경우, 에러 수준을 정의하기를 원할수도 있다.     
    - 높은 수준의 에러 매개변수로 많은 심각한 에러를 나타낼 수 있다.   
    - 명령어 해석기 또는 프로그램은 자동적으로 다음 행동을 결정하기 위해 이러한 에러 수준을 사용할 수 있다.   
    
  - __프로세스나 하나의 프로그램을 실행시키는 작업은 다른 프로그램을 load()하고 execute()하기를 원할 수 있다.__   
    - 이러한 특징은 명령어 해석기가 직접적인 사용자 명령에 의한 프로그램을 실행시킬 수 있게 한다.   
      - ex) 마우스 클릭, batch 명령 등   
    - __적재된 프로그램이 종료될 때 제어가 어디로 가는지 중요하다.__     
      __1. 새로운 프로그램이 종료될 때, 기존에 사용되는 프로그램으로 제어가 넘어갈 때__   
        - 기존에 사용되는 프로그램의 메모리 이미지를 저장해야만 한다.   
        - 하나의 프로그램이 다른 프로그램을 호출하기 위한 메카니즘이 생성되어 있는 것이다.   
      __2. 두 프로그램이 병행으로 실행될 경우__   
        - 새로운 작업 또는 프로세스가 멀티프로그램되게 생성되었다.   
      __3. 새로운 프로세스나 작업을 생성하거나, 프로세스나 작업의 집합을 생성할 경우__   
        - 작업의 우선순위, 최대 허용 실행 시간 등 작업 또는 프로세스의 특성을 재설정하고 알아내는 능력이 필요하다.   
      __4. 프로세스나 작업이 부정확하거나 더 이상 필요없을 경우__   
        - 해당 프로세스 또는 작업 종료   
      __5. 작업이나 프로세스가 실행 종료되기를 기다릴 경우__    
        - 특정 시간만큼 기다리기를 원할수도 있다.   
        - 일반적으로, 특정 이벤트를 기다릴 것이다.   
        - 이벤트가 발생시 신호를 보내야 한다.   
        
  - __흔히, 두 개 이상의 프로세스가 데이터를 공유할 수 있다.__   
    - 공유된 데이터의 무결성을 보장하기 위해 OS는 프로세스가 공유하는 데이터를 lock하는 시스템 호출을 제공한다.   
      - ex) acquire_lock(), release_lock()   
    - 다른 프로세스는 lock이 해제될 때까지 해당 데이터에 접근이 불가하다.   
    
  - __Single-tasking 시스템__   
    - MS-DOS OS가 대표적인 예      
    - 컴퓨터가 시작될 때, 발동되는 명령어 해석기가 있다.   
    - 단일 작업이기 때문에 프로그램을 실행하고, 새로운 프로세스를 생성하지 않는 간단한 방법 사용한다.   
    - __과정__   
      __1. 가능한한 최대의 메모리를 프로그램에 주기 위해 메모리 대부분을 쓰면서 프로그램을 메모리 적재한다.__   
      __2. 명령어 포인터를 프로그램의 첫 번째 명령어로 설정한다.__   
      __3. 프로그램이 실행되면 에러가 발생하거나, 프로그램은 종료시키기 위한 시스템 호출을 실행한다.__   
        - 에러 코드는 나중에 사용하기 위해 시스템 메모리에 저장된다.   
        - 위의 행동을 따르면서, overwrite되지 않은 명령어 해석기의 작은 부분은 실행을 재개한다.  
        - 첫 작업은 디스크로부터 명령어 해석기의 나머지 부분을 재적재하는 것이다.   
        - 명령어 해석기는 다음 프로그램이나 사용자가 이전 에러코드를 사용가능하게 해준다.   
        
        <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/2_9_DOS_Execution.jpg"  title="2_9_MS-DOS_Execution" alt="2_9_MS-DOS_Execution"></img><br><strong>2.9 MS-DOS 실행</strong><br>(a) 시스템 시작 시 (b) 프로그램 실행 시 
      </p>   
  
  - __Multi-tasking 시스템__   
    - FreeBSD(Berkeley UNIX에서 파생)가 대표적인 예     
    - 사용자가 시스템에 로그인 할 때, 사용자가 선택한 shell이 실행된다.   
    - 사용자가 요청한 프로그램을 실행하고 명령을 허용하는데 있어 MS-DOS shell과 비슷하다.   
    - 멀티태스킹 시스템이기 때문에, 명령어 해석기는 다른 프로그램이 실행되는 동안 계속 실행된다.   
    - 새로운 프로세스를 시작하기 위해서, shell은 fork() 시스템 호출을 실행한다.   
    - 선택된 프로그램은 exec() 시스템 호출을 통해 메모리로 적재되고 프로그램이 실행된다.   
    - 명령어가 발행되는 방식에 따라, shell은 프로세스가 끝나길 기다리거나 백그라운드에서 프로세스를 실행시킨다.   
      - 백그라운드에서 프로세스를 실행시킬 경우   
        - shell은 즉시 다른 명령어를 요청한다.   
        - 프로세스가 백그라운드에서 실행되고 있을 때, shell이 자원을 사용하고 있으므로, 키보드로부터 직접적인 입력을 받을 수 있다.   
        - 입출력은 GUI 인터페이스를 통하거나, 파일을 통해 행해진다.   
        - 사용자는 shell에게 다른 프로그램을 실행시키는 것, 실행되는 프로세스의 진행상태를 지켜보는 것, 프로그램의 우선순위를 변경하는 것 등을 자유롭게 물어볼 수 있다.   
        - 프로세스가 완료되면, 0이 아닌 에러 코드나 0의 프로세스 상태 코드를 반환하면서, 종료를 하기 위해 exit() 시스템 호출을 실행한다.   
        - 이러한 상태나 에러 코드는 shell이나 다른 프로그램에서 이용가능하다.   
        <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/2_10_FreeBSD_Memory.jpg"  title="2_10_FreeBSD_Memory" alt="2_10_FreeBSD_Memory"></img><br><strong>2.10 여러 프로그램을 실행하는 FreeBSD</strong>
      </p>
        
#### 2.4.2 File Management(파일 관리)   

  - __craete(), delete()을 통해 파일 생성, 삭제할 수 있어야 한다.__   
    - 파일 이름이나, 파일 속성의 일부를 요구한다.   
    - 파일이 생성되면, open()을 사용하여 파일을 열고, read(), write(), reposition()을 통해 읽기, 쓰기, 위치 변경을 할 수 있다.   
    - 파일을 더 이상 사용하지 않을 경우, close()를 사용하여 파일을 닫는다.   
  
  - __파일 시스템이 파일을 조직하기 위해 디렉토리 구조를 가진다면 우리는 디렉토리에 대해서도 파일과 같은 연산 집합이 필요 하다.__   
    - 추가로 파일이나 디렉토리에 대해 여러 속성의 값을 결정할 수 있어야 하고 필요에 따라 재설정 할 수 있어야 한다.  
      - get_file_attribute(), set_file_attribute()   
    - 파일 속성은 파일 이름, 파일 유형, 보호코드 등 정보를 포함한다.   
    - 일부 OS는 move(), copy() 등 더 많은 시스템 호출을 제공하기도 한다.   

#### 2.4.3 Device Management(장치 관리)   

  - __OS에 의해 통제되는 다양한 자원(메모리, 디스크 장치, 파일 접근 등)은 장치로 간주될 수 있다.__   
    - 일부는 물리적 장치(디스크 드라이브), 일부는 가상적 또는 추상적 장치(파일)      
    - 다수의 사용자가 있는 시스템인 경우, 독점적인 장치 사용을 보장받기 위해 우선 그 장치를 요청(request()) 해야 한다.
    - 장치의 사용 후, release()해줘야 한다.   
      - 파일의 open(), close()와 비슷한 개념이다.   
    - 일부 OS는 장치에 관리되지 않는 접근을 허용한다.   
      - 이러한 경우 deadlock과 장치 경합에 대한 위험성이 존재할 수 있다.   
    - 장치가 요청되고 할당되었으면, read(), write(), reposition() 할 수 있다.   
    - 입출력 장치와 파일 사이의 유사성이 너무 커서, UNIX를 포함한 많은 OS는 두 개를 파일-장치 구조로 합친다.   
      - 이 경우, 시스템 호출의 집합이 파일과 장치 둘 다에서 사용된다.   
      - 입출력 장치는 특정한 파일 이름, 디렉토리 위치, 또는 파일 특성에 의해 식별된다.   
    - 사용자 인터페이스는 근본적인 시스템 호출이 다름에도 불구하고 장치와 파일들을 비슷하게 보이게 만들 수 있다.    
    
#### 2.4.4 Information Maintenance(정보 유지)   

  - __많은 시스템 호출은 OS와 사용자 프로그래밍 사이에서 정보를 전달하는 목적을 위해 존재한다.__      
    - 대부분의 시스템은 현재 time()과 date()를 반환하는 시스템 호출을 가지고 있다.   
      - 다른 시스템 호출은 OS 버전, 디스크 또는 메모리 빈 공간 크기, 현재 사용자의 수 등 시스템에 관한 정보를 반환한다.      

  - __시스템 호출의 집합은 프로그램 디버깅하는데 도움이 된다.__   
    - 많은 시스템은 메모리를 dump() 하기 위한 시스템 호출을 가진다.   
    - 프로그램은 실행되는 각각의 시스템 호출 목록을 추적한다.   
    - microprocessor는 매 명령어 실행 후, CPU에 의해 실행되는 trap인 'single step'으로 알려진 CPU 모드를 지원한다.  
      - 이러한 trap은 디버거에 의해 발견된다.   
    - 많은 OS는 프로그램이 특정 위치나 위치들의 집합에서 실행하는 시간의 양을 나타내기 위해서 프로그램의 time profile을 제공한다.   
      - time profile은 추적 기능 또는 규칙적인 타이머 인터럽트가 필요하다.   
      - 타이머 인터럽트가 발생할 때마다, Program counter 값이 기록된다.   
      - 충분히 잦은 타이머 인터럽트로, 프로그램의 다양한 부분에서 소비된 시간의 통계적인 그림을 얻을 수 있다.   
      - OS는 모든 프로세스에 대한 정보를 유지하고, 시스템 호출을 정보에 접근하기 위해 사용된다.   
      - 일반적으로 프로세스 정보를 재설정을 위해 시스템 호출 get_process_attributes() + set_process_attributes()을 사용한다.   

#### 2.4.5 Commuincation(통신)   

  - __프로세스간 통신 모델 2가지__ :star:    
    __1. Message-passing model(메세지 전달 방식)__   
      - __정보를 전달하기 위해 프로세스간 메세지를 교환한다.__   
      - __메세지는 공동 메일 박스를 통해 간접적 또는 직접적으로 프로세스 사이에 교환된다.__   
      - 통신하기전에 반드시 연결이 열려있어야 한다.   
      - 다른 통신자의 이름을 반드시 알고 있어야 한다.   
        - __통신 네트워크에 의해 연결된 다른 컴퓨터의 프로세스 또는 같은 시스템에서의 다른 프로세스__   
      - 네트워크에서 각 컴퓨터는 'host name'을 가진다.   
        - host는 IP 주소와 같은 네트워크 식별자를 가지고 있다.   
        - process는 'process name'을 가지고 있고 이러한 name은 OS가 해당 프로세스를 참조할 수 있게 식별자로 번역된다.   
          - get_hostid(), get_processid()는 이러한 번역을 한다.   
        - 식별자는 통신 모델에 따라 open_connection()과 close_connection() 시스템 호출 또는 파일 시스템에 의해 제공된 open(), close() 시스템 호출에 전달된다.   
        - 수신 프로세스는 accept_connection() 호출을 통해 통신에 대한 허락을 해야만한다.   
        - 연결을 받아들이는 대부분 프로세스는 특정한 목적을 위해 제공된 시스템 프로그램인 daemon이다.   
          - daemon은 wait_for_connection()을 실행시키고 연결이 생성되었을 시 깨어난다.   
        - Client로 알려진 통신의 기원과 Server인 daemon은 read_message(), write_message() 시스템 호출을 사용하여 메세지를 교환한다.   
        - Close_connection()은 통신을 종료한다.   
        
    __2. Shared-memory model(공유 메모리 방식)__    
    
      - __프로세스는 다른 프로세스의 소유된 메모리 부분에 접근 권한을 위해 shared_memory_attach(), shared_memory_create()을 사용한다.__      
        - __보통 OS는 하나의 프로세스가 다른 프로세스의 메모리 접근을 막으려고 한다.__     
        - __공유 메모리는 이러한 제한을 제거히기 위해, 두 개 이상의 프로세스 동의를 요구한다.__     
        - __공유 영역에서 데이터를 쓰고 읽음으로써 정보를 교환할 수 있다.__   
        - 데이터 형식은 프로세스에 의해 결정되고 OS 통제 아래 있지 않다.   
        - __프로세스가 동시에 같은 위치에 쓰기 작업을 하지 않아야 하는 것을 보장해야 한다.__   
        
    - __대부분 OS는 두 가지 모델을 모두 구현한다.__   
      - 메세지 전달 방식은 충돌을 방지할 필요가 없기 때문에 소량의 데이터를 교환하는데 유용하다.      
      - 공유 메모리는 하나의 컴퓨터 내에서 발생하여 메모리 전송 속도로 수행되기 때문에, 통신이 편리하고, 최대 속도를 가능하게 하게 하지만 메모리를 공유하는 프로세스 사이에서 동기화와 보호 영역에 대한 문제점을 가지고 있다.   
      

#### 2.4.6 Protection(보호)   

  - __보호는 컴퓨터에 의해 제공된 자원에 대한 접근을 통제하기 위한 메카니즘을 제공한다.__   
    - 보호는 다수의 사용자를 가진 멀티 프로그램 컴퓨터 시스템과만 관련이 있었지만, 인터넷과 네트워크의 도입으로 서버부터 모바일 기기까지의 모든 컴퓨터 시스템은 반드시 보호를 고려하게 됐다.      
    - 보호를 제공하는 시스템 호출은 파일과 디스크 같은 자원의 설정 허가를 변경하는 get_permission(), set_permission()을 포함한다.    
    - allow_user()와 deny_user()는 특정 사용자가 특정 자원에 대한 접근을 허가 또는 거절한다.   

### 2.5 System Programs      

  - __시스템 유틸리티로 알려진 시스템 프로그램은 프로그램 실행과 개발을 위한 편리한 환경을 제공한다.__   
  
  - __시스템 프로그램 카테고리__   
    - __File management(파일 관리)__   
      - 시스템 프로그램은 일반적으로 파일, 폴더를 조작한다.      
      - create, delete, copy, rename, print, dump, list       

    - __Status information(상태 정보)__   
      - 일부 프로그램은 사용자의 수, 디스크 또는 메모리 사용가능 공간, 시간, 날짜 등 상태 정보를 시스템에 물어본다.     
      - 다른 일부 프로그램은 더 복잡한 디버깅, 로깅, 수행 디테일 정보를 물어본다.   
      - 전형적으로 터미널, 다른 출력 장치, 파일에 결과를 출력하거나 윈도우 GUI에 보여준다.   
      - 일부 시스템은 환경설정 정보를 저장하고 복구하는데 사용되는 registry를 지원한다.   

    - __File modification(파일 수정)__   
      - 다수의 텍스트 편집기는 디스크나 다른 저장 장치에 저장된 파일 내용 수정 또는 생성을 할 수 있다.      
      - 텍스트의 변경을 수행하거나 파일의 내용을 검색하는 특수한 명령어도 있다.      

    - __Programming-language support(프로그래밍 언어 지원)__   
      - 컴파일러, 어셈블러, 디버거, 인터프리터는 OS내에 제공되거나 개별 다운로드하여 사용가능하다.     

    - __Program loading and execution(프로그램 적재와 실행)__   
      - 프로그램이 어셈블되거나 컴파일되면, 실행되기 위해 반드시 메모리로 적재되야 한다.     
      - 시스템은 absolute loader, relocation loader, linkage editor, overlay loader를 제공한다.   
      - 고수준 언어 또는 기계언어를 위한 디버깅 시스템도 필요하다.   

    - __Communications(통신)__   
      - 프로세스, 사용자, 컴퓨터 시스템 사이에 가상 연결을 위한 메카니즘도 제공한다.      
      - 사용자가 다른 사용자의 화면에 메세지를 보내기, 웹 페이지 탐색, 이메일 전송, 원격 접속, 파일 전송 등을 가능하게 한다.      

    - __Backgroud Service(백그라운드 서비스)__ :star:      
      - 모든 일반용 시스템은 부트 시간에 특정 시스템 프로그램 프로세스를 실행하기 위한 수단을 가지고 있다.      
      - 일부 프로세스는 작업이 완료된 후 종료하지만, 다른 일부는 시스템이 중단될 때까지 작동한다.   
      - __계속해서 실행되는 시스템 프로그램 프로세스는 Service, Subsystem 또는 Daemon이라고 알려져 있다.__   
        - ex) 네트워크 데몬   
          - 시스템은 정확한 프로세스에 연결 요청을 하기 위해 네트워크 연결을 듣는 서비스가 필요했다.   
        - ex) 프로세스 스케줄러, 시스템 오류 감시 서비스 등   
      - 시스템 프로그램과 마찬가지로 대부분의 OS는 공동 작업 수행 또는 공동 문제 해결하는데 유용한 프로그램을 제공한다.   
        - ex) 웹 브라우저, 워드 프로세서, 게임, 컴파일러, 데이터 베이스 시스템, 통계 분석 패키지 같은 app   
      - 대다수 사용자에 의해 보여지는 OS의 view는 시스템 호출보다는 시스템 프로그램과 app에 의해 정의된다.   
        - ex) MAC OS X   
          - 사용자는 mouse-and-window interface인 GUI만 본다.   
          - 다른 윈도우에서는 사용자가 UNIX shell을 가질 수도 있다.   
          - 둘 다 같은 시스템 호출 집합을 사용하지만, 다르게 보이고 다른 방식으로 동작한다.   
        - ex) dual-booting from MAC OS X to Window   
          - 같은 하드웨어에서 같은 사용자가 완전히 다른 두 개의 인터페이스를 가지고 같은 물리적 자원을 사용하는 app의 두 집합을 가진다.   
            - 하나의 사용자가 동시적으로 또는 순차적으로 다수의 사용자 인터페이스에 노출된다.   
      
### 2.6 Operating-System Design and Implementation   
#### 2.6.1 Design Goals(설계 목적)   

  - __고수준에서 시스템의 설계는 하드웨어와 시스템의 종류에 영향을 받는다.__   
    - 일괄 처리, 시간 분할, 단일 사용자, 다수 사용자, 분산, 실시간, 일반       
    
  - __사용자 목적__   
    - 사용하기 편하고, 배우기 쉽고, 사용하기 쉽고, 의존할 수 있고 안전하고 빨라야한다.      
    - 이것을 보장하기 위한 일반적인 해결책은 없고 시스템 설계에 도움이 되지는 않는다.   
    - 시스템 설계, 생성, 유지, 동작하는 사람들에게는 시스템이 설계, 구현, 유지하기 쉽고, 효율적이고 에러가 없고, 의존할 수 있고, 유연해야 한다.       
    
#### 2.6.2 Mechanisms and Policies(메카니즘과 정책)    

  - __Mechanism__   
    - how to do something             
      - ex) 타이머 구조는 CPU 보호를 보장하기 위한 메카니즘이다.              
      
  - __Policy__   
    - what will be done        
      - ex) 특정 사용자를 위해 타이머를 얼마동안 세팅할지 결정    

  - __Policy와 Mechanism의 분리는 유연성에 있어 중요하다.__   
    - policy는 시간이 흐르면서 또는 공간을 가로지르면서 변화한다.   
      - 가장 최악의 경우는 policy에서 각각의 변화가 근본적인 mechanim에서의 변화를 요청할 때이다.   
    - policy의 변화에 둔감한 mechanism이 이상적이다.   
    - policy 결정은 모든 자원 할당에 있어 중요하다.   
      - 자원을 할당할지 결정하는 것이 필수적일 때마다 policy 결정이 확인되어야만 한다.   
    - 문제가 what 보다 how일 경우 mechanism이 반드시 확인되어야 한다.   

      
#### 2.6.3 Implementation(구현)   

  - __어떻게 구현할지에 대한 일반적인 명세문을 만드는 것은 어렵다.__   
  
  - __초기 OS는 어셈블리 언어로 쓰여졌고 현재 대부분의 OS는 C, C++ 같은 고수준 언어로 쓰여진다.__   
    - OS는 하나 이상의 언어로 쓰여질 수 있다.   
    - 고수준 루틴은 C로 되어 있을 수 있고, 시스템 프로그램은 C 또는 C++, interpreted scripting 언어인 PERL 또는 Python 또는 Shell script로 되어 있을 수 있다.   
    - Linux는 이러한 모든 언어에서 쓰여진 프로그램을 포함한다.   
    - OS 구현을 위해 최소한 시스템 구현 언어 또는 고수준 언어를 사용함으로써 얻어지는 장점이 있다.   
      - __장점__   
        - 코드가 더 빠르게 작성될 수 있고 더 간결하고 이해하기 쉽고 디버그도 쉽다.   
        - 컴파일러 기술의 발전은 간단한 재컴파일만 하더라도 전체 OS를 위해 생성된 코드를 향상 시킬 것이다.    
        - 고수준 언어로 작성될 경우 다른 하드웨어로 이동하기 위한 이식이 훨씬 쉽다.   
      - __단점__   
        - 속도가 느리고 저장장치가 많이 소요된다.   
          - 하지만 하드웨어 성능의 발전으로 오늘날의 시스템에서는 더 이상 문제가 되지 않는다.   
    - 어셈블리어 프로그래머는 효율적인 작은 루틴을 생산할 수 있지만 현대의 컴파일러는 대규모 프로그램을 위해 복잡한 분석을 수행하고고 그리고 정교환 최적화를 적용하여 우수한 코드를 생산 할 수 있다.   
    - 현대 프로세서는 깊은 파이프라이닝과 사람보다 훨씬 쉽게 복잡한 의존성의 세부사항을 다룰 수 있는 다수의 기능 유닛을 가지고 있다.   
    - OS에서 주요한 성능 향상은 좋은 어셈블리어 코드보다 좋은 자료구조와 알고리즘의 결과일 가능성이 크다.   
    - OS가 큼에도 불구하고, 입출력 관리, 메모리 관리, CPU 스케줄러, 인터럽트 핸들러 같은 코드의 작은 부분이 고성능에 중요하다.   
    - 시스템이 작성되고 정확하게 동작한 후에는, 병목현상이 발견될 수 있고, 동등한 어셈블리어로 교체될 수 있다.   

### 2.7 Operating-System Structure   

  - __하나의 단일 구조를 가지는 것보다 작업을 작은 요소 또는 모듈로 나눠야 한다.__   
    - 각 모듈은 정의된 입력, 출력, 기능을 가진 시스템의 잘 정의된 부분이여야 한다.      

#### 2.7.1 Simple Structure(간단한 구조)   
    
  - __운영체제는 처음에는 소형이면서 간단하고 제한된 시스템으로 시작 되었다. 최소의 공간에 최대의 기능들을 제공하도록 작성되어 있어서 모듈들로 주의 깊게 분할 되지 않았다.__   
    - __MS-DOS__   
      - 인터페이스와 기능 계층이 잘 분리되어 있지 않다.   
        - 응용 프로그램이 기본 입/출력 루틴을 통하여 디스플레이와 디스크 드라이브에 직접 쓰기가 가능 하다.   
        - 이런 자유는 프로그램을 취약하게 만들었다. 따라서 사용자 프로그램이 고장나면 시스템 전체가 고장나게 된다.   
      - MS-DOS는 시작부터 하드웨어의 기능에 제한적이었으며 Intel 8088이 이중 모드와 하드웨어 보호 기능을 제공하지 않기 때문에 MS-DOS의 설계자들은 기본 하드웨어를 접근하도록 하용 할 수 밖에 없었다.   
      
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/2_11_DOS_Structure.jpg"  title="2_11_DOS_Structure" alt="2_11_DOS_Structure"></img><br><strong>2.11 MS-DOS 계층 구조</strong>
      </p>
    
    - __UNIX__   
      - 처음에는 하드웨어 기능에 의해 제한 받는 시스템 구조였다.   
      - __커널과 시스템 프로그램으로 구성되어 있다.__   
        - 커널은 여러 가지 인터페이스와 장치 드라이버로 다시 분리 되었다.   
      - __시스템 호출 인터페이스와 물리적 하드웨어 사이는 커널이다.__   
        - 시스템 호출을 통해 파일 시스템, CPU 스케줄링, 메모리 관리 그리고 다른 운영체제의 기능을 제공 한다.   
        - 이러한 단일(Monolithic)구조는 구현하기 어렵고 유지보수하기도 어렵다.   
          - 하지만 커널내에서 통신 또는 시스템 호출 인터페이스 내 아주 조금의 오버헤드가 있기 때문에 성능에 이점이 있다.   
          
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/2_12_UNIX_Structure.jpg"  title="2_12_UNIX_Structure" alt="2_12_UNIX_Structure"></img><br><strong>2.12 UNIX 계층 구조</strong>
      </p>
          
#### 2.7.2 Layered Approach(계층적 접근)   

  - __적합한 하드웨어 지원으로 OS는 원래의 MS-DOS와 UNIX에 의해 허용된 것 보다 더 작고 적절한 부분들로 나뉠 수 있다.__    
  
  - __하향식(top-down) 접근법에서는 전체적인 기능과 특징이 결정되고 구성 요소로부터 분리가 된다.__       
    - 저수준의 루틴에서 외부 인터페이스가 변경되지 않고 루틴 자체가 명시된 일을 수행한다면 자유스럽게 구현할 수 있는 대신 보안에 취약하다.   
    
  - __계층적 접근 방식은 운영체제가 여러 개의 계층으로 나누어 진다.__   
    - 최하위 계층 0은 하드웨어   
    - 최상위 계층 N은 사용자 인터페이스   
    
    <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/2_13_Layered_OS.jpg" width =300px height = 300px title="2_13_Layered_OS" alt="2_13_Layered_OS"></img><br><strong>2.13 계층화된 OS</strong>
      </p>
    
  - __OS 계층은 데이터를 조작할 수 있는 동작과 데이터로 구성된 추상적 객체의 구현이다.__   
    - 높은 계층에 의해 야기되는 작업의 집합과 자료구조로 구성된 계층 M은 낮은 계층에서 작업을 일으킬 수 있다.   
  
  - __계층적 접근 방식의 장점은 구성과 디버깅의 간단함이다.__  
    - 계층들은 단지 자신의 하위 계층들의 서비스와 기능을 사용하기 위해 선택된다.   
    - 첫 번째 계층은 다른 부분에 대한 걱정없이 하드웨어만을 사용하여 디버깅 할 수 있다.   
      - 자신의 기능을 수행하기 위해 오직 기본 하드웨어만 사용하기 때문이다.   
    - 첫 번째 계층 디버깅이 끝나고, 두 번째 계층이 디버그되는 동안 첫번째 계층의 기능이 정확하게 연산한다고 가정될 수 있다.   
    - 특정 계층에서 디버깅 동안 에러가 발생되면 하위 계층은 이미 디버그 된 상태이기 때문에 해당 에러는 반드시 그 계층에 있다.   
    - 각 계층은 하위 계층에 의해 제공된 연산만 사용해 구현한다.    
      - 계층은 연산들이 어떻게 구현되는지 알 필요가 없고 이러한 연산들이 무엇을 하는지만 알면 된다.   
      - 각 계층은 상위 계층으로부터 하드웨어, 연산, 자료구조의 존재를 숨긴다.   
      - 따라서 계층을 나누면 시스템의 설계나 구현이 간단해진다.   
      
  - __계층적 접근 방식의 단점은 여러 계층을 정의하는 것이 어렵다는 것이다.__
    - 각 계층은 오직 하위 계층만 사용할 수 있기 때문이다.   
    - 예를 들어 예비 저장 장소(Backing store :가상 메모리 알고리즘에 의해 사용되는 디스크 공간)를 위한 장치 드라이버는 메모리 관리가 예비 저장 장소를 사용할 수 있는 능력을 필요로 하기 때문에 메모리 관리 루틴들보다 저수준에 있어야 한다.   
  
  - __계층적 구현의 문제점은 다른 유형의 구현 방법보다 효율성이 낮다는 것이다.__   
    - 각 계층에서 매개변수들이 수정될 수 있고 데이터는 전달되야 한다.   
    - 각 계층은 시스템 호출에 오버헤드를 추가하기 떄문에 계층적 구조가 아닌 시스템에서보다 더 오래 걸리는 시스템 호출을 가지게 된다.   
    - 이러한 제한으로 작은 backlash를 야기하지만 개선되고 있다.   
    
    
#### 2.7.3 Microkernels(마이크로커널)   

  - __커널로부터 불필요한 구성 요소를 제거하고 커널을 시스템 및 사용자 수준 프로그램으로 구현하여 운영체제를 구성하였다.__   
    - 서비스는 커널에서 남아있어야하고 사용자 공간에서 구현되어야 한다.   
    - 최소한의 프로세스와 메모리 관리, 통신 기능을 제공한다.   
    - 주요 기능은 클라이언트 프로그램과 사용자 공간에서 수행되는 다양한 서비스간에 통신을 제공하는 것이다.   
    - 통신은 메세지 교환을 통해 제공된다.   
    
  - __장점__   
    - OS 확장을 쉽게 할 수 있다.   
      - 모든 새로운 서비스는 사용자 공간에 추가되며 커널 수정은 필요하지 않다.   
      - 마이크로커널이 더 작은 커널이기 때문에 커널이 수정되어야만 할 때 변경이 더 적은 편이다.   
    - 다른 하드웨어로 이식이 쉽다.   
    - 높은 보안성과 신뢰성을 제공한다.   
      - 대부분 서비스가 사용자로 실행이 되기 때문이다.   
      - 서비스가 잘못되더라도 OS의 다른 부분은 영향을 받지 않는다.   
  
  - __단점__   
    - 가중된 시스텡 기능 오버헤드 때문에 성능이 감소된다.   
    
    <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/2_14_microkernelArchitecture.jpg"  title="2_14_microkernelArchitecture" alt="2_14_microkernelArchitecture"></img><br><strong>2.14 마이크로커널 구조</strong>
      </p>
   
#### 2.7.4 Modules(모듈)   
  
  - __OS 설계를 위한 현재 최고의 방법론은 loadable 커널 모듈을 사용하는 것과 관련이 있다.__   
    - 커널은 부트 시간 또는 실행되는 동안 모듈을 통해 추가적인 서비스에 대한 링크와 핵심 요소의 집합을 가진다.   
    - 이러한 설계 유형은 Solaris, Linux, Mac OS X, Window의 같은 현대 UNIX의 구현에서 흔한다.   
    - 다른 서비스들이 동적으로 구현되는 동안 커널이 핵심 서비스를 제공한다.   
    - 동적으로 서비스를 연결하는 것은 매변 변화가 있을때마다 커널 재컴파일을 요구하지 않고 커널에 직접적으로 새로운 특성을 추가하려고 하는 것이다.   
      - ex) CPU 스케줄링과 메모리 관리 알고리즘을 직접적으로 커널에 만들고 loadable 모듈 방식으로 다른 파일 시스템을 위한 자원을 추가한다.   
    - 전체적인 결과는 각 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층적 구조를 닮았지만 모듈은 임의의 모듈을 호출할 수 있다는 점에서 계층적 구조보다 더 유연하다.   
    - 중심 모듈은 핵심 기능만을 가지고 있고 다른 모듈의 적재 방법과 모듈들과 어떻게 통신하는지 안다는 점에서 마이크로 커널과 유사하지만 모듈은 통신을 하기위해 메세지 전달을 호출할 필요가 없기 때문에 더 효율적이다.   
    
#### 2.7.5 Hybrid Systems(하이브리드 시스템)   
  
  - __Linux, Solaris는 monolithic이면서 modular이다.__   
    - 하나의 주소 공간에 있는 OS를 가지는 것은 아주 효율적인 성능을 제공 = monolithic   
    - 새로운 기능들이 커널에 동적으로 추가 = modular   
    
  - __Window는 monolithic이면서 마이크로커널 시스템의 일부 동작을 가지고 있으며, 동적으로 적재하는 커널 모듈을 지원한다.__   
  - __MAC OS X, iOS, Android가 대표적이다.__   
  
### 2.8 Operationg-System Debugging   
  
  - __디버깅은 병목현상인 프로세스를 제거함으로써 성능을 향상시키는 Performance tuning을 포함한다.__   

#### 2.8.1 Failure Analysis(실패 분석)   

  - __프로세스가 실패한다면, 대부분 OS는 문제가 발생한 사용자 또는 시스템 오퍼레이터에 알려주기 위해서 log 파일에 에러 정보를 기록한다.__   
  
  - __OS는 특정 시점에 작업 중이던 메모리 상태를 기록한 core dump(= memory dump, system dump)를 차후 분석을 위해 파일에 저장시킨다.__   
  - __프로세스의 메모리와 코드를 분석하게 해주는 디버거에 의해 실행되는 프로그램과 core dump가 조사될 수 있다.__   
    - 디버거는 프로그래머가 프로세스의 메모리, 코드를 조사할 수 있게 해준다.   
    
  - __OS 커널 디버깅은 사용자 수준 디버깅 툴의 부족, 하드웨어의 통제, 커널의 복잡성, 크기 때문에 사용자 수준 프로세스 코드를 디버깅하는 것보다 훨씬 복잡하다.__   
  
  - __커널에서의 실패는 crash dump라고 한다.__   
    - crash가 발생할 때, 에러 정보는 log 파일에 저장되고, 메모리 상태는 crash dump에 저장된다.   
    
  - __OS 디버깅과 Process 디버깅은 다른 툴과 기술을 사용한다.__   
    - 파일 시스템 코드에서 커널 실패는 커널이 재부팅하기전에 파일 시스템에 있는 파일에 커널의 상태를 저장하는 것에 대한 위험성을 가지게 할 수 있다.   
    - 일반적인 기술은 파일 시스템을 포함하지 않는 용도를 위해 확보된 디스크 부분에 커널의 메모리 상태를 저장하는 것이다.   
    - 커널이 회복 불가능한 에러를 감지하면, 메모리 전체 내용 또는 적어도 시스템 메모리의 커널 부분을 디스크 영역에 기록한다.   
    - 시스템이 재부팅될 때, 디스크 영역으로부터 데이터를 모으기 위한 프로세스가 실행되고 이러한 데이터를 분석을 위해 파일 시스템 내에 있는 crash dump file에 기록한다.   
    - 이러한 방식은 일반적인 사용자 수준 프로세스 디버깅에서 불필요하다.   
    
#### 2.8.2 Peformance Tuning(성능 조정)   
  
  - __병목 현상을 확인하기 위해서 시스템 성능을 모니터 할 수 있어야 한다.__   
  
  - __OS는 시스템 동작의 trace listing을 생산함으로써 이러한 모니터를 수행하여 성능을 조정할 수 있다.__   
    - 모든 관심있는 event는 event의 시간, 중요한 파라미터와 함께 log되고 파일에 작성된다.   
    - 분석 프로그램은 비효율성, 병목현상을 확인하고 시스템 성능을 측정하기 위해서 log 파일을 사용할 수 있다.   
    - 이와 같은 추적은 제안된 개선 시스템의 모의 실험을 위한 입력으로 동작할 수 있고 또한 사람들이 OS 동작에서 에러를 발견하는데 도움을 줄 수 있다.    
    
  - __상호작용적인 단일 목적 툴을 사용하여 성능을 조정할 수 있다.__   
    - 상호적용적인 단일 목적 툴은 사용자와 관리자가 병목현상을 찾기 위해 다양한 시스템 요소의 상태를 물어볼 수 있게 해준다.   
    - UNIX 명령어 `top`는 시스템에서 사용된 자원과 자원을 사용하는 프로세스의 정렬된 리스트도 보여준다.   
    - 다른 툴은 디스크 입출력, 메모리 할당, 네트워크 트래픽의 상태를 보여준다.   
    - Window Task Manager는 메모리 사용량, CPU, 프로세스, 네트워킹 통계, 현재 app을 위한 정보를 포함한다.   
    
#### 2.8.3 DTrace    

  - __DTrace는 커널과 사용자 프로세스가 실행되는 시스템에 probe를 동적으로 추가할 수 있는 기능이다.__   
    - 이러한 probe들은 프로세스 활동, 시스템 상태, 커널에 대한 엄청난 양을 확인하기 위해서 D 프로그래밍 언어를 통해 쿼리를 받을 수 있다.   
    - u : 사용자 모드, k : 커널 모드   
  
  - __사용자 수준과 커널 코드 사이에 상호작용 디버깅은 두 코드를 이해하고 상호작용을 할 수 있게 하는 도구없이는 거의 불가능하다.__   
  
  - __도구는 반드시 시스템의 어떠한 부분도 디버그 할 수 있어야하고 시스템의 의존성없이 사용할 수 있어야 한다. 그리고 최대한 성능에 영향을 미치지 않는 것이 좋다.__     
     - 사용하지 않을 때는 영향을 주지 않고, 사용 중일 경우에는 아주 부분적인 영향만 주는 것이 이상적이다.   
     
  - __DTrace 도구는 이러한 요건을 충족하고 동적이고 안전하고 저영향 디버깅 환경을 제공한다.__   
    - 시스템에 해를 끼치지 않고 중요한 app을 실행시키는 생산적인 시스템에서 실행된다.   
    - 실행가능하게 하는 동안 작업들을 느리게 하지만, 실행한 후 시스템을 pre 디버깅 상태로 재설정한다.   
    - 시스템에서 발생한 모든 것을 디버그할 수 있고 각 CPU 명령어 또는 커널 서브루틴 작업을 보여주는 코드를 깊게 조사할 수 있다.   
    
  - __DTrace는 컴파일러, 프레임워크, 프레임워크 내에 쓰여진 probe들의 provider, customer로 구성된다.__   
    - provider는 probe를 생성하고 커널 구조는 모든 probe를 추적하기 위해 존재한다.   
    - probe는 고유한 probe 식별자에 따른 색인과 이름에 의한 해시된 해시 테이블 구조에 저장되어 있다.   
    - probe가 실행 가능해질 때, probe가 되기 위한 영역의 코드의 일부분이 dtrace-probe를 호출하기 위해 재기록되고 코드의 원래 수행을 계속한다.   
    - 다른 provider는 다른 종류의 probe를 생선한다.   
      - ex) 커널 시스템 호출 probe는 사용자 프로세스 probe, 입출력 probe와 다르게 동작한다.   
    - 컴파일러는 커널에서 실행되는 byte 코드를 생성한다.   
      - 이러한 byte 코드는 컴파일러에 의해서 안전이 보장되기 때문에, loop가 허용되지 않고, 특정 커널 상태 수정만이 특별하게 요청되었을 때만 수정을 허락한다.   
      - 권한을 얻은 사용자 또는 root 사용자만 DTrace를 사용할 수 있다.   
      - 생성된 코드는 커널에서 실행되고 probe를 작동시키며, 사용자 모드에서 consumer를 실행시키고 두 consumer간 통신을 실행시킨다.   
  
  - __consumer는 probe에 관심이 있는 코드이고 probe의 결과이다.__   
    - provider에게 하나 이상의 probe 생성을 요청한다.   
    - probe가 fire될 때, 커널에 의해 관리된 데이터를 방출한다.   
 
  - __커널 내에서 Enabling Control Blocks(ECBs)라 불리는 행동이 probe가 fire될 때 수행된다.__   
    - 하나의 probe는 해당 probe에 관심이 있는 하나 이상의 consumer가 있으면 실행시키기 위해 다수의 ECB를 일으킬 수 있다.   
    - 각 ECB는 해당 ECB로 걸러질 수 있는 predicate (if문)을 가지고 있다.   
    - 그렇지 않을 경우 ECB안에 있는 일련의 행동의 리스트가 실행되어진다.   
    - 가장 일반적인 동작은 검사 실행 시점에서 변수의 값 같은 데이터의 일부분을 수집하는 것이다.   
      - 이러한 데이터를 모음으로써, 사용자 또는 커널 동작의 완벽한 그림이 만들어질 수 있다.   
    - 사용자, 커널로부터 firing되는 probe는 어떻게 사용자 수준 동작이 커널 수준 반응을 일으키는지 보여줄 수 있다.   
    - 이러한 데이터는 성능 모니터, 코드 최적화에 있어 가치가 없다.   
    - probe consumer가 종료되면, 각 ECB는 제거된다.   
      - dtrace_probe() 함수를 제거하기 위해 코드를 재작성하고 원래 코드로 되돌리는 것과 관련 있다.   
      - probe가 생성되기 전과 파괴된 후 시스템은 probing이 일어나지 않은 것처럼 똑같다.   
  
  - __DTrace는 probe가 너무 많은 메모리 또는 CPU를 사용하지 않는 것을 보장하기 위해 관리한다.__   
    - 조사 결과를 담기 위해 사용되는 버퍼는 default 최대값을 초과하는지 모니터된다.   
    - 조사 수행을 위한 CPU 시간도 모니터된다.   
    - 한계과 초과되면, consumer는 초과하는 probe와 같이 종료된다.   
    - 버퍼는 데이터 손실을 피하기 위해 CPU당 할당되어진다.   
  
  - __오픈 소스이기 떄문에 Mac OS X, Free BSD에도 추가되어졌다.__   
  
### 2.9 Operating-System Generation   

  - __시스템은 각 특정 컴퓨터를 위해서 설정되거나 생성되어야 한다.__   
    - 이러한 프로세스는 System generation(SYSGEN)이라고 알려져있다.   
    
  - __시스템을 생성하기 위해, 특별한 프로그램을 사용한다.__   
    - SYSGEN 프로그램은 주어진 파일(ISO image)로부터 읽거나 하드웨어 시스템의 특정 설정을 고려한 정보를 위해 시스템 오퍼레이터에 물어보거나 어떤 요소가 있는지 알아보기 위해 하드웨어를 직접 조사한다.   
    
  - __반드시 확인되어야 될 정보__   
    - 어떤 CPU가 사용되어야 하는가, 어떤 옵션이 설치되어야 하는가?   
      - 멀티 CPU 시스템 같은 경우, 개별 CPU가 기술될 수 있다.   
    - 부트 디스크를 어떤 형식으로 할 것인가?, 얼만큼의 부분 또는 파티션으로 나눌 것인가?, 각 파티션에 어떤 것들이 들어갈 것인가?   
    - 얼만큼의 메모리가 이용가능한가?   
      - 일부 시스템은 illegal address가 발생할 때까지 메모리를 할당 후, 메모리 위치를 참조함으로써 확인한다. 이러한 과정은 마지막 legal address와 이용가능한 메모리 양을 정의한다.   
    - 어떤 장치가 이용가능한가?   
      - 시스템은 각 장치 번호, 인터럽트 번호, 타입, 모델, 특성을 다루는 방법을 알아야 한다.   
    - 어느 OS 옵션이 요구되는지 또는 어떤 파라미터 값이 사용되어야 하는가?   
      - 얼만큼의 버퍼 크기가 사용되는지, 어떤 CPU 스케줄링 알고리즘이 요구되는지, 지원할 수 있는 최대 프로세스 수가 몇인지 등   
      
  - __정보가 사용되는 방식__    
    - __시스템 관리자가 OS의 소스코드 복사본을 수정하기 위해 정보를 사용할 수 있다.__   
      - OS는 완벽히 컴파일되어있고 조건들에 따라 데이터 선언, 초기화, 변화는 묘사된 시스템에 맞춘 OS의 output-object 버전을 생산한다.   
      
    - __시스템 묘사는 미리 컴파일된 라이브러리부터 모듈의 선택과 테이블의 생성을 이끌 수 있다.__   
      - 이러한 모듈은 생성된 OS를 형성하기 위해 서로 연결된다.   
      - 선택은 모든 지원 가능한 입출력 장치를 위한 장치 드라이버를 함유하기 위해 라이브러리를 사용가능하게 하지만, 필요한 라이브러리들이 OS에 연결되어야 한다.   
      - 시스템이 재컴파일되지 않았기 때문에, 시스템 생성은 더 빠르지만 결과적인 시스템은 너무 일반적일 수 있다.   
    
    - __완벽하게 테이블 중심으로 시스템을 만들 수 있다.__   
      - 모든 코드는 시스템의 항상 부분이 되고, 컴파일 또는 연결 시간보다 실행시간에 선택이 일어난다.   
      - 시스템 생성은 시스템을 묘사하기 위해 적절한 테이블을 생성하는 것과 관련이 있다.   
    
    - __이러한 접근 방식의 차이점은 생성된 시스템의 일반성, 크기 그리고 하드웨어 설정 변경과 같은 수정의 편의성이다.   
    
### 2.10 System Boot   

  - __커널을 로딩함으로써 컴퓨터를 시작하는 과정을 booting systme이라고 한다.__   
  
  - __대부분 컴퓨터에서, 부트스트랩 프로그램 또는 부트스트랩 로더는 커널을 찾아내고, 커널을 메인 메모리로 적재하고 실행시킨다.__    
   
  - __PC같은 일부 컴퓨터 시스템은 간단한 부트스트랩 로더가 결과적으로 커널을 적재하는 디스크로부터 더 복잡한 부트 프로그램을 불러오는 two-step 프로세스를 사용한다.   
  
  - __파워가 켜지거나 reboot 됐을 때와 같이 CPU가 reset event를 받을 경우, 명령어 레지스터에 미리 정의된 메모리 위치가 적재되어 지고, 그곳에서 실행을 시작한다.   
    - 해당 위치에는 초기 부트스트랩 프로그램이 있다.   
    - RAM은 시스템 시작 시에 알려지지 않은 상태에 있기 때문에, 해당 프로그램은 ROM에 들어있다.   
    - ROM은 초기화가 필요없고, 컴퓨터 바이러스에 의해 쉽게 감염되지 않기 때문에 편리하다.   
    
  - __부트스트랩 프로그램은 다양한 작업을 수행할 수 있다.__   
    - 기계의 상태를 확인하기 위해 진단을 할 수 있다.   
    - 진단이 끝나면, 프로그램은 부팅 과정를 계속 진행한다.   
    - CPU 레지스터부터, 장치 조종, 메인 메모리의 내용까지 시스템의 모든 측면을 초기화할 수 있다.   
    - 그 이후 OS를 시작한다.   
    
  - __휴대폰, 태블릿, 게임 콘솔같은 시스템은 ROM에 전체 OS가 저장되어있다.__   
    - ROM에 OS를 저장하는 것은 작은 OS, 간단한 하드웨어 지원, 단호한 동작에 적합하다.   
    - 부트스트랩 코드를 변경하면 ROM 하드웨어 칩 변경을 해야하는 문제점이 있다.   
    - 일부 시스템은 EPROM을 사용함으로써 이러한 문제를 해결한다.   
      - EPROM은 명백하게 주어진 명령어를 기록할 수 있을 때만 제외하고는 읽기만 가능하다.   
  
  - __ROM의 모든 형식은 firmware로 알려져 있다.__   
    - 하드웨어, 소프트웨어 사이 어딘가에 특성들이 놓여있다.   
    - firmware 문제점은 RAM에서 코드를 실행하는 것보다 느리다는 것이다.   
    - 일부 시스템은 firmware에 OS를 저장하고 OS의 빠른 실행을 위해 RAM에 복사한다.   
    - firware는 상대적으로 비싸서 오직 작은양만 이용가능하다는 문제점도 있다.   
    
  - __Window, Mac OS X, UNIX와 같은 일반용 OS를 포함한 큰 OS나 빈번하게 변경되는 OS에서는 부트스트랩 로더가 firmware에 저장되고, OS는 디스크에 있다.   
    - 부트스트랩은 진단을 하고 디스크로부터 고정된 위치(블록 0)에 있는 단일 블록을 메모리로 입력시킬수 있는 코드를 가지고 있고 해당 블록(부트 블록)에서부터 해당 코드를 실행한다.   
    - 부트 블록에 저장된 프로그램은 전체 OS를 메모리로 적재하고 실행을 시작할만큼 충분히 복잡하다.   
    - 이것은 단일 디스크 블록에 적합할 만큼 간단한 코드이고 디스크에 있는 해당 주소와 부트스트랩 프로그램의 reminder의 길이만 알고 있다.   
    
  - __GRUB은 Linux 시스템을 위한 부트스트랩 프로그램 오픈소스다.__   
    - 부트스트랩 결합 디스크와 OS 자체는 디스크에 새로운 버전을 기록함으로써 쉽게 변경될 수 있다.   
    - 부트 파티션을 가지는 디스크를 부트 디스크 또는 시스템 디스크라고 부른다.   
  
  - __완전한 부트스트랩 프로그램이 적재되면, OS 커널을 찾기 위해 파일 시스템을 가로지르고, 커널을 메모리로 적재하고 실행한다. 이 시점에서 시스템은 running 상태에 있다고 말해진다.__   
  
