# :bookmark_tabs: Operating System Concepts 9th edition      
## 2장 System Structures   
__중요하다고 생각되거나 알고 있으면 좋을 것 같다는 내용이 있던 챕터에는 :star: 표시를 해놓았고    
해당 챕터안에 중요 개념 옆에 :star: 표시 해놓습니다.   
혹시 잘못된 내용이 있거나 보완해야할 점이 있으면 `issue` 해주시거나 알려주시면 감사하겠습니다.:bow:__   

* [2.System Structures](#2system-structures)   
  - [2.1 Operating-System Services](#21-operating-system-services)   
  - [2.2 User and Operating-System Interface](#22-user-and-operating-system-interface)   
    - [2.2.1 Command Interpreters(명령어 해석기)](#221-command-interpreters명령어-해석기) :star:     
    - [2.2.2 Graphical User Interfaces(그래픽 사용자 인터페이스)](#222-graphical-user-interfaces그래픽-사용자-인터페이스)   
    - [2.2.3 Choice of Interface(인터페이스 선택)](#223-choice-of-interface인터페이스-선택)   
  - [2.3 System Call](#23-system-call)   
  - [2.4 Types of System Calls](#24-types-of-system-calls)   
    - [2.4.1 Process Control(프로세스 제어)](#241-process-control프로세스-제어)   
   
    - [](#)   
    - [](#)   
    - [](#)   
    - [](#)   

   
## 2.System Structures   
### 2.1 Operating-System Services   

  - __User Interface(사용자 인터페이스)__   
    - 거의 모든 OS는 UI(User Interface)가 있다.   
    - UI 유형   
      - __1. Command-Line Interface(CLI)__   
        - 문자 명령을 사용한다.   
      - __2. Batch Interface(일괄 처리 인터페이스)__      
        - 명령과, 명령을 제어하는 지시들이 파일로 입력되며, 이러한 파일이 실행된다.   
      - __3. Graphical User Interface(GUI)__   
        - 입/출력을 가리키고 메뉴에서 고르거나 선택을 행하는 지시 장치를 가진 윈도우 시스템과 텍스트를 입력하는 키보드로 구성된다.   

  - __Program execution(프로그램 수행)__
    - 시스템은 반드시 프로그램을 메모리에 적재해 실행시킬 수 있어야 한다.   
    - 프로그램은 반드시 정상적으로 또는 비정상적으로(에러를 나타내면서) 자신의 실행을 종료시킬 수 있어야 한다.   

  - __I/O operations(입출력 연산)__   
    - 실행되고 있는 프로그램은 파일 또는 입출력 장치와 관련된 입출력을 요구할 수도 있다.   
    - 효율성과 보호를 위해 사용자들은 보통 입출력 장치를 직접 제어할 수 없다. 따라서 운영체제가 입출력 수행을 위한 수단을 제공해야 한다.   


  - __File-system manipulation(파일 시스템 조작)__   
    - 프로그램은 파일과 디렉토리를 읽고 쓸 뿐만 아니라 이름에 의한 생성, 삭제, 지정된 파일 검색, 파일 정보를 열거할 수 있어야 한다.   

  - __Communication(통신)__   
    - 프로세스간 정보를 교환해야할 상황이 있다.      
    - ex) 한 컴퓨터 내에 실행되는 프로세스들 또는 컴퓨터 네트워크로 연결된 다른 컴퓨터 시스템에서 실행되는 프로세스들   
    - __1. 공유 메모리 방법__   
      - 메모리의 공유된 영역에 두 개 이상의 프로세스가 읽고 쓸 수 있다.      
    - __2. 메세지 전달 방법__   
      - 미리 정의된 형식의 정보의 패킷이 OS에 의해 프로세스들 사이에 이동한다.   

  - __Error detection(오류 탐지)__   
    - OS는 항상 모든 가능한 오류를 감지하고 해결할 수 있어야 한다.      
    - __Error 종류__   
      - __CPU와 Memory hardware__   
        - 메모리 에러 또는 파워 문제  
      - __입출력 장치__   
        - 디스크 Parity 에러, 네트워크 연결 실패, 프린터 용지 부족 등   
      - __사용자 프로그램__   
        - 연산 오버플로우, 잘못된 메모리 위치 접근 시도, 너무 큰 CPU 사용 시간 등   
    - 오류에 대한 적절한 조취를 취해 정확하고 일관된 컴퓨터 사용을 보장해야 하지만, 시스템을 중단시켜야만 하는 경우도 있다.   
    - 오류를 야기하는 프로세스를 종료시키거나 프로세스가 오류를 감지하고 수정할 수 있게 프로세스에 에러 코드를 반환시킨다.   
    
  - __OS 효율성을 보장하는 기능__   
       
    - __Resource allocation(자원 할당)__   
      - 다수의 사용자나 다수의 작업이 동시에 실행 될 때 각각에 자원을 할당 해야 한다.   
      - CPU 사이클, 메인 메모리, 파일 저장 장치는 특병한 할당 코드를 가질 수도 있다.      
      - 입출력 장치는 더 일반적인 요청, 해제 코드를 가질 수 있다.   
      - CPU 사용을 가장 잘하는 방법을 결정하는데 있어서, OS는 CPU의 속도, 반드시 실행되어야하는 작업, 이용가능한 레지스터의 수 등을 고려하는 CPU 스케줄링 루틴을 가지고 있다.      

    - __Accounting(회계)__   
      - 어느 사용자가 얼마만큼 그리고 어떤 컴퓨터 자원을 사용하는지 알아야 한다.      
      - 이러한 사용 기록 저장은 회계나 사용량 통계를 축적하는데 사용된다.       
      - 사용량 통계는 컴퓨팅 서비스를 향상시키기 위해 시스템을 변경하기를 바라는 리서처들에게 좋은 수단이 될 수 있다.    
            
    - __Protection and security(보호와 보안)__   
      - 분리된 프로세스가 동시에 실행될 때, 하나의 프로세스가 다른 프로세스를 방해하거나 OS를 방해하지 않아야 한다.      
      - 보호는 시스템 자원에 모든 접근이 통제되도록 보장하는 것과 관련이 있다.    
      - 외부로부터 시스템 보안은 각 사용자가 시스템 자원 접근 권한을 얻기 위해 비밀번호와 같은 수단으로 자신을 시스템에 인증하는 것이다.       
      - 칩입을 감지하기 위해 모든 연결을 기록하고 부적절한 접근 시도로부터 네트워크 아답터를 포함한 외부 입출력 장치들을 보호하는 것까지 확대된다.      
      - 시스템이 안전하고 보호되려면, 예방조치가 시스템을 전체에 도입되어야 한다.       

### 2.2 User and Operating-System Interface   
#### 2.2.1 Command Interpreters(명령어 해석기)   

  - __일부 OS는 커널이 명령어 해석기를 포함한다.__   
  
  - __Window, UNIX와 같은 OS는 명령어 해석기를 사용자가 처음으로 로그인하거나 작업이 시작될 때 실행되는 특수한 프로그램으로 간주한다.__         
  - __Shell__ :star:   
    - __시스템에서 선택할 수 있는 여러 명령어 인터프리터를 말한다.__      
    - UNIX, Linux에서는 사용자가 Boorne shell, C shell, Bourne-Again shell, Korn shell 등을 포함하는 여러 shell 중 하나를 선택할 수 있다.   
    - __대부분 shell은 비슷한 기능들을 제공히고 어느 shell을 시용할지에 대한 사용자의 선택은 개인의 선호에 달려있다.__   
    - 명령어 해석기의 주요 기능은 명시된 다음 사용자 명령어을 얻고 실행하는 것이다.   
    - 이 단계에서 얻어진 대부분의 명령들은 파일을 조작한다.   
      - copy, delete, list, print, create, execute   
      
    - MS-DOS와 UNIX shell은 이러한 방식으로 동작하고 이러한 명령어들은 두 방법에 의해 수행될 수 있다.   
    
    - __1. 명령어 해석기 자체가 명령어를 실행하기 위한 코드를 가지고 있다.__   
      - 파일 삭제 명령어는 적절한 시스템 호출을 만들고 파라미터를 설정하는 코드의 영역으로 명령어 해석기가 이동하게 할 수 있다.   
      - 이러한 경우, 각 명령어가 자신만의 구현 코드를 필요로 하기 때문에 주어질 수 있는 명령어의 수가 명령어 해석기의 크기를 결정한다.   
      
    - __2. 시스템 프로그램을 통해 대부분의 명령어가 수행된다.__   
      - 명령어 해석기는 어떠한 방식에서든 명령어를 이해하지 못한다. 단지, 명령어를 메모리로 올리거나 실행될 파일을 확인하는데 사용한다.   
      - 파일 삭제를 위한 UNIX 명령어는 `rm`이라 불리는 파일을 검색하고 그 파일을 메모리로 적재하고 파라미터 `file.txt`를 가지고 실행한다.   
      - rm 명령어와 관련된 기능은 rm 파일에 있는 코드에 의해 완벽하게 정의되어 있다.   
      - 이러한 방식으로 프로그래머는 적절한 이름을 가진 새로운 파일들을 생성함으로써 시스템에 쉽게 새로운 명령어를 추가할 수 있다.   
      - 명령어 해석기 프로그램은 작을 수 잇지만, 추가되어진 새로운 명령어를 위해서 변화될 필요는 없다.   

#### 2.2.2 Graphical User Interfaces(그래픽 사용자 인터페이스)   

  - __사용자는 마우스 기반 데스크탑에 특성화된 윈도우 메뉴 시스템을 사용한다.__    
    - 프로그램, 파일, 폴더, 시스템 기능을 나타내는 아이콘이 있다.   
    - 1980년대 애플 맥킨토시 발매로 널리 퍼졌으며, 첫 GUI는 1973년 Xerox Alto 컴퓨터에 나왔다.   
    - 모바일 폰, 태블릿에서는 터치 스크린에서 gesture를 함으로써 동작한다.   
    
#### 2.2.3 Choice of Interface(인터페이스 선택)       

  - __개인 선호에 따라 선택된다.__      

  - __컴퓨터 관리하는 시스템 관리자, 시스템의 깊은 지식이 있는 Power 사용자는 CLI를 주로 사용한다.__    
    - CLI는 자신 고유의 프로그램 능력을 가지고 있기 때문에 반복적인 작업을 더 쉽게 만든다.    
    - 빈번한 작업은 명령어 라인의 집합을 필요로하고 이러한 집합은 파일에 기록될 수 있고, 이러한 파일은 프로그램처럼 실행될 수 있다.     
    - 이러한 프로그램은 실행가능한 코드로 컴파일된다기보다는 CLI에 의해 해석된다고 할 수 있다.   
    - 이러한 shell script는 Linux, UNIX 같은 CLI 지향적인 시스템에서 흔히 볼 수 있다.   
    
    
### 2.3 System Call   

  - __시스템 호출은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다.__   
    - 시스템 호출은 일반적으로 C, C++ 등과 같은 언어로 작성된 루틴 형태로 제공 된다.    
    - 하지만, 하드웨어에 직접 접근해야 하는 작업 등의 특정 ROW LEVEL 작업은 어셈블리 명령을 사용하여 작성되어야 한다.   
    
  - __시스템 호출이 사용되는 방식의 예__   
    - 한 파일로부터 데이터를 읽고 그것들을 다른 파일에 복사하는 프로그램 작성 시       
      - 프로그램이 필요할 첫 입력은 두 파일의 이름의 이름이다. 입력 파일, 출력 파일   
      - 이러한 이름들은 OS 설계에 따라 많은 방식에서 정해질 수 있다.   
      - 프로그램이 사용자에게 이름을 요청하는 방식   
        - 1. 인터렉티브 시스템에서 이러한 요청 방식은 연속적인 시스템 호출이 필요하다.   
          - 먼저 화면에 즉각적인 메세지를 작성하기위한 시스템 호출, 그 다음 두 파일을 정의하는 키보드 문자들로부터 읽어오기 위한 시스템 호출   
        - 2. 마우스 기반, 아이콭 기반 시스템에서는 파일 이름의 메뉴가 윈도우에 보인다.   
          - 사용자는 이름을 클릭하기 위해 마우스를 사용할 수 있고, 윈도우는 명시된 이름을 열 수 있다.   
          - 이러한 연속은 많은 입출력 시스템 호출이 필요하다.   
      - 두 파일의 이름을 얻게되면, 프로그램은 반드시 입력 파일을 열고 출력 파일을 생성해야 한다.   
      - 이러한 각 동작은 또다른 시스템 호출이 필요하다.   
      - 각 동작 동안 발생가능한 오류 조건은 추가적인 시스템 호출이 필요하다.   
        - 프로그램이 입력 파일을 열려고 할 때, 해당 이름의 파일이 없거나 접근이 불가할 수 있다.   
          - 콘솔(시스템 호출)에 메세지를 출력하고 비정상적인 종료(시스템 호출)을 한다.   
        - 출력 파일을 생성할 때, 같은 이름을 가진 출력 파일이 있을 수 있다.   
          - 프로그램을 중단(시스템 호출)시키거나 존재하는 파일을 삭제(시스템 호출)하고 새로운 파일 생성(시스템 호출)해야한다.   
          - 인터렉티브 시스템에서는 사용자에게 프로그램을 중단시킬건지 존재하는 파일을 교체할 것인지 물어보는 방법도 있다.   
      - 두 파일이 모두 준비되면, 입력 파일로부터 읽고(시스템 호출) 출력 파일에 쓰는(시스템 콜) 작업을 한다.   
      - 각 읽기와 쓰기는 반드시 발생가능한 에러 조건 관련한 상태 정보를 반환해야 한다.   
      - 입력에서는 파일의 끝에 도달했거나 읽기에서 하드웨어 실패(parity 에러)같은 것을 발견할 수 있고, 출력에서는 출력 장치에 따른 다양한 에러(디스크 공간 부족 등)를 마주할 수 있다.   
      - 모든 파일이 복사된 후, 프로그램은 두 파일을 종료(시스템 호출)하고 윈도우나 콘솔에 메세지를 작성(시스템 호출)하고 마지막으로 정상적으로 종료(시스템 호출)시킨다.   
    
  - __간단한 프로그램이 OS를 많이 사용하게 만들수도 있다.__   
    - 시스템은 초당 수천 개의 시스템 호출을 실행한다.      
    - 대다수 프로그래머는 이러한 세부 사항을 보지 못한다.
    - 대부분의 응용 개발자들은 응용 프로그래밍 인터페이스(Application Programming Interface, API)에 따라 프로그램을 설계한다.   
    - API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다.    
    - __응용 프로그래머가 이용하는 가장 일반적인 API 3가지__   
      - Window 시스템을 위한 Window API    
      - POSIX 기반 시스템(Linux, Mac OS X, UNIX)을 위한 POSIX API   
      - Java 가상 머신에서 실행되는 프로그램을 위한 Java API   
    - Linux, UNIX에서 C언어로 쓰여진 프로그램을 위한 라이브러리는 `libc`다.   
    - 각 OS는 각 시스템 콜을 위한 자신 고유의 이름을 가진다.   
    
  - __응용 프로그래머가 시스템 호출을 사용하는 것보다 API에 따라 프로그래밍하는 것을 선호하는 이유__   
    - __프로그램 호환성__  
      - API에 따라 프로그램을 설계하는 응용 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서나 컴파일되고 실행되기 때문이다.   
      
  - __대부분 프로그래밍 언어에서 run-time 지원 시스템은 OS에 의해 이용가능하게 만들어진 시스템 호출에 연결을 하는 시스템 호출 인터페이스를 제공한다.__   
    - API에서 함수 호출을 막고, OS내에 있는 필요한 시스템 호출을 일으킨다.       
    - 각 시스템 호출과 연관된 숫자가 있고, 시스템 호출 인터페이스는 이러한 숫자들에 따른 색인 테이블을 가지고 있다.   
    - 시스템 호출 인터페이스는 OS커널에서 예정된 시스템 호출을 일으키고 시스템 호출의 상태와 반환 값을 반환한다.   
    - 호출자는 어떻게 시스템 호출이 구현되거나 동작하는 동안 무엇을 하는지 알 필요가 없으며, 오직 API를 따르고 OS가 시스템 호출의 결과로 무엇을 할 지를 이해하기만 하면 된다.   
    - OS 인터페이스의 세부 사항의 대부분은 API에 의해 프로그래머에게 비밀이고, run-time 지원 라이브러리에 의해 관리된다.    
        
  - __OS에 매개변수를 전달하는 3가지 방식__        
    __1. 레지스터에 매개변수를 전달__   
    __2. 레지스터보다 더 많은 매개변수가 있을 경우, 매개변수가 메모리 안 블록 또는 테이블에 저장되고, 블록의 주소를 레지스터의 매개변수로 전달__   
    __3. 스택__   
      - 매개변수는 프로그램에 의해 스택에 push되고 OS에 의해 pop된다.   
      - 일부 OS에서는 전달되는 매개변수의 수나 길이의 제한이 없는 블록 또는 스택 방법을 선호한다.   
    
### 2.4 Types of System Calls   

  - __시스템 호출을 대략 6가지 주요 범주로 그룹될 수 있다.__   
    __1. Process Control(프로세스 제어)__   
    __2. File Manipulation(파일 조작)__   
    __3. Device Management(장치 관리)__   
    __4. Information Maintenance(정보 유지)__   
    __5. Commuication(통신)__   
    __6. Protection(보호)__   

#### 2.4.1 Process Control(프로세스 제어)   

  - __실행 중인 프로그램은 수행을 정상(end()) 또는 비정상(abort())으로 끝낼 수 있어야 한다.__   
    - 현재 실행되는 프로그램을 비정상적으로 종료시키기위한 시스템 호출이 만들어 지거나, 프로그램에 문제가 발생해 오류 트랩(trap)을 유발할 경우 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다.   
    - 덤프는 디스크에 기록되고 문제의 원인을 밝혀내기 위해 디버거(Bebugger)에 의해 검사될 수 있다.   
    - 이러한 비정상적 또는 정상적 상황에서, OS는 반드시 명령어 해석기로 제어를 전달해야 한다. 명령어 해석기는 이어 다음 명령을 읽는다.   
    - 인터렉티브 시스템에서 명령어 해석기는 쉽게 다음 명령어를 계속한다.   
      - 시용자가 모든 에러에 반응하기 위해 적절한 명령을 발행할 수 있는 것을 가정한다.   
    - GUI 시스템에서 팝업 윈도우는 사용자에게 에러를 알려주고 지시를 요청한다.   
    - Batch 시스템에서 명령어 해석기는 모든 작업을 종료하고 다음 명령을 계속한다.   
    
  - __일부 시스템은 에러 발생 상황에 특별한 복구 동작을 할 수 있다.__   
    - 프로그램이 입력에서 에러를 발견하고 비정상적으로 종료시키기를 원할 경우, 에러 수준을 정의하기를 원할수도 있다.     
    - 높은 수준의 에러 매개변수로 많은 심각한 에러를 나타낼 수 있다.   
    - 명령어 해석기 또는 프로그램은 자동적으로 다음 행동을 결정하기 위해 이러한 에러 수준을 사용할 수 있다.   
    
  - __프로세스나 하나의 프로그램을 실행시키는 작업은 다른 프로그램을 load()하고 execute()하기를 원할 수 있다.__   
    - 이러한 특징은 명령어 해석기가 직접적인 사용자 명령에 의한 프로그램을 실행시킬 수 있게 한다.   
      - ex) 마우스 클릭, batch 명령 등   
    - __적재된 프로그램이 종료될 때 제어가 어디로 가는지 중요하다.__     
      __1. 새로운 프로그램이 종료될 때, 기존에 사용되는 프로그램으로 제어가 넘어갈 때__   
        - 기존에 사용되는 프로그램의 메모리 이미지를 저장해야만 한다.   
        - 하나의 프로그램이 다른 프로그램을 호출하기 위한 메카니즘이 생성되어 있는 것이다.   
      __2. 두 프로그램이 병행으로 실행될 경우__   
        - 새로운 작업 또는 프로세스가 멀티프로그램되게 생성되었다.   
      __3. 새로운 프로세스나 작업을 생성하거나, 프로세스나 작업의 집합을 생성할 경우__   
        - 작업의 우선순위, 최대 허용 실행 시간 등 작업 또는 프로세스의 특성을 재설정하고 알아내는 능력이 필요하다.   
      __4. 프로세스나 작업이 부정확하거나 더 이상 필요없을 경우__   
        - 해당 프로세스 또는 작업 종료   
      __5. 작업이나 프로세스가 실행 종료되기를 기다릴 경우__    
        - 특정 시간만큼 기다리기를 원할수도 있다.   
        - 일반적으로, 특정 이벤트를 기다릴 것이다.   
        - 이벤트가 발생시 신호를 보내야 한다.   
        
  - __흔히, 두 개 이상의 프로세스가 데이터를 공유할 수 있다.__   
    - 공유된 데이터의 무결성을 보장하기 위해 OS는 프로세스가 공유하는 데이터를 lock하는 시스템 호출을 제공한다.   
      - ex) acquire_lock(), release_lock()   
    - 다른 프로세스는 lock이 해제될 때까지 해당 데이터에 접근이 불가하다.   
    
  - __Single-tasking 시스템__   
    - MS-DOS OS가 대표적인 예      
    - 컴퓨터가 시작될 때, 발동되는 명령어 해석기가 있다.   
    - 단일 작업이기 때문에 프로그램을 실행하고, 새로운 프로세스를 생성하지 않는 간단한 방법 사용한다.   
    - __과정__   
      __1. 가능한한 최대의 메모리를 프로그램에 주기 위해 메모리 대부분을 쓰면서 프로그램을 메모리 적재한다.__   
      __2. 명령어 포인터를 프로그램의 첫 번째 명령어로 설정한다.__   
      __3. 프로그램이 실행되면 에러가 발생하거나, 프로그램은 종료시키기 위한 시스템 호출을 실행한다.__   
        - 에러 코드는 나중에 사용하기 위해 시스템 메모리에 저장된다.   
        - 위의 행동을 따르면서, overwrite되지 않은 명령어 해석기의 작은 부분은 실행을 재개한다.  
        - 첫 작업은 디스크로부터 명령어 해석기의 나머지 부분을 재적재하는 것이다.   
        - 명령어 해석기는 다음 프로그램이나 사용자가 이전 에러코드를 사용가능하게 해준다.   
  
  - __Multi-tasking 시스템__   
    - FreeBSD(Berkeley UNIX에서 파생)가 대표적인 예     
    - 사용자가 시스템에 로그인 할 때, 사용자가 선택한 shell이 실행된다.   
    - 사용자가 요청한 프로그램을 실행하고 명령을 허용하는데 있어 MS-DOS shell과 비슷하다.   
    - 멀티태스킹 시스템이기 때문에, 명령어 해석기는 다른 프로그램이 실행되는 동안 계속 실행된다.   
    
    
  - ____   
    -   
    -   
  
  - ____   
    -   
    -       
### 2.
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -    
    -    
  - ____   
    -   
    -   
### 2.
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -    
    -    
  - ____   
    -   
    -   
### 2.
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -    
    -    
  - ____   
    -   
    -   
### 2.
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -    
    -    
  - ____   
    -   
    -   
### 2.
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -    
    -    
  - ____   
    -   
    -   
