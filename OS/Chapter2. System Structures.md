# :bookmark_tabs: Operating System Concepts 9th edition      
## 2장 System Structures   
__중요하다고 생각되거나 알고 있으면 좋을 것 같다는 내용이 있던 챕터에는 :star: 표시를 해놓았고    
해당 챕터안에 중요 개념 옆에 :star: 표시 해놓습니다.   
혹시 잘못된 내용이 있거나 보완해야할 점이 있으면 `issue` 해주시거나 알려주시면 감사하겠습니다.:bow:__   

* [2.System Structures](#2system-structures)   
  - [2.1 Operating-System Services](#21-operating-system-services)   
  - [2.2 User and Operating-System Interface](#22-user-and-operating-system-interface)   
    - [2.2.1 Command Interpreters(명령어 해석기)](#221-command-interpreters명령어-해석기) :star:     
    - [2.2.2 Graphical User Interfaces(그래픽 사용자 인터페이스)](#222-graphical-user-interfaces그래픽-사용자-인터페이스)   
    - [2.2.3 Choice of Interface(인터페이스 선택)](#223-choice-of-interface인터페이스-선택)   
  - [2.3 System Call](#23-system-call)   
  - [2.4 Types of System Calls](#24-types-of-system-calls)   
    - [2.4.1 Process Control(프로세스 제어)](#241-process-control프로세스-제어)   
    - [2.4.2 File Management(파일 관리)](#242-file-management파일-관리)   
    - [2.4.3 Device Management(장치 관리)](#243-device-management장치-관리)   
    - [2.4.4 Information Maintenance(정보 유지)](#244-information-maintenance정보-유지)   
    - [2.4.5 Commuincation(통신)](#245-commuincation통신) :star:      
    - [2.4.6 Protection(보호)](#246-protection보호)   
  - [2.5 System Programs](#25-system-programs)   
  - [2.6 Operating-System Design and Implementation](#26-operating-system-design-and-implementation)   
    - [2.6.1 Design Goals(설계 목적)](#261-design-goals설계-목적)   
    - [2.6.2 Mechanisms and Policies(메카니즘과 정책)](#262-mechanisms-and-policies메카니즘과-정책)   
    - [2.6.3 Implementation(구현)](#263-implementation구현)   
  - [](#)   
    - [](#)   
    - [](#)   
    - [](#)   
    - [](#)   
    - [](#)   
    
    
## 2.System Structures   
### 2.1 Operating-System Services   

  - __User Interface(사용자 인터페이스)__   
    - 거의 모든 OS는 UI(User Interface)가 있다.   
    - UI 유형   
      - __1. Command-Line Interface(CLI)__   
        - 문자 명령을 사용한다.   
      - __2. Batch Interface(일괄 처리 인터페이스)__      
        - 명령과, 명령을 제어하는 지시들이 파일로 입력되며, 이러한 파일이 실행된다.   
      - __3. Graphical User Interface(GUI)__   
        - 입/출력을 가리키고 메뉴에서 고르거나 선택을 행하는 지시 장치를 가진 윈도우 시스템과 텍스트를 입력하는 키보드로 구성된다.   

  - __Program execution(프로그램 수행)__
    - 시스템은 반드시 프로그램을 메모리에 적재해 실행시킬 수 있어야 한다.   
    - 프로그램은 반드시 정상적으로 또는 비정상적으로(에러를 나타내면서) 자신의 실행을 종료시킬 수 있어야 한다.   

  - __I/O operations(입출력 연산)__   
    - 실행되고 있는 프로그램은 파일 또는 입출력 장치와 관련된 입출력을 요구할 수도 있다.   
    - 효율성과 보호를 위해 사용자들은 보통 입출력 장치를 직접 제어할 수 없다. 따라서 운영체제가 입출력 수행을 위한 수단을 제공해야 한다.   


  - __File-system manipulation(파일 시스템 조작)__   
    - 프로그램은 파일과 디렉토리를 읽고 쓸 뿐만 아니라 이름에 의한 생성, 삭제, 지정된 파일 검색, 파일 정보를 열거할 수 있어야 한다.   

  - __Communication(통신)__   
    - 프로세스간 정보를 교환해야할 상황이 있다.      
    - ex) 한 컴퓨터 내에 실행되는 프로세스들 또는 컴퓨터 네트워크로 연결된 다른 컴퓨터 시스템에서 실행되는 프로세스들   
    - __1. 공유 메모리 방법__   
      - 메모리의 공유된 영역에 두 개 이상의 프로세스가 읽고 쓸 수 있다.      
    - __2. 메세지 전달 방법__   
      - 미리 정의된 형식의 정보의 패킷이 OS에 의해 프로세스들 사이에 이동한다.   

  - __Error detection(오류 탐지)__   
    - OS는 항상 모든 가능한 오류를 감지하고 해결할 수 있어야 한다.      
    - __Error 종류__   
      - __CPU와 Memory hardware__   
        - 메모리 에러 또는 파워 문제  
      - __입출력 장치__   
        - 디스크 Parity 에러, 네트워크 연결 실패, 프린터 용지 부족 등   
      - __사용자 프로그램__   
        - 연산 오버플로우, 잘못된 메모리 위치 접근 시도, 너무 큰 CPU 사용 시간 등   
    - 오류에 대한 적절한 조취를 취해 정확하고 일관된 컴퓨터 사용을 보장해야 하지만, 시스템을 중단시켜야만 하는 경우도 있다.   
    - 오류를 야기하는 프로세스를 종료시키거나 프로세스가 오류를 감지하고 수정할 수 있게 프로세스에 에러 코드를 반환시킨다.   
    
  - __OS 효율성을 보장하는 기능__   
       
    - __Resource allocation(자원 할당)__   
      - 다수의 사용자나 다수의 작업이 동시에 실행 될 때 각각에 자원을 할당 해야 한다.   
      - CPU 사이클, 메인 메모리, 파일 저장 장치는 특병한 할당 코드를 가질 수도 있다.      
      - 입출력 장치는 더 일반적인 요청, 해제 코드를 가질 수 있다.   
      - CPU 사용을 가장 잘하는 방법을 결정하는데 있어서, OS는 CPU의 속도, 반드시 실행되어야하는 작업, 이용가능한 레지스터의 수 등을 고려하는 CPU 스케줄링 루틴을 가지고 있다.      

    - __Accounting(회계)__   
      - 어느 사용자가 얼마만큼 그리고 어떤 컴퓨터 자원을 사용하는지 알아야 한다.      
      - 이러한 사용 기록 저장은 회계나 사용량 통계를 축적하는데 사용된다.       
      - 사용량 통계는 컴퓨팅 서비스를 향상시키기 위해 시스템을 변경하기를 바라는 리서처들에게 좋은 수단이 될 수 있다.    
            
    - __Protection and security(보호와 보안)__   
      - 분리된 프로세스가 동시에 실행될 때, 하나의 프로세스가 다른 프로세스를 방해하거나 OS를 방해하지 않아야 한다.      
      - 보호는 시스템 자원에 모든 접근이 통제되도록 보장하는 것과 관련이 있다.    
      - 외부로부터 시스템 보안은 각 사용자가 시스템 자원 접근 권한을 얻기 위해 비밀번호와 같은 수단으로 자신을 시스템에 인증하는 것이다.       
      - 칩입을 감지하기 위해 모든 연결을 기록하고 부적절한 접근 시도로부터 네트워크 아답터를 포함한 외부 입출력 장치들을 보호하는 것까지 확대된다.      
      - 시스템이 안전하고 보호되려면, 예방조치가 시스템을 전체에 도입되어야 한다.       

### 2.2 User and Operating-System Interface   
#### 2.2.1 Command Interpreters(명령어 해석기)   

  - __일부 OS는 커널이 명령어 해석기를 포함한다.__   
  
  - __Window, UNIX와 같은 OS는 명령어 해석기를 사용자가 처음으로 로그인하거나 작업이 시작될 때 실행되는 특수한 프로그램으로 간주한다.__         
  - __Shell__ :star:   
    - __시스템에서 선택할 수 있는 여러 명령어 인터프리터를 말한다.__      
    - UNIX, Linux에서는 사용자가 Boorne shell, C shell, Bourne-Again shell, Korn shell 등을 포함하는 여러 shell 중 하나를 선택할 수 있다.   
    - __대부분 shell은 비슷한 기능들을 제공히고 어느 shell을 시용할지에 대한 사용자의 선택은 개인의 선호에 달려있다.__   
    - 명령어 해석기의 주요 기능은 명시된 다음 사용자 명령어을 얻고 실행하는 것이다.   
    - 이 단계에서 얻어진 대부분의 명령들은 파일을 조작한다.   
      - copy, delete, list, print, create, execute   
      
    - MS-DOS와 UNIX shell은 이러한 방식으로 동작하고 이러한 명령어들은 두 방법에 의해 수행될 수 있다.   
    
    - __1. 명령어 해석기 자체가 명령어를 실행하기 위한 코드를 가지고 있다.__   
      - 파일 삭제 명령어는 적절한 시스템 호출을 만들고 파라미터를 설정하는 코드의 영역으로 명령어 해석기가 이동하게 할 수 있다.   
      - 이러한 경우, 각 명령어가 자신만의 구현 코드를 필요로 하기 때문에 주어질 수 있는 명령어의 수가 명령어 해석기의 크기를 결정한다.   
      
    - __2. 시스템 프로그램을 통해 대부분의 명령어가 수행된다.__   
      - 명령어 해석기는 어떠한 방식에서든 명령어를 이해하지 못한다. 단지, 명령어를 메모리로 올리거나 실행될 파일을 확인하는데 사용한다.   
      - 파일 삭제를 위한 UNIX 명령어는 `rm`이라 불리는 파일을 검색하고 그 파일을 메모리로 적재하고 파라미터 `file.txt`를 가지고 실행한다.   
      - rm 명령어와 관련된 기능은 rm 파일에 있는 코드에 의해 완벽하게 정의되어 있다.   
      - 이러한 방식으로 프로그래머는 적절한 이름을 가진 새로운 파일들을 생성함으로써 시스템에 쉽게 새로운 명령어를 추가할 수 있다.   
      - 명령어 해석기 프로그램은 작을 수 잇지만, 추가되어진 새로운 명령어를 위해서 변화될 필요는 없다.   

#### 2.2.2 Graphical User Interfaces(그래픽 사용자 인터페이스)   

  - __사용자는 마우스 기반 데스크탑에 특성화된 윈도우 메뉴 시스템을 사용한다.__    
    - 프로그램, 파일, 폴더, 시스템 기능을 나타내는 아이콘이 있다.   
    - 1980년대 애플 맥킨토시 발매로 널리 퍼졌으며, 첫 GUI는 1973년 Xerox Alto 컴퓨터에 나왔다.   
    - 모바일 폰, 태블릿에서는 터치 스크린에서 gesture를 함으로써 동작한다.   
    
#### 2.2.3 Choice of Interface(인터페이스 선택)       

  - __개인 선호에 따라 선택된다.__      

  - __컴퓨터 관리하는 시스템 관리자, 시스템의 깊은 지식이 있는 Power 사용자는 CLI를 주로 사용한다.__    
    - CLI는 자신 고유의 프로그램 능력을 가지고 있기 때문에 반복적인 작업을 더 쉽게 만든다.    
    - 빈번한 작업은 명령어 라인의 집합을 필요로하고 이러한 집합은 파일에 기록될 수 있고, 이러한 파일은 프로그램처럼 실행될 수 있다.     
    - 이러한 프로그램은 실행가능한 코드로 컴파일된다기보다는 CLI에 의해 해석된다고 할 수 있다.   
    - 이러한 shell script는 Linux, UNIX 같은 CLI 지향적인 시스템에서 흔히 볼 수 있다.   
    
    
### 2.3 System Call   

  - __시스템 호출은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다.__   
    - 시스템 호출은 일반적으로 C, C++ 등과 같은 언어로 작성된 루틴 형태로 제공 된다.    
    - 하지만, 하드웨어에 직접 접근해야 하는 작업 등의 특정 ROW LEVEL 작업은 어셈블리 명령을 사용하여 작성되어야 한다.   
    
  - __시스템 호출이 사용되는 방식의 예__   
    - 한 파일로부터 데이터를 읽고 그것들을 다른 파일에 복사하는 프로그램 작성 시       
      - 프로그램이 필요할 첫 입력은 두 파일의 이름의 이름이다. 입력 파일, 출력 파일   
      - 이러한 이름들은 OS 설계에 따라 많은 방식에서 정해질 수 있다.   
      - 프로그램이 사용자에게 이름을 요청하는 방식   
        - 1. 인터렉티브 시스템에서 이러한 요청 방식은 연속적인 시스템 호출이 필요하다.   
          - 먼저 화면에 즉각적인 메세지를 작성하기위한 시스템 호출, 그 다음 두 파일을 정의하는 키보드 문자들로부터 읽어오기 위한 시스템 호출   
        - 2. 마우스 기반, 아이콭 기반 시스템에서는 파일 이름의 메뉴가 윈도우에 보인다.   
          - 사용자는 이름을 클릭하기 위해 마우스를 사용할 수 있고, 윈도우는 명시된 이름을 열 수 있다.   
          - 이러한 연속은 많은 입출력 시스템 호출이 필요하다.   
      - 두 파일의 이름을 얻게되면, 프로그램은 반드시 입력 파일을 열고 출력 파일을 생성해야 한다.   
      - 이러한 각 동작은 또다른 시스템 호출이 필요하다.   
      - 각 동작 동안 발생가능한 오류 조건은 추가적인 시스템 호출이 필요하다.   
        - 프로그램이 입력 파일을 열려고 할 때, 해당 이름의 파일이 없거나 접근이 불가할 수 있다.   
          - 콘솔(시스템 호출)에 메세지를 출력하고 비정상적인 종료(시스템 호출)을 한다.   
        - 출력 파일을 생성할 때, 같은 이름을 가진 출력 파일이 있을 수 있다.   
          - 프로그램을 중단(시스템 호출)시키거나 존재하는 파일을 삭제(시스템 호출)하고 새로운 파일 생성(시스템 호출)해야한다.   
          - 인터렉티브 시스템에서는 사용자에게 프로그램을 중단시킬건지 존재하는 파일을 교체할 것인지 물어보는 방법도 있다.   
      - 두 파일이 모두 준비되면, 입력 파일로부터 읽고(시스템 호출) 출력 파일에 쓰는(시스템 콜) 작업을 한다.   
      - 각 읽기와 쓰기는 반드시 발생가능한 에러 조건 관련한 상태 정보를 반환해야 한다.   
      - 입력에서는 파일의 끝에 도달했거나 읽기에서 하드웨어 실패(parity 에러)같은 것을 발견할 수 있고, 출력에서는 출력 장치에 따른 다양한 에러(디스크 공간 부족 등)를 마주할 수 있다.   
      - 모든 파일이 복사된 후, 프로그램은 두 파일을 종료(시스템 호출)하고 윈도우나 콘솔에 메세지를 작성(시스템 호출)하고 마지막으로 정상적으로 종료(시스템 호출)시킨다.   
    
  - __간단한 프로그램이 OS를 많이 사용하게 만들수도 있다.__   
    - 시스템은 초당 수천 개의 시스템 호출을 실행한다.      
    - 대다수 프로그래머는 이러한 세부 사항을 보지 못한다.
    - 대부분의 응용 개발자들은 응용 프로그래밍 인터페이스(Application Programming Interface, API)에 따라 프로그램을 설계한다.   
    - API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다.    
    - __응용 프로그래머가 이용하는 가장 일반적인 API 3가지__   
      - Window 시스템을 위한 Window API    
      - POSIX 기반 시스템(Linux, Mac OS X, UNIX)을 위한 POSIX API   
      - Java 가상 머신에서 실행되는 프로그램을 위한 Java API   
    - Linux, UNIX에서 C언어로 쓰여진 프로그램을 위한 라이브러리는 `libc`다.   
    - 각 OS는 각 시스템 콜을 위한 자신 고유의 이름을 가진다.   
    
  - __응용 프로그래머가 시스템 호출을 사용하는 것보다 API에 따라 프로그래밍하는 것을 선호하는 이유__   
    - __프로그램 호환성__  
      - API에 따라 프로그램을 설계하는 응용 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서나 컴파일되고 실행되기 때문이다.   
      
  - __대부분 프로그래밍 언어에서 run-time 지원 시스템은 OS에 의해 이용가능하게 만들어진 시스템 호출에 연결을 하는 시스템 호출 인터페이스를 제공한다.__   
    - API에서 함수 호출을 막고, OS내에 있는 필요한 시스템 호출을 일으킨다.       
    - 각 시스템 호출과 연관된 숫자가 있고, 시스템 호출 인터페이스는 이러한 숫자들에 따른 색인 테이블을 가지고 있다.   
    - 시스템 호출 인터페이스는 OS커널에서 예정된 시스템 호출을 일으키고 시스템 호출의 상태와 반환 값을 반환한다.   
    - 호출자는 어떻게 시스템 호출이 구현되거나 동작하는 동안 무엇을 하는지 알 필요가 없으며, 오직 API를 따르고 OS가 시스템 호출의 결과로 무엇을 할 지를 이해하기만 하면 된다.   
    - OS 인터페이스의 세부 사항의 대부분은 API에 의해 프로그래머에게 비밀이고, run-time 지원 라이브러리에 의해 관리된다.    
        
  - __OS에 매개변수를 전달하는 3가지 방식__        
    __1. 레지스터에 매개변수를 전달__   
    __2. 레지스터보다 더 많은 매개변수가 있을 경우, 매개변수가 메모리 안 블록 또는 테이블에 저장되고, 블록의 주소를 레지스터의 매개변수로 전달__   
    __3. 스택__   
      - 매개변수는 프로그램에 의해 스택에 push되고 OS에 의해 pop된다.   
      - 일부 OS에서는 전달되는 매개변수의 수나 길이의 제한이 없는 블록 또는 스택 방법을 선호한다.   
    
### 2.4 Types of System Calls   

  - __시스템 호출을 대략 6가지 주요 범주로 그룹될 수 있다.__   
    __1. Process Control(프로세스 제어)__   
    __2. File Manipulation(파일 조작)__   
    __3. Device Management(장치 관리)__   
    __4. Information Maintenance(정보 유지)__   
    __5. Commuication(통신)__   
    __6. Protection(보호)__   

#### 2.4.1 Process Control(프로세스 제어)   

  - __실행 중인 프로그램은 수행을 정상(end()) 또는 비정상(abort())으로 끝낼 수 있어야 한다.__   
    - 현재 실행되는 프로그램을 비정상적으로 종료시키기위한 시스템 호출이 만들어 지거나, 프로그램에 문제가 발생해 오류 트랩(trap)을 유발할 경우 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다.   
    - 덤프는 디스크에 기록되고 문제의 원인을 밝혀내기 위해 디버거(Bebugger)에 의해 검사될 수 있다.   
    - 이러한 비정상적 또는 정상적 상황에서, OS는 반드시 명령어 해석기로 제어를 전달해야 한다. 명령어 해석기는 이어 다음 명령을 읽는다.   
    - 인터렉티브 시스템에서 명령어 해석기는 쉽게 다음 명령어를 계속한다.   
      - 시용자가 모든 에러에 반응하기 위해 적절한 명령을 발행할 수 있는 것을 가정한다.   
    - GUI 시스템에서 팝업 윈도우는 사용자에게 에러를 알려주고 지시를 요청한다.   
    - Batch 시스템에서 명령어 해석기는 모든 작업을 종료하고 다음 명령을 계속한다.   
    
  - __일부 시스템은 에러 발생 상황에 특별한 복구 동작을 할 수 있다.__   
    - 프로그램이 입력에서 에러를 발견하고 비정상적으로 종료시키기를 원할 경우, 에러 수준을 정의하기를 원할수도 있다.     
    - 높은 수준의 에러 매개변수로 많은 심각한 에러를 나타낼 수 있다.   
    - 명령어 해석기 또는 프로그램은 자동적으로 다음 행동을 결정하기 위해 이러한 에러 수준을 사용할 수 있다.   
    
  - __프로세스나 하나의 프로그램을 실행시키는 작업은 다른 프로그램을 load()하고 execute()하기를 원할 수 있다.__   
    - 이러한 특징은 명령어 해석기가 직접적인 사용자 명령에 의한 프로그램을 실행시킬 수 있게 한다.   
      - ex) 마우스 클릭, batch 명령 등   
    - __적재된 프로그램이 종료될 때 제어가 어디로 가는지 중요하다.__     
      __1. 새로운 프로그램이 종료될 때, 기존에 사용되는 프로그램으로 제어가 넘어갈 때__   
        - 기존에 사용되는 프로그램의 메모리 이미지를 저장해야만 한다.   
        - 하나의 프로그램이 다른 프로그램을 호출하기 위한 메카니즘이 생성되어 있는 것이다.   
      __2. 두 프로그램이 병행으로 실행될 경우__   
        - 새로운 작업 또는 프로세스가 멀티프로그램되게 생성되었다.   
      __3. 새로운 프로세스나 작업을 생성하거나, 프로세스나 작업의 집합을 생성할 경우__   
        - 작업의 우선순위, 최대 허용 실행 시간 등 작업 또는 프로세스의 특성을 재설정하고 알아내는 능력이 필요하다.   
      __4. 프로세스나 작업이 부정확하거나 더 이상 필요없을 경우__   
        - 해당 프로세스 또는 작업 종료   
      __5. 작업이나 프로세스가 실행 종료되기를 기다릴 경우__    
        - 특정 시간만큼 기다리기를 원할수도 있다.   
        - 일반적으로, 특정 이벤트를 기다릴 것이다.   
        - 이벤트가 발생시 신호를 보내야 한다.   
        
  - __흔히, 두 개 이상의 프로세스가 데이터를 공유할 수 있다.__   
    - 공유된 데이터의 무결성을 보장하기 위해 OS는 프로세스가 공유하는 데이터를 lock하는 시스템 호출을 제공한다.   
      - ex) acquire_lock(), release_lock()   
    - 다른 프로세스는 lock이 해제될 때까지 해당 데이터에 접근이 불가하다.   
    
  - __Single-tasking 시스템__   
    - MS-DOS OS가 대표적인 예      
    - 컴퓨터가 시작될 때, 발동되는 명령어 해석기가 있다.   
    - 단일 작업이기 때문에 프로그램을 실행하고, 새로운 프로세스를 생성하지 않는 간단한 방법 사용한다.   
    - __과정__   
      __1. 가능한한 최대의 메모리를 프로그램에 주기 위해 메모리 대부분을 쓰면서 프로그램을 메모리 적재한다.__   
      __2. 명령어 포인터를 프로그램의 첫 번째 명령어로 설정한다.__   
      __3. 프로그램이 실행되면 에러가 발생하거나, 프로그램은 종료시키기 위한 시스템 호출을 실행한다.__   
        - 에러 코드는 나중에 사용하기 위해 시스템 메모리에 저장된다.   
        - 위의 행동을 따르면서, overwrite되지 않은 명령어 해석기의 작은 부분은 실행을 재개한다.  
        - 첫 작업은 디스크로부터 명령어 해석기의 나머지 부분을 재적재하는 것이다.   
        - 명령어 해석기는 다음 프로그램이나 사용자가 이전 에러코드를 사용가능하게 해준다.   
  
  - __Multi-tasking 시스템__   
    - FreeBSD(Berkeley UNIX에서 파생)가 대표적인 예     
    - 사용자가 시스템에 로그인 할 때, 사용자가 선택한 shell이 실행된다.   
    - 사용자가 요청한 프로그램을 실행하고 명령을 허용하는데 있어 MS-DOS shell과 비슷하다.   
    - 멀티태스킹 시스템이기 때문에, 명령어 해석기는 다른 프로그램이 실행되는 동안 계속 실행된다.   
    - 새로운 프로세스를 시작하기 위해서, shell은 fork() 시스템 호출을 실행한다.   
    - 선택된 프로그램은 exec() 시스템 호출을 통해 메모리로 적재되고 프로그램이 실행된다.   
    - 명령어가 발행되는 방식에 따라, shell은 프로세스가 끝나길 기다리거나 백그라운드에서 프로세스를 실행시킨다.   
      - 백그라운드에서 프로세스를 실행시킬 경우   
        - shell은 즉시 다른 명령어를 요청한다.   
        - 프로세스가 백그라운드에서 실행되고 있을 때, shell이 자원을 사용하고 있으므로, 키보드로부터 직접적인 입력을 받을 수 있다.   
        - 입출력은 GUI 인터페이스를 통하거나, 파일을 통해 행해진다.   
        - 사용자는 shell에게 다른 프로그램을 실행시키는 것, 실행되는 프로세스의 진행상태를 지켜보는 것, 프로그램의 우선순위를 변경하는 것 등을 자유롭게 물어볼 수 있다.   
        - 프로세스가 완료되면, 0이 아닌 에러 코드나 0의 프로세스 상태 코드를 반환하면서, 종료를 하기 위해 exit() 시스템 호출을 실행한다.   
        - 이러한 상태나 에러 코드는 shell이나 다른 프로그램에서 이용가능하다.   
        
#### 2.4.2 File Management(파일 관리)   

  - __craete(), delete()을 통해 파일 생성, 삭제할 수 있어야 한다.__   
    - 파일 이름이나, 파일 속성의 일부를 요구한다.   
    - 파일이 생성되면, open()을 사용하여 파일을 열고, read(), write(), reposition()을 통해 읽기, 쓰기, 위치 변경을 할 수 있다.   
    - 파일을 더 이상 사용하지 않을 경우, close()를 사용하여 파일을 닫는다.   
  
  - __파일 시스템이 파일을 조직하기 위해 디렉토리 구조를 가진다면 우리는 디렉토리에 대해서도 파일과 같은 연산 집합이 필요 하다.__   
    - 추가로 파일이나 디렉토리에 대해 여러 속성의 값을 결정할 수 있어야 하고 필요에 따라 재설정 할 수 있어야 한다.  
      - get_file_attribute(), set_file_attribute()   
    - 파일 속성은 파일 이름, 파일 유형, 보호코드 등 정보를 포함한다.   
    - 일부 OS는 move(), copy() 등 더 많은 시스템 호출을 제공하기도 한다.   

#### 2.4.3 Device Management(장치 관리)   

  - __OS에 의해 통제되는 다양한 자원(메모리, 디스크 장치, 파일 접근 등)은 장치로 간주될 수 있다.__   
    - 일부는 물리적 장치(디스크 드라이브), 일부는 가상적 또는 추상적 장치(파일)      
    - 다수의 사용자가 있는 시스템인 경우, 독점적인 장치 사용을 보장받기 위해 우선 그 장치를 요청(request()) 해야 한다.
    - 장치의 사용 후, release()해줘야 한다.   
      - 파일의 open(), close()와 비슷한 개념이다.   
    - 일부 OS는 장치에 관리되지 않는 접근을 허용한다.   
      - 이러한 경우 deadlock과 장치 경합에 대한 위험성이 존재할 수 있다.   
    - 장치가 요청되고 할당되었으면, read(), write(), reposition() 할 수 있다.   
    - 입출력 장치와 파일 사이의 유사성이 너무 커서, UNIX를 포함한 많은 OS는 두 개를 파일-장치 구조로 합친다.   
      - 이 경우, 시스템 호출의 집합이 파일과 장치 둘 다에서 사용된다.   
      - 입출력 장치는 특정한 파일 이름, 디렉토리 위치, 또는 파일 특성에 의해 식별된다.   
    - 사용자 인터페이스는 근본적인 시스템 호출이 다름에도 불구하고 장치와 파일들을 비슷하게 보이게 만들 수 있다.    
    
#### 2.4.4 Information Maintenance(정보 유지)   

  - __많은 시스템 호출은 OS와 사용자 프로그래밍 사이에서 정보를 전달하는 목적을 위해 존재한다.__      
    - 대부분의 시스템은 현재 time()과 date()를 반환하는 시스템 호출을 가지고 있다.   
      - 다른 시스템 호출은 OS 버전, 디스크 또는 메모리 빈 공간 크기, 현재 사용자의 수 등 시스템에 관한 정보를 반환한다.      

  - __시스템 호출의 집합은 프로그램 디버깅하는데 도움이 된다.__   
    - 많은 시스템은 메모리를 dump() 하기 위한 시스템 호출을 가진다.   
    - 프로그램은 실행되는 각각의 시스템 호출 목록을 추적한다.   
    - microprocessor는 매 명령어 실행 후, CPU에 의해 실행되는 trap인 'single step'으로 알려진 CPU 모드를 지원한다.  
      - 이러한 trap은 디버거에 의해 발견된다.   
    - 많은 OS는 프로그램이 특정 위치나 위치들의 집합에서 실행하는 시간의 양을 나타내기 위해서 프로그램의 time profile을 제공한다.   
      - time profile은 추적 기능 또는 규칙적인 타이머 인터럽트가 필요하다.   
      - 타이머 인터럽트가 발생할 때마다, Program counter 값이 기록된다.   
      - 충분히 잦은 타이머 인터럽트로, 프로그램의 다양한 부분에서 소비된 시간의 통계적인 그림을 얻을 수 있다.   
      - OS는 모든 프로세스에 대한 정보를 유지하고, 시스템 호출을 정보에 접근하기 위해 사용된다.   
      - 일반적으로 프로세스 정보를 재설정을 위해 시스템 호출 get_process_attributes() + set_process_attributes()을 사용한다.   

#### 2.4.5 Commuincation(통신)   

  - __프로세스간 통신 모델 2가지__ :star:    
    __1. Message-passing model(메세지 전달 방식)__   
      - __정보를 전달하기 위해 프로세스간 메세지를 교환한다.__   
      - __메세지는 공동 메일 박스를 통해 간접적 또는 직접적으로 프로세스 사이에 교환된다.__   
      - 통신하기전에 반드시 연결이 열려있어야 한다.   
      - 다른 통신자의 이름을 반드시 알고 있어야 한다.   
        - __통신 네트워크에 의해 연결된 다른 컴퓨터의 프로세스 또는 같은 시스템에서의 다른 프로세스__   
      - 네트워크에서 각 컴퓨터는 'host name'을 가진다.   
        - host는 IP 주소와 같은 네트워크 식별자를 가지고 있다.   
        - process는 'process name'을 가지고 있고 이러한 name은 OS가 해당 프로세스를 참조할 수 있게 식별자로 번역된다.   
          - get_hostid(), get_processid()는 이러한 번역을 한다.   
        - 식별자는 통신 모델에 따라 open_connection()과 close_connection() 시스템 호출 또는 파일 시스템에 의해 제공된 open(), close() 시스템 호출에 전달된다.   
        - 수신 프로세스는 accept_connection() 호출을 통해 통신에 대한 허락을 해야만한다.   
        - 연결을 받아들이는 대부분 프로세스는 특정한 목적을 위해 제공된 시스템 프로그램인 daemon이다.   
          - daemon은 wait_for_connection()을 실행시키고 연결이 생성되었을 시 깨어난다.   
        - Client로 알려진 통신의 기원과 Server인 daemon은 read_message(), write_message() 시스템 호출을 사용하여 메세지를 교환한다.   
        - Close_connection()은 통신을 종료한다.   
        
    __2. Shared-memory model(공유 메모리 방식)__    
    
      - __프로세스는 다른 프로세스의 소유된 메모리 부분에 접근 권한을 위해 shared_memory_attach(), shared_memory_create()을 사용한다.__      
        - __보통 OS는 하나의 프로세스가 다른 프로세스의 메모리 접근을 막으려고 한다.__     
        - __공유 메모리는 이러한 제한을 제거히기 위해, 두 개 이상의 프로세스 동의를 요구한다.__     
        - __공유 영역에서 데이터를 쓰고 읽음으로써 정보를 교환할 수 있다.__   
        - 데이터 형식은 프로세스에 의해 결정되고 OS 통제 아래 있지 않다.   
        - __프로세스가 동시에 같은 위치에 쓰기 작업을 하지 않아야 하는 것을 보장해야 한다.__   
        
    - __대부분 OS는 두 가지 모델을 모두 구현한다.__   
      - 메세지 전달 방식은 충돌을 방지할 필요가 없기 때문에 소량의 데이터를 교환하는데 유용하다.      
      - 공유 메모리는 하나의 컴퓨터 내에서 발생하여 메모리 전송 속도로 수행되기 때문에, 통신이 편리하고, 최대 속도를 가능하게 하게 하지만 메모리를 공유하는 프로세스 사이에서 동기화와 보호 영역에 대한 문제점을 가지고 있다.   
      

#### 2.4.6 Protection(보호)   

  - __보호는 컴퓨터에 의해 제공된 자원에 대한 접근을 통제하기 위한 메카니즘을 제공한다.__   
    - 보호는 다수의 사용자를 가진 멀티 프로그램 컴퓨터 시스템과만 관련이 있었지만, 인터넷과 네트워크의 도입으로 서버부터 모바일 기기까지의 모든 컴퓨터 시스템은 반드시 보호를 고려하게 됐다.      
    - 보호를 제공하는 시스템 호출은 파일과 디스크 같은 자원의 설정 허가를 변경하는 get_permission(), set_permission()을 포함한다.    
    - allow_user()와 deny_user()는 특정 사용자가 특정 자원에 대한 접근을 허가 또는 거절한다.   

### 2.5 System Programs      

  - __시스템 유틸리티로 알려진 시스템 프로그램은 프로그램 실행과 개발을 위한 편리한 환경을 제공한다.__   
  
  - __시스템 프로그램 카테고리__   
    - __File management(파일 관리)__   
      - 시스템 프로그램은 일반적으로 파일, 폴더를 조작한다.      
      - create, delete, copy, rename, print, dump, list       

    - __Status information(상태 정보)__   
      - 일부 프로그램은 사용자의 수, 디스크 또는 메모리 사용가능 공간, 시간, 날짜 등 상태 정보를 시스템에 물어본다.     
      - 다른 일부 프로그램은 더 복잡한 디버깅, 로깅, 수행 디테일 정보를 물어본다.   
      - 전형적으로 터미널, 다른 출력 장치, 파일에 결과를 출력하거나 윈도우 GUI에 보여준다.   
      - 일부 시스템은 환경설정 정보를 저장하고 복구하는데 사용되는 registry를 지원한다.   

    - __File modification(파일 수정)__   
      - 다수의 텍스트 편집기는 디스크나 다른 저장 장치에 저장된 파일 내용 수정 또는 생성을 할 수 있다.      
      - 텍스트의 변경을 수행하거나 파일의 내용을 검색하는 특수한 명령어도 있다.      

    - __Programming-language support(프로그래밍 언어 지원)__   
      - 컴파일러, 어셈블러, 디버거, 인터프리터는 OS내에 제공되거나 개별 다운로드하여 사용가능하다.     

    - __Program loading and execution(프로그램 적재와 실행)__   
      - 프로그램이 어셈블되거나 컴파일되면, 실행되기 위해 반드시 메모리로 적재되야 한다.     
      - 시스템은 absolute loader, relocation loader, linkage editor, overlay loader를 제공한다.   
      - 고수준 언어 또는 기계언어를 위한 디버깅 시스템도 필요하다.   

    - __Communications(통신)__   
      - 프로세스, 사용자, 컴퓨터 시스템 사이에 가상 연결을 위한 메카니즘도 제공한다.      
      - 사용자가 다른 사용자의 화면에 메세지를 보내기, 웹 페이지 탐색, 이메일 전송, 원격 접속, 파일 전송 등을 가능하게 한다.      

    - __Backgroud Service(백그라운드 서비스)__ :star:      
      - 모든 일반용 시스템은 부트 시간에 특정 시스템 프로그램 프로세스를 실행하기 위한 수단을 가지고 있다.      
      - 일부 프로세스는 작업이 완료된 후 종료하지만, 다른 일부는 시스템이 중단될 때까지 작동한다.   
      - __계속해서 실행되는 시스템 프로그램 프로세스는 Service, Subsystem 또는 Daemon이라고 알려져 있다.__   
        - ex) 네트워크 데몬   
          - 시스템은 정확한 프로세스에 연결 요청을 하기 위해 네트워크 연결을 듣는 서비스가 필요했다.   
        - ex) 프로세스 스케줄러, 시스템 오류 감시 서비스 등   
      - 시스템 프로그램과 마찬가지로 대부분의 OS는 공동 작업 수행 또는 공동 문제 해결하는데 유용한 프로그램을 제공한다.   
        - ex) 웹 브라우저, 워드 프로세서, 게임, 컴파일러, 데이터 베이스 시스템, 통계 분석 패키지 같은 app   
      - 대다수 사용자에 의해 보여지는 OS의 view는 시스템 호출보다는 시스템 프로그램과 app에 의해 정의된다.   
        - ex) MAC OS X   
          - 사용자는 mouse-and-window interface인 GUI만 본다.   
          - 다른 윈도우에서는 사용자가 UNIX shell을 가질 수도 있다.   
          - 둘 다 같은 시스템 호출 집합을 사용하지만, 다르게 보이고 다른 방식으로 동작한다.   
        - ex) dual-booting from MAC OS X to Window   
          - 같은 하드웨어에서 같은 사용자가 완전히 다른 두 개의 인터페이스를 가지고 같은 물리적 자원을 사용하는 app의 두 집합을 가진다.   
            - 하나의 사용자가 동시적으로 또는 순차적으로 다수의 사용자 인터페이스에 노출된다.   
      
### 2.6 Operating-System Design and Implementation   
#### 2.6.1 Design Goals(설계 목적)   

  - __고수준에서 시스템의 설계는 하드웨어와 시스템의 종류에 영향을 받는다.__   
    - 일괄 처리, 시간 분할, 단일 사용자, 다수 사용자, 분산, 실시간, 일반       
    
  - __사용자 목적__   
    - 사용하기 편하고, 배우기 쉽고, 사용하기 쉽고, 의존할 수 있고 안전하고 빨라야한다.      
    - 이것을 보장하기 위한 일반적인 해결책은 없고 시스템 설계에 도움이 되지는 않는다.   
    - 시스템 설계, 생성, 유지, 동작하는 사람들에게는 시스템이 설계, 구현, 유지하기 쉽고, 효율적이고 에러가 없고, 의존할 수 있고, 유연해야 한다.       
    
#### 2.6.2 Mechanisms and Policies(메카니즘과 정책)    

  - __Mechanism__   
    - how to do something             
      - ex) 타이머 구조는 CPU 보호를 보장하기 위한 메카니즘이다.              
      
  - __Policy__   
    - what will be done        
      - ex) 특정 사용자를 위해 타이머를 얼마동안 세팅할지 결정    

  - __Policy와 Mechanism의 분리는 유연성에 있어 중요하다.__   
    - policy는 시간이 흐르면서 또는 공간을 가로지르면서 변화한다.   
      - 가장 최악의 경우는 policy에서 각각의 변화가 근본적인 mechanim에서의 변화를 요청할 때이다.   
    - policy의 변화에 둔감한 mechanism이 이상적이다.   
    - policy 결정은 모든 자원 할당에 있어 중요하다.   
      - 자원을 할당할지 결정하는 것이 필수적일 때마다 policy 결정이 확인되어야만 한다.   
    - 문제가 what 보다 how일 경우 mechanism이 반드시 확인되어야 한다.   

      
#### 2.6.3 Implementation(구현)   

  - __어떻게 구현할지에 대한 일반적인 명세문을 만드는 것은 어렵다.__   
  
  - __초기 OS는 어셈블리 언어로 쓰여졌고 현재 대부분의 OS는 C, C++ 같은 고수준 언어로 쓰여진다.__   
    - OS는 하나 이상의 언어로 쓰여질 수 있다.   
    - 고수준 루틴은 C로 되어 있을 수 있고, 시스템 프로그램은 C 또는 C++, interpreted scripting 언어인 PERL 또는 Python 또는 Shell script로 되어 있을 수 있다.   
    - Linux는 이러한 모든 언어에서 쓰여진 프로그램을 포함한다.   
    
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -    
    -    
  - ____   
    -   
    -   
### 2.
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -   
    -   
    
  - ____   
    -    
    -    
  - ____   
    -   
    -   
