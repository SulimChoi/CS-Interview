# :bookmark_tabs: Operating System Concepts 9th edition      
## 7장 Deadlocks      
__중요하다고 생각되는 목차에는 :star: 표시해놓았습니다.__   
__:star:되어 있는 목차를 클릭하시면 클릭하신 목차의 내용이 있는 페이지로 넘어가며__   
__해당 페이지 내에 있는 중요 개념 옆에 :star: 표시해놓았습니다.__   

__혹시 잘못된 내용이 있거나 보완해야할 점이 있으면 `issue` 해주시거나 알려주시면 감사하겠습니다.:bow:__   

- [7. Deadlocks](#7-deadlocks)   
  - [7.1 System Model](#71-system-model)   
  - [7.2 Deadlock Characterization(데드락 특징)](#72-deadlock-characterization데드락-특징)   
    - [7.2.1 Necessary Conditions(필수 조건)](#721-necessary-conditions필수-조건) :star:   
    - [7.2.2 Resource-Allocation Graph(자원-할당 그래프)](#722-resource-allocation-graph자원-할당-그래프)   
  - [7.3 Methods for Handling Deadlocks](#73-methods-for-handling-deadlocks)   
  - [7.4 Deadlock Prevention](#74-deadlock-prevention)   
    - [7.4.1 Mutual Exclusion(상호 배제)](#741-mutual-exclusion상호-배제) :star:   
    - [7.4.2 Hold and Wait(점유 및 대기)](#742-hold-and-wait점유-및-대기) :star:   
    - [7.4.3 No Preemption(비선점)](#743-no-preemption비선점) :star:   
    - [7.4.4 Circular Wait(순환 대기)](#744-circular-wait순환-대기) :star:   
  - [7.5 Deadlock Avoidance](#75-deadlock-avoidance) :star:         
    - [7.5.1 Safe State](#751-safe-state)   
    - [7.5.2 Resource-Allocation-Graph Algorithm(자원-할당-그래프 알고리즘)](#752-resource-allocation-graph-algorithm자원-할당-그래프-알고리즘)   
    - [7.5.3 Banker's Algorithm(은행원 알고리즘)](#753-bankers-algorithm은행원-알고리즘)   
  - [7.6 Deadlock Detection](#76-deadlock-detection)   
    - [7.6.1 Single Instance of Each Resource Type(각 자원 타입의 단일 인스턴스)](#761-single-instance-of-each-resource-type각-자원-타입의-단일-인스턴스)   
    - [7.6.2 Several Instances of Each Resource Type(각 자원 타입의 다수 인스턴스)](#762-several-instances-of-each-resource-type각-자원-타입의-다수-인스턴스)   
    - [7.6.3 Detection-Algorithm Usage(탐지-알고리즘 사용)](#763-detection-algorithm-usage탐지-알고리즘-사용)   
  - [7.7 Recovery from Deadlock](#77-recovery-from-deadlock)   
    - [7.7.1 Process Termination(프로세스 종료)](#771-process-termination프로세스-종료)   
    - [7.7.2 Resource Preemption(자원 선점)](#772-resource-preemption자원-선점)     
  
## 7. Deadlocks   
### 7.1 System Model   

  - __프로세스는 반드시 자원을 요청하고 사용 후 반환해야한다.__   
    - 요청된 자원의 수는 시스템에서 이용가능한 자원의 총 수를 초과하면 안된다.   
  
  - __프로세스가 자원을 사용하는 과정__   
    - __1. 요청(Request)__   
      - 프로세스는 자원을 요청한다.   
        - 요청하는 자원이 다른 프로세스에 의해 사용되고 있을 경우, 요청하는 프로세스는 자원을 얻을 때까지 기다려야 한다.   
        
    - __2. 사용(Use)__   
      - 프로세스는 자원을 사용할 수 있다.   
    
    - __3. 해제(Release)__   
      - 프로세스는 자원을 해제한다.   
      
  - __프로세스 또는 스레드가 커널에 의해 관리되는 자원을 사용하는데 있어서 OS가 프로세스가 해당 자원에 대한 요청과 자원이 할당되었는지를 확실하게 확인해줘야 한다.__   
    - 시스템 테이블은 각 자원이 할당되거나 이용가능한지를 기록한다.   
      - 각 자원이 할당되었을 경우, 테이블은 자원이 어느 프로세스에 할당되었는지를 기록한다.   
      - 요청한 자원이 현재 다른 프로세스에게 할당되어 있을 경우, 해당 자원에 대한 프로세스 대기 큐에 추가 될 수 있다.   
  
  - __deadlock을 일으킬 수 있는 자원들에는 물리적 자원(프린터, 테이프 드라이브, 메모리 공간, CPU 사이클) 또는 논리적 자원(세마포어, mutex lock, file)이 있다.__   
  
  
### 7.2 Deadlock Characterization(데드락 특징)   
#### 7.2.1 Necessary Conditions(필수 조건)   

  - __Deadlock이 발생하는데 필요한 4가지 조건__ :star:   
    - __1. 상호 배제(Mutual exclusion)__    
      - __최소한 하나의 자원이 반드시 공유될 수 없는 상태로 점유되어야 한다.__   
        - 한 번에 하나의 프로세스만 해당 자원을 사용할 수 있다.    
        - 다른 프로세스가 해당 자원을 요청하면 해당 자원이 해제될 때까지 기다려야한다.   
      
    - __2. 점유 및 대기(Hold and wait)__   
      - __프로세스는 적어도 하나의 자원을 점유한 채 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 기다리고 있어야 한다.__   
      
    - __3. 비선점(No preemption)__    
      - __자원들을 선점할 수 없어야 한다.__    
      - 자원이 강제적으로 해제될 수 없고 점유하고 있는 프로세스가 작업을 종료한 후 그 프로세스에 의해 자발적으로만 해제될 수 있다.   
      
    - __4. 순환 대기(Circular wait)__   
      - __기다리는 프로세스가 서로 자원을 얻기 위해 꼬리를 물고 있어야한다.__   
        - 대기하고 있는 프로세스의 집합 `{P0, P1, …, Pn}`에서 `P0`는 `P1`이 점유한 자원을 대기하고 `P1`은 `P2`가 점유한 자원을 대기하고, `Pn-1`은 `Pn`이 점유한 자원을 대기하며 `Pn`은 `P0`가 점유한 자원을 대기한다.      
        
#### 7.2.2 Resource-Allocation Graph(자원-할당 그래프)   

  - __Deadlock은 시스템 자원-할당 그래프로 불리는 방향 그래프로 더 정확하게 묘사될 수 있다.__   
    - 정점 `V`, 간선 `E`로 구성된다.   
    - `P` : 프로세스, `R` : 자원    
    - `P -> R` : 요청 간선   
    - `R -> P` : 할당 간선   
    - __그래프에서 사이클이 있다면 Deadlock이 발생할수도 있다.__   
      - 사이클은 Deadlock의 발생에 대한 필요 충분 조건이다.   
      - Deadlock이 발생한다면 사이클에 관련된 모든 프로세스는 deadlock 상태가 된다.   
    
    <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/7_1_ResourceAllocation.jpg" height = 300px title="7_1_ResourceAllocation" alt="7_1_ResourceAllocation"></img><br><strong>7.1 자원-할당 그래프</strong> </p>
  
    - `P1`이 `R2`의 자원 하나를 점유하고, `R1`의 자원 하나를 기다리고 있다.   
    - `P2`가 `R1`과 `R2`의 자원 하나를 점유하고, `R3`의 자원 하나를 기다리고 있다.   
    - `P3`가 `R3`의 자원을 점유하고 있다.   
    - __`P3`가 `R3`의 사용을 마치고 해제하면 `P2`가 `R3`를 할당받고 `R1`의 사용을 마치고 해제하면, `P1`이 `R1`을 할당받아 사용할 수 있으므로 deadlock이 발생하지 않는다.__   
    
    <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/7_2_ResourceAllocationWithDeadlock.jpg" height = 300px title="7_2_ResourceAllocationWithDeadlock" alt="7_2_ResourceAllocationWithDeadlock"></img><br><strong>7.2 교착 상태의 자원-할당 그래프</strong> </p> 
    
    - 7.1 그림에서 `P3 -> R2`를 추가한 그래프   
    - __최소 2개의 사이클이 존재한다.__    
      - `P1 -> R1 -> P2 -> R3 -> P3 -> R2 -> P1`    
      - `P2 -> R3 -> P3 -> R2 -> P2`   
      - __`P1, P2, P3`은 deadlock 상태가 된다.__   
      - `P2`는 P3가 점유하고 있는 `R3`를 기다리고 있고, `P3`는 `P1` 또는 `P2`가 `R2`를 해제하기를 기다린다.   
      - `P1`은 `P2`가 `R1`을 해제하기를 기다린다.   
      
    <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/7_3_CycleNoDeadlock.jpg" height = 300px title="7_3_CycleNoDeadlock" alt="7_3_CycleNoDeadlock"></img><br><strong>7.3 사이클이 존재하지만 교착 상태가 발생하지 않는 자원-할당 그래프</strong> </p> 
    
    - __사이클이 존재하지만 Deadlock이 발생하지 않는다.__   
      - `P1 -> R1 -> P3 -> R2 -> P1`    
      - `P4`가 `R2`를 해제하게 되면 `P3`가 `R2`를 할당받으면서 사이클이 없어지게 된다.   
      
  - __사이클이 없다면 Deadloc이 발생하지 않고, 사이클이 있다면 Deadlock이 발생할수도 있고 없을수도 있다.__   
  
### 7.3 Methods for Handling Deadlocks   

  - __교착 상태를 해결하는 3가지 방법__   
    - __1. 교착 상태 예방(Deadlock Prevention)__   
      - __시스템이 교착 상태가 되지 않도록 보장하기 위해 교착 상태를 예방하거나 회피하는 프로토콜 사용__   
    - __2. 교착 상태 탐지(Deadlock Detection)__   
      - __시스템이 교착 상태가 되게 허용한 다음 감지하여 회복__   
    - __3. 교착 상태 회피 (Deadlock Avoidance)__   
      - __문제를 무시하고 교착 상태가 시스템에서 발생하지 않은 척 한다.__   
    
  - __교착 상태가 발생했는데 탐지하지 못할 경우 프로세스에 점유된 자원들이 실행될 수 없고 더 많은 프로세스가 자원을 요청할수록 더 많은 프로세스가 교착 상태에 빠지기 때문에 시스템의 성능은 줄어들어 결국 시스템은 멈추게되고 수동으로 재시작해야 한다.__   
  
  - __3번의 방법이 가장 많이 사용된다.__   
    - __비용이 중요한 고려사항이고 3번의 방법이 가장 저렴하다.__   
    - 많은 시스템에서 교착 상태는 드물게 발생하기 때문에 다른 방법에 대한 비용을 가치있지 않다.    
    - __다른 상태에서 회복하기 위해 사용하는 방법이 교창 상태를 회복하는데 사용될 수도 있다.__   
      - ex) 시스템이 멈춰있을 경우(교착 상태가 아님)   
        - 가장 우선순위에서 실행되는 실시간 프로세스는 OS에 통제권을 반환하지 않는다.   
        - __이 경우를 위해서 시스템은 반드시 수동 회복 수단을 가져야하는데 이를 교착 상태를 회복하는데 사용할 수 있다.__   
    
### 7.4 Deadlock Prevention   

  - __4가지 발생 조건 중 적어도 하나를 막음으로써 교착 상태를 예방할 수 있다.__   

#### 7.4.1 Mutual Exclusion(상호 배제)       
  
  - __상호 배제 조건은 반드시 지켜져야 한다.__ :star:    
    - 적어도 하나의 자원이 공유될 수 없어야 한다.
    - 공유 자원은 상호 배제 접근을 할 필요가 없고 교착 상태와 연관될 수가 없다.   
      - ex) 읽기 전용 파일   
      
  - __일부 자원은 본질적으로 공유가 불가능하기 때문에 보통 상호 배제 조건을 부정함으로써 교착 상태를 예방할 수 없다.__ :star:   
    - ex) mutex lock은 여러 프로세스에 의해 동시에 공유될 수 없다.   

#### 7.4.2 Hold and Wait(점유 및 대기)         

  - __점유 및 대기 조건이 발생하지 않게 보장하기 위해서는 프로세스가 자원을 요청 할 때 다른 자원들을 점유하지 않을 것을 반드시 보장해야 한다.__ :star:
  
  - __점유 및 대기를 발생하지 않게 하는 두 가지 프로토콜__ :star:   
    - __1. 각 프로세스가 실행하기 전에 자원을 요청하고 할당받아야하는 프로토콜__   
      - 다른 시스템 호출보다 프로세스에 자원을 요청하는 시스템 호출을 선행하는 것을 요구함으로써 이러한 방법을 구현할 수 있다.   
    - __2. 프로세스가 가지고 있는 것이 없을 때만 자원을 요청하는 프로토콜__   
      - 추가적인 자원을 요청하기 전에, 현재 할당된 모든 자원을 해제해야 한다.   
    
    - ex) DVD 드라이브로부터 디스크의 파일로 데이터를 복사하고 파일을 정렬하고 결과를 프린터에 출력하는 프로세스가 있을 경우   
      - 1번 프로토콜은 시작 시에 모든 자원들이 요청되어 점유되어 있어야 한다.(DVD 드라이브, 디스크 파일, 프린터)   
        - 프린터는 마지막에 사용하는데도 불구하고 전체 실행동안 프린터를 점유하고 있게된다.   
      - 2번 프로토콜은 처음에 DVD 드라이브와 디스크 파일을 요청한 뒤 DVD로부터 디스크 파일로 데이터를 복사하고 둘을 해제한다. 그리고 디스크 파일과 프린터를 요청하고 디스크 파일을 프린터로 복사 후 둘을 해제한 뒤 종료한다.   
      
    - __두 프로토콜의 2 가지 단점__   
      - __1. 자원 활용성이 낮을 수 있다.__   
        - 자원이 사용되지 않는 오랜 기간동안 할당되어 있을 수 있다.   
          - ex) 디스크 파일에 데이터가 남아있을 거라고 확신할 수 있을 경우에만 DVD 드라이브와 디스크 파일을 해제할 수 있고 그 다음 디스크 파일과 프린트를 요청할 수 있다.   
            - 그렇지 않을 경우, 두 프로토콜을 위해서 시작 시에 모든 자원을 요청해야만 한다.   

      - __2. 기아 현상 가능성이 있다.__   
        - 여러 자원이 필요한 프로세스가 무기한적으로 자원을 기다릴 수도 있다.   
        - 적어도 필요한 자원 중 하나는 항상 다른 프로세스에 할당되어 있기 때문이다.   
        
#### 7.4.3 No Preemption(비선점)            

  - __비선점 조건이 지켜지지 않게 하는 두 가지 프로토콜__ :star:   
    
    - __1. 비선점 조건을 배제하기 위해서는 프로세스가 일부 자원을 점유하고 있고 추가적인 자원(다른 프로세스가 점유중이며 즉시 할당될 수 없는)을 요청할 경우 자원을 요청한 프로세스가 현재 점유하고 있는 자원들은 모두 선점(해제)당해져야 한다.__   
      - 선점(해제)당한 자원들은 해당 자원들을 기다리고 있는 프로세스를 위해서 자원 목록에 추가된다.   
      - 프로세스는 선점당했던 자원과 새로 요청했던 자원들을 얻을 수 있을 때만 재시작될 수 있다.   

    - __2. 프로세스가 자원을 요청하면, 먼저 자원이 이용가능한지 확인한다.__   
      - 이용가능하다면 할당되고, 아니라면 추가적인 자원을 기다리고 있는 다른 프로세스에 할당되어 있는지 확인한다.   
        - 추가적인 자원을 기다리고 있는 다른 프로세스에 할당이 되어있다면, 기다리고 있는 프로세스로부터 요청했던 자원을 선점하여 해당 자원을 요청하는 프로세스에 할당한다.   
        - 이용불가능하고, 기다리는 프로세스에 의해 점유된 상태도 아니라면, 요청하는 프로세스는 기다려야만 한다.   
          - 기다리는 동안, 다른 프로세스가 자신이 점유하고 있는 자원의 일부를 요청할 경우 해당 자원은 선점당해질 수 있다.   
        - 프로세스는 요청한 새로운 자원과 기다리는 동안 선점당해진 자원들을 점유하고 있을 때에만 재시작 될 수 있다.   
    
    - __이러한 프로토콜은 자원의 상태를 쉽게 저장하고 복원할 수 있는 자원에 적용된다.__   
      - ex) CPU 레지스터, 메모리 공간 등   
      - 일반적으로 mutex lock과 세마포어 같은 자원들에는 적용할 수 없다.   

#### 7.4.4 Circular Wait(순환 대기)          
  
  - __순환 대기 조건이 지켜지지 않게 하기 위해서 모든 자원 타입에 순서를 부과하고 각 프로세스는 오름차순 순서로 자원을 요청해야 한다.__ :star:   
    - ex) `F(테이프 드라이브) = 1`, `F(디스크 드라이브) = 5`, `F(프린터) = 12`      
      - __1. 프로세스가 `Ri`를 먼저 요청한 상황에서 `F(Ri) < F(Rj)`일 경우에만 `Rj`를 요청할 수 있다.__
        - 테이프와 프린터 동시에 사용하기를 원할 경우, 먼저 테이프 요청 후 프린터 요청을 해야한다.   
      - __2. 프로세스가 `Ri`를 먼저 요청한 상황에서 `Rj`를 요청하는 프로세스는 `F(Ri) >= F(Rj)`에 있는 자원 `Ri`를 반드시 해제해야만 한다.__   
        - 프린터 사용하고 있는데 테이프 요청할 경우, 프린터를 반드시 해제해야 한다.   
    - __같은 자원 타입의 여러 인스턴스가 필요할 경우에는, 원하는 모든 인스턴스를 위한 하나의 요청만 발행되어야 한다.__   
    
    - __위의 1, 2 프로토콜이 사용되면, 순환 대기 조건은 배제된다.__    
      - ex) `{P0, P1, .... , Pn}`의 프로세스 집합이 있고 `Pi`가 `Pi+1`에 의해 점유된 `Ri`를 기다리고 있다고 할 경우   
        - 모듈러 연산을 사용하여 `Pn` 은 `P0`에 의해 점유된 `Rn`을 기다리고 있다고 표현    
        - `Pi+1`은 `Ri+1`를 기다리는 동안 `Ri`를 점유하고 있기 때문에 `F(Ri) < F(Ri+1)`이라고 할 수 있다.   
        - 하지만, 이것은 `F(R0) < F(R1) < .... < F(Rn) < F(R0)`을 의미하고 F(R0) < F(R0)는 불가능하므로 순환 대기가 일어날 수 없다.   
      
    - __이러한 구조는 시스템에 있는 모든 동기화 객체 사이에 순서를 매김으로써 app에 구현될 수 있다.__   
      - 동기화 객체에 대한 모든 요청은 오름차순으로 만들어져야 한다.    
        - ex) Pthread에서 lock 순서가 `F(first_mutex) = 1, F(second_mutex) = 2`일 경우   
          - thread_two는 순서에 상관없이 lock을 요청할 수 없다.   
        - 순서를 매기거나 계층화하는 것은 교착 상태를 막을 수 없다.   
          - 교착 상태 예방은 app 개발자가 이러한 순서를 따르는 프로그램을 작성하는데 달려있다.   
          
    - __F()함수는 시스템에서 자원 사용의 일반적인 순서에 따라 정의되어야 한다.__   
      - ex) 테이프 드라이브는 거의 항상 프린터 전에 필요하다. 그러므로 F(테이프 드라이브) < F(프린터)로 정의하는 것은 합리적이다.    
      - 올바른 순서에 의해 얻어지는 자원이 app 개발자의 역할(책임)임에도 불구하고, lock을 적절한 순서로 얻게 보장하고 순서에 상관없이 lock이 얻어지고 교착 상태가 발생할 때 적절한 경고를 주기위해서 특정 소프트웨어가 사용될 수 있다.   
      
  - __One lock-order verifier는 witness이다.__   
    - FreeBSD와 같은 UNIX의 BSD 버전에서 사용된다.    
    - witness는 임계 영역을 보호하기 위해 상호 배제 lock을 사용한다.   
    - 시스템에서 lock 순서의 관계를 동적으로 관리함으로써 작동한다.   
    <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/7_4_DeadlockExample.png" height = 500px title="7_4_DeadlockExample" alt="7_4_DeadlockExample"></img><br><strong>7.4 교착 상태 예시 코드</strong> </p> 

      - __thread_one이 lock을 얻는 첫 번째이고 `first_mutex, second_mutex` 순서로 작동한다.__   
        - witness는 `first_mutex`가 반드시 `second_mutex` 전에 얻어져야 한다고 관계를 기록한다.   
        - thread_two가 나중에 순서를 벗어난 lock을 얻을 경우, witness가 시스템 콘솔에 경고 메세지를 발생시킨다.    
        
    - __lock이 동적으로 얻어질 수 있다면, lock 순서를 부과하는 것이 교착 상태 예방을 보장하지 않는다.__   
    <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/7_5_DeadlockWithLockOrdering.png" width = 600px height = 300px title="7_5_DeadlockWithLockOrdering" alt="7_5_DeadlockWithLockOrdering"></img><br><strong>7.5 lock 순서를 가진 교착 상태 예시 코드</strong> </p>   
    
    
      - ex) 두 계좌 사이에 예금 거래   
        - 경쟁 상태를 예방하기 위해 각 계좌는 `get_lock()`함수로부터 얻어지는 mutex lock을 가진다.   
        - 두 스레드가 동시에 `transaction()` 함수를 호출하면 교착 상태가 발생할 수 있다.   
          - 첫 번째 스레드 -> `transaction(checking_account, savings_account, 25);`   
          - 두 번째 스레드 -> `transaction(savings_account, checking_account, 50);`    

### 7.5 Deadlock Avoidance    
  
  - __교착 상태 예방의 부작용은 낮은 장치 이용률과 저하된 시스템 처리량이다.__    
  
  - __교착 상태를 회피하는 방법__ :star:         
    - __자원이 어떻게 요청되었는지에 대한 추가적인 정보를 요구해야 한다.__   
      - ex) 프린터, 테이프 드라이브가 있는 시스템일 경우    
        - 시스템은 프로세스 P가 먼저 테이프 드라이브를 요청한 후 프린터를 요청하고 두 자원을 해제하기 전에 프로세스 Q가 프린터를 요청한 후 테이프 드라이브를 요청할 것이라는 것을 알 필요가 있다.   
        
    - __시스템은 각 요청에 대해서 프로세스가 미래에 발생가능한 교착 상태를 회피하기 위해서 기다려야 할지 말지를 결정할 수 있다.__   
      - 각 요청은 이러한 결정을 내리는데 있어서 시스템이 자원이 현재 이용가능한지, 자원이 현재 어느 프로세스에 할당되어 있는지, 그리고 각 프로세스가 앞으로 요청하거나 해제하는 자원을 고려해야한다.   
      
    - __가장 단순하고 유용한 모델은 각 프로세스가 필요할지도 모를 각 타입의 자원의 최대 수를 선언하는 것이다.__   
      - 시스템이 교착 상태에 빠지지 않는 것는 것을 보장하는 알고리즘을 형성하는 것이 가능해진다.   

#### 7.5.1 Safe State   

  - __Safe state__   
    - __시스템이 각 프로세스에 자원을 할당(최대까지 할당 가능)할 수 있고 교착 상태를 피할 수 있는 상태__   
  
  - __Safe sequence(순서)가 존재할 경우에만 시스템은 safe 상태이다.__   
    - `<P1, P2, ... , Pn>` 의 프로세스 순서는 현재 할당 상태에 있어 Safe 순서이다.   
      - `Pi`가 만들 수 있는 자원 요청은 현재 이용가능한 자원 + `j<i`인 모든 `Pj`에 의해 점유된 자원에 의해 만족될 수 있다.   
      - `Pi`가 필요한 자원이 즉시 이용가능하지 않다면 `Pi`는 모든 `Pj`가 끝날때까지 기다릴 수 있다.   
        - 모든 `Pj`가 끝날 때, `Pi`는 필요했던 모든 자원을 얻을 수 있고 원했던 작업을 완료하고 할당된 자원을 반환할 수 있다.   
      - `Pi`가 종료될 때, `Pi+1`은 필요했던 모든 자원을 얻을 수 있다.   
      - __이러한 순서가 존재하지 않는다면, 시스템 상태를 unsafe 상태라고 말한다.__   
      
  - __Safe state는 deadlock state가 아니다.__   
    - 역으로, deadlock state는 unsafe state이다.   
      - 하지만, 모든 unsafe state가 deadlock이라고 할 수는 없다.   
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/7_6_StateSpaces.jpg" height = 300px title="7_6_StateSpaces" alt="7_6_StateSpaces"></img><br><strong>7.6 상태 공간</strong> </p>   
      
      - 상태가 safe 하는 한, OS는 deadlock을 회피할 수 있다.   
      - unsafe 상태일 경우, OS는 프로세스가 deadlock을 발생시키는 방식으로 자원 요청하는 것을 막을 수 없다.   
        - 프로세스의 행동이 unsafe 상태를 통제한다.   
        
  - __Safe state의 개념으로 시스템이 교착 상태에 빠지지 않게 보장하는 회피 알고리즘을 정의할 수 있다.__   
    - 핵심은 시스템이 항상 safe 상태에 있게 보장하는 것이다.   
    - 프로세스가 현재 이용가능한 자원을 요청할 때마다 시스템은 해당 자원이 즉시 할당되야 하는지 또는 프로세스가 기다려야할 지 결정해야 한다.   
    - 요청은 오직 할당이 시스템을 safe 상태에 머무르게 할 경우에만 승인된다.   
    - 프로세스가 자원을 요청하더라도 기다려야 할 수 있기 때문에 자원 이용률이 낮아질 수 있다.   
    
#### 7.5.2 Resource-Allocation-Graph Algorithm(자원-할당-그래프 알고리즘)   
  
  - __각 자원의 종류의 하나의 인스턴스만 가지는 자원 할당 시스템일 경우 자원 할당 그래프의 한 종류를 사용할 수 있다.__   
    - __Claim 간선__    
      - `Pi -> Rj` : Pi가 자원 Rj를 미래에 어느 시점에 요청할 수 있다는 의미   
      - 점선으로 표현   
    - __자원들은 시스템에서 먼저 claim되어야 한다.__    
      - 프로세스가 시작하기 전에 모든 claim 간선이 자원 할당 그래프에 표시되어야 한다.   
      - __Pi가 Rj를 요청한다고 할 경우, 요청은 요청 간선 Pi -> Rj를 할당 간선 Rj -> Pi로 변환시키는 것이 자원 할당 그래프에서 사이클을 형성하지 않을 경우에만 승인된다.__   
        - 사이클 감지 알고리즘을 사용함으로써 확인한다.   
          - n^2 연산을 요구한다.(n은 시스템에 있는 프로세스의 수)   
      - 사이클이 없다면, 자원의 할당은 시스템을 safe 상태에 있게 한다.   
      - 사이클이 있다면, 자원의 할당은 시스템을 unsafe 상태에 있게 한다.   
        - 이 경우, 프로세스 Pi는 자신의 요청이 만족될 때까지 기다려야만 한다.   
        
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/7_7_DeadlockAvoidance.jpg" title="7_7_DeadlockAvoidance" alt="7_7_DeadlockAvoidance"></img> <img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/7_8_UnsafeState.jpg" title="7_8_UnsafeState" alt="7_8_UnsafeState"></img><br><strong>7.7 교착 상태 회피 자원-할당 그래프 / 7.8 unsafe 상태의 자원-할당 그래프</strong></p>   
      
        - P2가 R2를 요청한다고 가정하면, R2가 현재 이용가능하지만 이러한 할당이 그래프에서 사이클을 형성할 것이기 때문에 P2에 할당할 수 없게 된다.   
          - unsafe 상태에 있게 될 것이다.   
        - P1이 R2를 요청하고 P2는 R1을 요청하면, 교착 상태가 발생한다.   

#### 7.5.3 Banker's Algorithm(은행원 알고리즘)   

  - __자원 할당 그래프는 각 자원 타입의 여러 인스턴스를 가진 자원 할당 시스템에는 적용할 수 없다.__   
  
  - __은행원 알고리즘은 각 자원 타입의 여러 인스턴스를 가진 자원 할당 시스템에 적용할 수 있지만 덜 효율적이다.__   
    - 은행원이 모든 고객들의 요구를 충족시킬 수 없는 방식으로 이용가능한 현금을 할당할 수 없게 보장하기 위한 은행 시스템에서 사용할 수 있기 때문에 은행원 알고리즘이라고 부른다.   
    - 새로운 프로세스가 시스템에 접속할 때, 필요할 지도 모르는 각 자원 타입의 최대 인스턴스 수를 선언해야만 한다.   
      - 최대 수는 시스템에 있는 총 자원의 수를 초과할 수 없다.   
    - 사용자가 자원의 집합을 요청할 때, 시스템은 자원의 할당이 시스템을 safe 상태에 있게 하는 지 확인해야만 한다.   
      - safe 상태에 있게 되게 한다면, 자원은 할당된다.   
      - safe 상태에 있지 않게 되게 한다면, 프로세느는 다른 프로세스가 충분한 자원을 해제할 때 까지 기다려야만 한다.   
      
  - __여러 자료구조가 은행원 알고리즘을 구현하기 위해 관리되어야만 한다.__   
    - `Available`   
      - 각 타입의 이용가능한 자원의 수   
        - ex) Available[j] = k   
          - 자원 Rj의 k개의 인스턴스가 이용가능하다는 뜻이다.   
    - `Max`   
      - 각 프로세스가 요구하는 최대 값   
        - ex) Max[i][j] = k   
          - 프로세스 Pi가 자원 Rj의 인스턴스 최대 k개를 요청할 수 있다는 뜻이다.   
    - `Allocation`   
      - 각 프로세스에 할당된 각 타입의 자원의 수   
        - ex) Allocation[i][j] = k   
          - 프로세스 Pi가 자원 Rj의 인스턴스 k개를 할당받았다는 뜻이다.   
    - `Need`   
      - 각 프로세스가 요구하는 자원의 수   
        - ex) Need[i][j] = k   
          - 프로세스 Pi가 작업을 완료하기 위해 자원 Rj의 인스턴스 k개가 필요하다는 뜻이다.   
          - Need[i][j] = Max[i][j] - Allocation[i][j]   
          
### 7.6 Deadlock Detection   

  - __시스템이 교착 상태 예방 또는 교착 상태 회피 알고리즘을 사용하지 않을 경우, 시스템이 제공해야 하는 요소__   
    - __1. 교착 상태가 발생했는지 확인하기 위한 시스템 상태 검사 알고리즘__   
    - __2. 교착 상태로부터 회복하는 알고리즘__    
    
  - __탐지 또는 회복 구조는 탐지 알고리즘의 실행과 필수 정보 관리하는데 실행 시간 비용뿐만 아니라 교착 상태로부터 회복하는데 있어서 잠재된 손실을 포함하는 오버헤드를 요구한다.__   

#### 7.6.1 Single Instance of Each Resource Type(각 자원 타입의 단일 인스턴스)   

  - __대기 그래프(Wait-for graph)__   
    - __모든 자원이 단일 인스턴스만 가질 경우, 자원 할당 그래프의 변형을 사용한 교착 상태 감지 알고리즘__    
    - 자원 할당 그래프에서 자원 노드를 제거하고 적절한 간선을 붕괴시킴으로써 대기 그래프를 얻을 수 있다.   
    - __Pi -> Pj 는 Pi가 필요로 하는 자원을 Pj가 해제하기를 기다리는 것을 나타낸다.__   
      - 대응되는 자원 할당 그래프가 Pi -> Rq 와 Rq -> Pj 두 간선을 포함하고 있을 경우에만 대기 그래프에서 Pi -> Pj 간선이 존재한다.   
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/7_9_TwoGraphs.jpg" height = 300px title="7_9_TwoGraphs" alt="7_9_TwoGraphs"></img><br><strong>7.9 (a) 자원-할당 그래프      (b) 대응되는 대기 그래프</strong> </p>   
      
      - __대기 그래프에서 사이클이 있을 경우에만 시스템에 교착 상태가 발생한다.__   
      - 교착 상태를 탐지하기 위해서, 시스템은 대기 그래프를 유지해야하고 주기적으로 그래프에서 사이클을 찾기 위한 알고리즘을 호출해야 한다.   
      - 그래프에서 사이클을 탐지하는 알고리즘은 n^2의 연산이 필요하다.(그래프에서 정점의 수 n)   
    
#### 7.6.2 Several Instances of Each Resource Type(각 자원 타입의 다수 인스턴스)   

  - __대기 그래프는 각 자원 타입의 다수 인스턴스를 가진 자원 할당 시스템에 적용될 수 없다.__   
  
  - __각 자원 타입의 다수 인스턴스를 가진 자원 할당 시스템에 적용할 수 있는 교착 상태 탐지 알고리즘은 시간에 따라 변하는 자료구조를 사용한다.__   
    - `Available`   
      - 각 타입의 이용가능한 자원의 수   
        - ex) Available[j] = k   
          - 자원 Rj의 k개의 인스턴스가 이용가능하다는 뜻이다.   
    - `Allocation`   
      - 각 프로세스에 할당된 각 타입의 자원의 수   
        - ex) Allocation[i][j] = k   
          - 프로세스 Pi가 자원 Rj의 인스턴스 k개를 할당받았다는 뜻이다.   
    - `Request`   
      - 각 프로세스가 현재 요청하는 자원의 수   
        - ex) Request[i][j] = k   
          - 프로세스 Pi가 자원 Rj의 인스턴스 k개가 요청하고 있다는 뜻이다.   
          - Request[i][j] = Max[i][j] - Allocation[i][j]   
    
    - __시스템이 교착 상태에 있는 지 탐지하기 위해서 m * n^2의 연산이 필요하다.__   
    
#### 7.6.3 Detection-Algorithm Usage(탐지-알고리즘 사용)    

  - __탐지 알고리즘 호출 시기를 결정하는 요소 2 가지__   
    - __1. 얼마나 자주 교착 상태가 발생하는가?__   
    - __2. 교착 상태 발생 시 얼마나 많은 프로세스가 영향을 받는가?__   
    
  - __교착 상태가 자주 발생하면, 탐지 알고리즘을 자주 호출해야 한다.__   
    - 교착 상태에 있는 프로세스에 할당된 자원들은 교착 상태가 풀릴 때까지 idle 상태로 있게 된다.   
    - 교창 상태 사이클에 관련된 프로세스의 수가 증가할 수 있다.   
    
  - __교착 상태는 일부 프로세스가 즉시 승인될 수 없는 요청을 할 때만 발생한다.__    
    - 이러한 요청은 기다리는 프로세스들의 연쇄를 끝내는 마지막 요청일 수 있다.   
    
  - __극단적으로 할당이 즉시 승인되지 않는 요청이 발생할때마다 탐지 알고리즘이 호출될 수 있다.__   
    - 이 경우 교착 상태인 프로세스를 확인하는 것 뿐만 아니라 교착 상태를 일으킨 프로세스도 확인한다.   
      - 현실에서는 교착 상태인 각 프로세스는 자원 그래프에서 사이클을 이루는 링크이다. 그러므로 모두가 교착 상태를 발생시킨다.   
    - 많은 다른 종류의 자원 타입이 존재하고, 하나의 요청이 자원 그래프에서 많은 사이클을 생성할수도 있다면, 각 사이클은 가장 최근 요청에 의해 완료되며, 하나의 인식가능한 프로세스에 의해 발생된다.   
  
  - __매 요청마다 탐지 알고리즘을 호출하는 것은 연산하는 시간에 있어 상당한 오버헤드를 발생시킬 수 있다.__   
    - 덜 비용이 드는 방법은 일정한 간격을 호출하는 것이다.   
      - ex) 한 시간마다 또는 CPU 이용률이 40% 이하로 떨어질 때마다 호출한다.     
        - 교착 상태는 결국 시스템 처리량에 아주 심한 손상를 주고 CPU 이용률을 떨어뜨린다.   
    - 제멋대로 호출될 경우, 자원 그래프는 많은 사이클을 가질 수 있다.   
      - 이 경우 어떤 프로세스가 교착 상태를 일으켰는 지 알 수 없다.   
      
### 7.7 Recovery from Deadlock   

  - __교착 상태를 탐지했을 경우__   
    - __1. operator에게 교착 상태가 발생했다는 것을 알려주고 수동으로 처리하게 한다.__   
    - __2. 시스템이 자동적으로 교착 상태로부터 회복하게 한다.__   
    
  - __교착 상태를 없애는 2가지 방법__   
    - __1. 순환 대기를 없애기 위해서 하나 이상의 프로세스를 중지(abort)시킨다.__   
    - __2. 하나 이상의 교착 상태에 있는 프로세스로부터 일부 자원을 선점한다.__   
    
#### 7.7.1 Process Termination(프로세스 종료)    
  
  - __프로세스를 중지시킴으로써 교착 상태를 제거하기 위해서 사용하는 방법 두 가지__     
    - __두 방법에서 시스템은 종료된 프로세스에 할당된 모든 자원을 회수한다.__   
    
    - __1. 교착 상태인 모든 프로세스 중지__   
      - 교착 상태 사이클을 없애지만 비용이 많이 든다.   
      - 오랫동안 연산을 할 수도 있다.   
      - 부분적인 연산의 결과는 반드시 폐기되야 하며 이후 다시 계산해야 한다.   
      
    - __2. 교착 상태 사이클이 제거될 때까지 프로세스 하나씩 중지__    
      - 각 프로세스가 중지될 때마다 탐지 알고리즘을 호출해 어느 프로세스가 여전히 교착 상태인지 확인해야 하기 때문에 많은 오버헤드를 초래할 수 있다.   
      
  - __프로세스를 중지시키는 것은 어렵다.__    
    - 프로세스가 파일 업데이트 도중에 중지된다면 파일은 부정확한 상태로 남아있을 것이다.   
    - 프로세스가 프린터에서 데이터를 출력하는 도중에 중지된다면 시스템은 반드시 다음 작업을 출력하기전에 프린터를 올바른 상태로 reset해야 한다.   
    
  - __부분적인 종료 방법이 사용된다면, 반드시 어느 교착 상태 프로세스 또는 일반 프로세스가 종료되었는 지 확인해야만 한다.__   
    - 이러한 확인은 CPU 스케줄링 결정과 유사한 정책 결정에 달려 있다.   
    - 기본적으로 비용이 핵심이다.   
    - __최소 비용을 초래하는 프로세스를 중지시켜야 한다.__   
      - 최소 비용은 정확한 용어는 아니다.   
    - __프로세스 중지에 영향을 미치는 요소__   
      - 1. 프로세스 우선순위   
      - 2. 얼마나 오랫동안 연산했으며 작업을 완료하기 위해서 얼마나 더 연산해야 하는지   
      - 3. 프로세스가 사용하는 자원의 타입과 수   
      - 4. 프로세스가 완료하기 위해 필요한 자원의 수   
      - 5. 종료되야 할 프로세스의 수
      - 6. 프로세스가 interactive 또는 batch인지   
      
#### 7.7.2 Resource Preemption(자원 선점)    

  - __자원 선점을 이용하여 교착 상태를 제거한다.__   
    - 프로세스로부터 일부 자원을 선점하고 교착 상태 사이클이 없어질 때까지 이러한 자원을 다른 프로세스에 넘겨준다.   
  
  - __선점으로 교착 상태를 해결하기 위해서 다뤄져야 할 3가지 이슈__   
    - __1. 희생자 선택(Selecting a victim)__   
      - __어느 자원 그리고 어느 프로세스가 선점될건지 선택해야 한다.__   
      - 프로세스의 종료와 같이 비용을 최소화할 수 있는 선점 순서를 결정해야 한다.   
      - 비용 요소에는 교착 상태 프로세스가 가지고 있는 자원의 수, 프로세스가 지금까지 소비한 시간의 양 같은 매개 변수들이 포함될 수 있다.   
      
    - __2. 롤백(Rollback)__   
      - 하나의 프로세스로부터 자원을 선점하면, 선점당한 프로세스는 어떻게 할 것인가?   
      - 일반적인 실행을 계속 할 수 없기 때문에, 반드시 프로세스를 safe state로 rollback하고 해당 지점으로부터 재시작해야한다.   
        - __일반적으로 safe state가 무엇인지 결정하기 어렵기 때문에, 가장 간단한 방법은 전체 rollback하는 것이다.__   
          - 프로세스를 중지시키고 재시작한다.   
          - 프로세스를 단지 교착 상태만 깨뜨릴 정도로 rollback 할 수 있다면 매우 효과적이다. 하지만, 이 방식은 시스템이 실행하는 모든 프로세스들의 상태에 대한 더 많은 정보를 유지할 것을 필요로 한다.


    - __3. 기아 현상(Starvation)__   
      - __기아 현상이 일어나지 않을 것이라는 것을 어떻게 보장하는가?__   
        - __즉, 어떻게 자원이 같은 프로세스로부터 항상 선점당하지 않을 것이라고 보장할 수 있는가?__   
      - __비용 요소에 기반하여 희생자를 고르는 시스템에서는 같은 프로세스가 항상 희생자로 선택될 수 있다.__   
        - 선택당한 프로세스는 절대 자신의 원하는 작업을 완료하지 못한다.   
          - 즉, 기아 상태에 있게 되며 이러한 문제는 모든 실용적인 시스템에서 다뤄야만 한다.   
      - 반드시 프로세스는 (작은) 유한의 수 만큼만 희생자로 선택되게 보장해야 한다.   
      - __가장 일반적인 해결법은 비용 요소에 rollback 횟수를 포함시키는 것이다.__   
      
