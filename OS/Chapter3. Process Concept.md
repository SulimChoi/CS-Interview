# :bookmark_tabs: Operating System Concepts 9th edition      
## 3장 Process Concept   
__중요하다고 생각되는 목차에는 :star: 표시해놓았습니다.__   
__:star:되어 있는 목차를 클릭하시면 클릭하신 목차의 내용이 있는 페이지로 넘어가며__   
__해당 페이지 내에 있는 중요 개념 옆에 :star: 표시해놓았습니다.__   

__혹시 잘못된 내용이 있거나 보완해야할 점이 있으면 `issue` 해주시거나 알려주시면 감사하겠습니다.:bow:__   

* [3.Process Concept](#3process-concept)   
   - [3.1 Process Concept](#31-process-concept) :star:   
      - [3.1.1 The Process(프로세스)](#311-the-process프로세스) :star:    
      - [3.1.2 Process State(프로세스 상태)](#312-process-state프로세스-상태) :star:   
      - [3.1.3 Process Control Block(프로세스 제어 블록)](#313-process-control-block프로세스-제어-블록) :star:     
      - [3.1.4 Thread(스레드)](#314-thread스레드)   
   - [3.2 Process Scheduling](#32-process-scheduling) :star:
      - [3.2.1 Scheduling Queues(스케줄링 큐)](#321-scheduling-queues스케줄링-큐) :star:   
      - [3.2.2 Schedulers(스케줄러)](#322-schedulers스케줄러) :star:   
      - [3.2.3 Context Switching(문맥 교환)](#323-context-switching문맥-교환) :star:     
   - [3.3 Operations on Processes](#33-operations-on-processes)   
      - [3.3.1 Process Creation(프로세스 생성)](#331-process-creation프로세스-생성) :star:   
      - [3.3.2 Process Termination(프로세스 종료)](#332-process-termination프로세스-종료) :star:   
   - [3.4 Interprocess Communication(프로세스간 통신)](#34-interprocess-communication프로세스간-통신) :star:   
      - [3.4.1 Shared-Memory Systems(공유 메모리 시스템)](#341-shared-memory-systems공유-메모리-시스템) :star:   
      - [3.4.2 Message-Passing Systems(메세지 전달 시스템)](#342-message-passing-systems메세지-전달-시스템) :star:   
         - [3.4.2.1 Naming(명명)](#3421-naming명명)   
      - [](#)   
      - [](#)   
      - [](#)         
      - [](#)   
      - [](#)   
      
## 3.Process Concept   
   
   - __Process__ :star:   
      - __현대 시분할 시스템에서 작업의 단위__   
      - __실행중인 프로그램__   
      
   - __시스템은 프로세스의 집합으로 구성__    
      - __OS 프로세스__   
         - 시스템 코드 실행   
      - __사용자 프로세스__   
         - 사용자 코드 실행    
         
### 3.1 Process Concept   

   - __batch 시스템__   
      - job을 실행시킨다.   
         - 해당 챕터에서 job은 process와 거의 같은 용어로 사용한다.   
         - 대부분의 OS 이론과 용어들은 OS의 주요 activity가 job processing일때 발전되었다.    
         - process가 job이라는 단어를 대체하기 때문에 일반적으로 받아들여지는 job scheduling 같은 단어 job을 포함하는 용어들의 사용을 피하는 것이 오해를 불러 일으킬 수도 있다.    
      
   - __시분할 시스템__   
      - 사용자 프로그램 또는 task를 가진다.   
      
#### 3.1.1 The Process(프로세스)   

   - __Process는 text 영역으로 알려진 program code뿐만 아니라 processor 레지스터의 내용과 program counter의 값에 의해 보여지는 현재 activity를 포함한다.__   
   
   - __Process in 메모리__ :star:   
      - __Stack__   
         - 함수 매개변수, 반환 주소, 지역 변수 같은 일시적 데이터   
      - __Data__   
         - 전역 변수   
      - __Heap__    
         - Process 실행 동안 동적으로 할당된 메모리   
      - __Text__   
         - Program code   
      #### 프로세스 메모리 이미지   
      
   - __Program = 수동적 개체__   
      - ex) 디스크에 저장된 명령어 목록을 가진 파일 (= 실행가능한 파일)   
   
   - __Process = 능동적 개체__   
      - ex) 실행할 다음 명령어를 명시하는 Program counter를 가지고 있으며 관련된 자원의 집합을 포함한다.    
      
   - __실행가능한 파일이 메모리로 적재될 때 Program은 Process가 된다.__ :star:   
      - 실행 시키는 방법   
         - 아이콘 더블 클릭   
         - 명령어 라인에서 실행가능한 파일 이름 입력, 엔터   
         
   - __두 개의 Process가 같은 Program과 관련이 있더라도, 두 개의 분리된 실행으로 고려된다.__ :star:   
      - ex) 다수의 사용자가 하나의 메일 프로그램을 여러 개 실행 또는 한 사용자가 하나의 웹브라우저 프로그램을 여러 개 실행할 경우, 각각의 분리된 Process이다.   
      - __Text 영역은 같지만 Stack, Data, Heap 영역은 다르다__   
      
   - __프로세스 자체가 다른 코드를 위한 실행 환경이 될 수 있다.__   
      - ex) Java 프로그래밍 환경   
         - 실행가능한 Java 프로그램은 JVM 내에서 실행된다.   
         - JVM은 적재된 Java 코드를 해석하고 그 코드를 위해서 기계 언어를 통해 그 코드를 실행하는 프로세스로서 실행된다.   
         
#### 3.1.2 Process State(프로세스 상태)   

   - __Process 상태__ :star:   
      - __New__   
         - Process가 생성된 상태   
      - __Running__   
         - 명령어가 실행중인 상태   
      - __Waiting__   
         - Process가 일부 event를 위해 입출력 완료 또는 신호를 기다림과 같은 어떤 사건이 발생하기를 기다리는 상태
      - __Ready__   
         - Processor에 할당되기를 기다리는 상태   
      - __Terminated__   
         - Process의 실행이 종료된 상태   
      
      #### 프로세스 상태 이미지   
      
#### 3.1.3 Process Control Block(프로세스 제어 블록)   

   - __각 Process는 PCB에 의해서 OS안에 표현된다.__   
      - PCB를 Task Control Block이라고도 한다.   
      
      #### PCB 이미지   
      
   - __PCB가 가진 정보__ :star:   
      - __프로세스 상태(Process state)__   
         - New, Ready, Running, Waiting(Halted)상태 등이 있다.   
      - __프로그램 카운터(Program counter)__   
         - 프로세스를 위해 실행되어야 할 다음 명령어의 주소를 가리킨다.   
      - __CPU 레지스터(CPU register)__   
         - 컴퓨터 구조에 따라 종류와 수가 다르다.   
         - 누산기(accumulator), 색인 레지스터(index register), 스택 레지스터(stack register), 범용 레지스터(general-purpose register), 상태 코드 정보(condition-code information)를 포함한다.   
         - Program Counter와 함께 상태 정보는 나중에 프로세스가 계속 올바르게 수행되도록 하기 위해서 인터럽트 발생시마다 반드시 저장되어야 한다.   
      - __CPU-스케줄링 정보(CPU-scheduling information)__   
         - 프로세스 우선순위, 스케줄링 큐를 위한 포인터, 다른 스케줄링 파라미터를 포함한다.   
      - __메모리-관리 정보(Memory-management information)__   
         - OS에 의해 사용되는 메모리 시스템에 따라 Segment table 또는 Page table과 base register, limit register의 값 같은 항목을 포함한다.   
      - __계산 정보(Accounting information)__   
         - CPU의 수, 사용된 시간, 시간 제한, 계정 정보, 작업(job) 또는 프로세스 번호 등을 포함한다.   
      - __입출력 상태 정보(I/O status information)__   
         - 프로세스에 할당된 일출력 장치들과 열린 파일의 목록 등을 포함   
      
      #### CPU 스위칭 이미지    

#### 3.1.4 Thread(스레드)   
   
   - __단일 스레드는 프로세스가 한번에 하나의 작업만 수행할 수 있게 한다.__   
   
   - __현대 OS는 프로세스가 다수의 스레드를 가질 수 있게 하고 한번에 하나 이상의 작업을 수행할 수 있게 한다.__   
      - 멀티 코어 시스템에서 효율적이다.   
      
   - __이러한 다수의 스레드를 지원하기 위해 시스템에서 PCB는 각 스레드를 위한 정보도 포함한다.__ :star:   
   
### 3.2 Process Scheduling   

   - __멀티 프로그래밍의 목적__   
      - 항상 어떤 프로세스가 실행되게하여 CPU의 사용을 최대화하는데 있다.   
      
   - __시분할의 목적__   
      - Process들 사이에 빈번하게 CPU를 변경해주어 각 프로그램이 실행되는 동안 사용자가 각 프로그램과 교류할 수 있게 하기 위해서이다.   
      
   - __이러한 목적을 달성하기 위해서 Process Scheduler가 존재하며, Process Scheduler는 CPU에서 프로그램 실행을 시키기 위해 이용가능한 프로세스들 중 하나의 프로세스를 선택한다.__   
      - 단일 처리기 시스템의 경우, 실행 중인 프로세스가 한 개 이상 있을 수 없다. 만약 단일 처리기에 여러 프로세스들이 있다면 프로세스들은 CPU가 작업이 끝날 때까지 대기하여야 한다.   
      
#### 3.2.1 Scheduling Queues(스케줄링 큐)   
   
   - __스케줄링 큐의 종류__ :star:   
      - __작업 큐(Job queue)__  
         - 프로세스가 시스템에 들어오면 작업 큐에 놓여 진다.   
         - 시스템에 있는 모든 프로세스로 구성된다.   

      - __준비 완료 큐(ready queue)__   
         - 메인 메모리에 있고 준비 완료되고 실행되기를 기다리는 프로세스들은 준비 완료 큐에 저장되어 있다.   
         - 연결 리스트로 저장되어 있다.   
         - 준비 완료 큐의 헤더는 연결 리스트의 첫 번째와 마지막 PCB를 가리키는 포인터를 포함한다.   
         - 각 PCB는 준비 완료 큐에서 다음 PCB를 가리키는 포인터 필드를 가진다.   
         
      - __장치 큐(Device queue)__   
         - 특정 입출력 장치를 위해 기다리고 있는 프로세스들의 목록    
         - 각 장치는 자신 고유의 장치 큐를 가진다.   
         
      #### 3.5 각 큐 이미지 
      
   - __새로운 프로세스는 초기에 ready queue에 넣어지고 실행을 위해 선택되기 전 또는 dispatched 될 때까지 대기한다.__   
      - __dispatch__ :star:   
         - 준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것, 즉 준비 상태에서 실행 상태로 바뀌는 것   
         - dispatch : ready → running   
   
   - __프로세스가 CPU에 할당되면 프로세스는 실행되고 아래의 event들 중 하나가 발생할 수 있다.__   
      __1. 입출력 요청을 하고 입출력 큐로 들어간다.__   
      __2. 자식 프로세스를 생성하고 자식이 종료될 때까지 기다린다.__   
      __3. 인터럽트의 결과로 CPU로부터 강제적으로 제거되고 ready queue에 다시 놓여진다.__   
      
      - __1~2는 프로세스가 결국 Wait -> ready 상태로 바뀌고 ready queue에 다시 놓여진다.__   
      - __프로세스는 종료될 때까지 이러한 cycle을 계속한다.   
         - 프로세스가 모든 queue로부터 제거되고 각 PCB와 자원이 해제되는 순간 종료된다.   
         
#### 3.2.2 Schedulers(스케줄러)   

   - __batch 시스템의 경우, 즉시 실행될 수 있는 프로세스보다 더 많은 프로세스가 요청 되어진다.__   
      - 이러한 프로세스들은 나중에 실행되기 위해서 거대한 저장 장치에 저장(spool)된다.   
      
   - __장기 스케줄러(= 작업 스케줄러)__ :star:   
      - 이러한 pool(거대한 저장 장치)에서 프로세스를 선택하고 실행을 위해 메모리로 적재한다.   
      
   - __단기 스케줄러(= CPU 스케줄러)__ :star:   
      - 실행할 준비가 된 프로세스들 중 선택하여 CPU에 할당한다.   
      
   - __장기 스케줄러와 단기 스케줄러의 차이점__ :star:   
      - __실행 빈도__    
         - __단기 스케줄러__   
            - CPU를 위해 반드시 빈번한게 새로운 프로세스를 선택해야 한다.    
               - ex) 아주 작은 시간동안만 실행한 후 입출력 요청을 하는 프로세스가 있을 경우 다른 프로세스를 선택해야한다.    
            - 단기 스케줄러는 적어도 100 milliseconds마다 실행한다.   
            - 단기 스케줄러는 실행 간격이 짧기 때문에 반드시 빨라야 한다.   
               - ex) 100 milliseconds 동안 실행되는 프로세스를 실행하기 위해 결정하는데 10 milliseconds가 걸린다면,   
               - (100+10) / 10 = 9% 의 CPU가 작업을 스케줄링 하기 위해서 낭비되어진다.   
               
         - __장기 스케줄러__   
            - 실행 빈도가 훨씬 적다.   
            - 멀티 프로그래밍의 정도(메모리 안에 있는 프로세스들의 수)를 제어한다.   
            - 멀티 프로그래밍의 정도가 안정되면, 프로세스 평균 생성률은 시스템은 나가는 프로세스의 평균률과 반드시 같아진다.   
            - 장기 스케줄러는 프로세스가 시스템을 나갈 때만 호출되어야 할 수도 있다.   
            - 실행 간격이 더 크기 때문에, 장기 스케줄러는 실행할 프로세스를 선택하는데 더 많은 시간을 사용해도 된다.   
               
               
   - __대부분의 프로세스는 입출력 중심 또는 CPU 중심으로 기술된다.__ :star:      
      - __입출력 중심 프로세스__   
         - 연산을 하는 것보다 입출력에 시간을 더 소비하는 프로세스   
         
      - __CPU 프로세스__   
         - 연산에 시간을 더 사용하면 입출력 요청을 드물게 발생시키는 프로세스   
         
   - __장기 스케줄러가 입출력 중심과 CPU 중심 프로세스들의 적절하게 섞인 프로세스를 선택하는 것이 중요하다.__   
      - 모든 프로세스가 입출력 중심일 경우   
         - ready queue는 거의 항상 비어있게 되고, 단기 스케줄러가 해야할 일은 거의 없다.   
      - 모든 프로세스가 CPU 중심일 경우   
         - 입출력 대기 큐는 거의 항상 비어있게 되고, 장치들은 사용되지 않으며 시스템은 다시 균형을 잃게 된다.   
         
      - __최고의 성능을 가진 시스템은 CPU 중심과 입출력 중심 프로세스들의 조합을 가질 것이다.__   
      
   - __일부 시스템에서는 장기 스케줄러가 없거나 아주 작을 수 있다.__   
      - 시분할 시스템(UNIX, MS Window)는 장기 스케줄러가 없지만 단기 스케줄러를 위해 모든 새로운 프로세스를 메모리에 넣는다.   
      - 이러한 시스템의 안정성은 이용가능한 터미널 수와 같은 물리적인 제한 또는 사용자의 조정 능력에 달려있다.   
         - ex) 멀티 사용자 시스템에서 성능이 허용할 수 없을 정도로 하락하면, 사용자는 그냥 종료할 것이다.   
      - 시분할 시스템과 같은 OS는 중기 스케줄링을 도입할 수도 있다.   
      
   - __중기 스케줄러__ :star:   
      - 메모리로부터 프로세스를 제거하는 것이 이점이 될 수 있고 멀티프로그래밍의 정도를 줄일 수 있다.   
      - __스와핑__     
         - 메모리에서 프로세스들을 제거한 다음 차후 실행 시 다시 메모리에 프로세스를 불러와서 중단되었던 시점부터 실행을 재개한다.   
         - 프로세스 중기 스케줄러에 의해 swap out, swap in 된다.   
         - 스와핑은 프로세스 조합을 향상시키거나 메모리 요구 사항에서의 변화가 이용가능한 메모리보다 초과할당했을 때 필수적일 수 있다.   
         
#### 3.2.3 Context Switching(문맥 교환)   
   
   - __인터럽트는 OS가 현재 작업으로터 CPU를 변경하고 커널 루틴을 실행하게 한다.__   
      - 인터럽트가 발생하면, CPU에서 실행하는 프로세스의 현재 문맥를 저장하고 나중에 해당 문맥를 복구한다. 본질적으로 프로세스를 중단하고 재개하는 것이다.   
      - 문맥은 프로세스의 PCB에 표시된다.   
         - CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보를 포함한다.   
         
      - 일반적으로 CPU의 현재 상태를 저장하고 실행을 재개하기 위해 상태 복구를 한다.   
      - __문맥 교환__ :star:      
         - __다른 프로세스로 CPU를 전환하는 것은 현재 프로세스의 상태 저장과 다른 프로세스의 상태 복구 수행하는 작업__   
         - __문맥 교환이 발생하면, 커널은 PCB에 현재(오래된) 프로세스의 문맥을 저장하고 스케줄된 새로운 프로세스의 저장된 문맥을 불러온다.__   
         - __문맥 교환이 일어날 동안 시스템은 어떠한 유용한 작업도 할 수 없기 때문에 문맥 교환 시간은 순수 오버헤드로 간주된다.__   
         - 문맥 교환 속도는 메모리 속도, 복사되어야 하는 레지스터의 수, 특수 명령어의 존재(모든 레지스터를 저장 또는 불러오기 위한 단일 명령어) 등의 machine에 따라 다르다.   
         - 일반적인 스피드는 아주 적은 milliseconds이다.   
         - __문맥 교환 시간은 하드웨어 매우 의존적이다.__   
            - 여러 레지스터 집합을 제공하는 프로세서가 있을 경우   
               - 문맥 교환은 단순히 현재 레지스터 집합으로 포인터를 변경하는 것을 요구한다.   
               - 만약 레지스터 집합보다 더 많은 active 프로세스가 있다면, 시스템은 메모리와 복사된 레지스터 데이터를 주고받는데 의지하게 된다.   
               - OS가 복잡할수록 문맥 교환동안 반드시 처리되어야 하는 작업의 양이 커진다.   
               
### 3.3 Operations on Processes   
#### 3.3.1 Process Creation(프로세스 생성)   

   - __대부분의 시스템에서 프로세스는 병행 실행될 수 있고 동적으로 생성, 제거될 수 있다.__    
   
   - __프로세스는 실행 도중에 프로세스 생성 시스템 호출을 통해서 여러 개의 새로운 프로세스들을 생성 할 수 있다.__ :star:   
      - __부모 프로세스__   
         - 생성하는 프로세스   
      - __자식 프로세스__   
         - 생성되는 새로운 프로세스   
      - __새로운 프로세스들은 다시 새로운 프로세스들을 생성할 수 있으며 그 결과 트리 구조의 프로세스가 형성 된다.__    
      
   - __대부분 OS는 고유한 프로세스 식별자(PID)에 의해 프로세스를 구분하며 식별자는 정수이다.__   
      - PID는 커널안의 프로세스의 다양한 속성에 접근하기 위해 index로 사용될 수 있다.   
      
   - __프로세스가 자식 프로세스를 생성할 때, 자식 프로세스는 작업을 수행하기 위해 CPU 시간, 메모리, 파일, 입출력 장치 같은 특정한 자원들이 필요하다.__   
   
   - __자식 프로세스가 자원을 얻는 방법__    
      __1. OS로부터 직접 자원을 받음__   
      __2. 부모 프로세스의 자원의 일부분을 부모 프로세스로부터 받음__   
      
      - 부모 프로세스는 자식들에게 자원을 분할하거나 자식들과 메모리 또는 파일과 같은 일부 자원을 공유할 수 있어야한다.   
      - 부모 자원을 자식에게 제한하는 것은 너무 많은 자식 프로세스를 생성함으로써 시스템이 부하를 받는 것을 막을 수 있다.   
   
   - __물리적, 논리적 자원을 제공하는 데 있어서 부모 프로세스는 초기 설정 데이터(input)를 자식 프로세스로 넘겨줄지도 모른다.__   
      - ex) image.jpg 파일의 내용을 터미널의 화면에 보여주는 기능을 하는 프로세스   
      - 프로세스가 생성될 때, 부모 프로세스로부터 input으로 image.jpg 파일의 이름, 출력 장치의 이름을 얻게 된다.   
      - 파일 이름을 사용하여, 파일을 열고 내용을 작성한다.   
      
      - 일부 OS는 자식 프로세스에 자원을 넘겨준다.   
         - 새로운 프로세스는 image.jpg와 터미널 장치 두 열린 파일을 받을 수 있고 둘 사이에 datum를 전송할 수 있다.   
         
   - __프로세스가 새로운 프로세스를 생성할 때 실행 관련 두 가지 가능성__   
      __1. 부모는 계속해서 자식과 병렬로 실행된다.__   
      __2. 부모는 일부 또는 모든 자식이 종료될 때까지 기다린다.__   
      
   - __새로운 프로세스를 위한 두 가지 주소 공간 가능성__   
      __1. 자식 프로세스는 부모 프로세스의 복사본이다.(같은 프로그램과 데이터를 가진다.)__   
      __2. 자식 프로세스는 자신에게 적재 될 새로운 프로그램을 가진다.__   
      
   - __UNIX에서 자식 프로세스는 부모 프로세스의 주소 공간의 복사본이다.__   
      - 부모가 자식과 통신을 쉽게 할 수 있다.   
      - 두 프로세스가 실행을 계속한다.   
      - fork()의 return 코드는 새로운 자식 프로세스일 경우 0이고 자식의 nonzero인 프로세스 식별자는 부모에게 return된다.    
      
   - __fork()후에 두 프로세스 중 하나는 프로세스의 메모리 공간을 새로운 프로그램으로 대체하기 위해서 exec() 시스템 호출을 사용한다.__   
      - exec()은 이진 파일을 메모리로 불러오고 (exec()이 가지고 있는 프로그램의 메모리 이미지를 파괴하면서) 실행을 시작한다.   
      - 이러한 방식에서 두 프로세스는 통신할 수 있고 각자 분리된 방식으로 진행된다.   
   
   - __자식이 실행되는 동안 부모가 할 게 없을 경우, 자식이 종료될 때까지 자신을 ready queue로 이동시키기 위해 wait()을 발행한다.__   
   
   - __프로세스의 주소 공간을 새로운 프로그램으로 덮어씌우는 exec()때문에, exec()는 에러가 발생하지 않는한 통제권을 반환하지 않는다.__   
   
   - __자식 프로세스는 부모 프로세스로부터 권한, 스케줄링 속성을 상속받는다.__   
   
#### 3.3.2 Process Termination(프로세스 종료)   

   - __프로세스는 마지막 명령문을 마칠 때 종료되고 exit() 시스템 호출을 사용하여 OS에게 프로세스 삭제를 요청한다.__   
      - 이 시점에서, 프로세스는 부모 프로세스에게 wait()을 통해 상태 값을 반환할 수 있다.   
      - 물리, 논리 메모리, 열린 파일, 입출력 버퍼를 포함한 모든 자원이 OS에 의해 해제된다.   
      
   - __프로세스는 시스템 호출을 통해 다른 프로세스를 종료시킬 수 있다.__   
      - 종료될 프로세스의 부모에 의해서만 이러한 시스템 호출이 가능하다.   
      
   - __부모가 자식의 실행을 종료하는 이유__ :star:   
      - 자식이 할당받은 자원의 사용을 초과했을 경우    
      - 자식에게 할당된 task가 더 이상 필요하지 않을 경우   
      - 부모가 종료하는데, 부모가 종료한 후 OS가 자식이 계속 실행되게 허용하지 않는 경우   
      
   - __일부 시스템에서는 부모 프로세스가 종료된 이후 자식 프로세스가 존재할 수 없다.__ :star:     
      - __연속적 종료(Cascading Termination)__   
         - 부모 프로세스가 종료되면, 모든 자식 프로세스들은 종료되어야 한다.   
         - OS가 직접 수행한다.   
         
   - __일반적인 종료에서 exit()은 직접적으로 또는 간접적(main의 return)으로 호출될 수 있다.__   
   
   - __부모는 wait()을 사용함으로써 자식이 종료될 때까지 기다릴 수 있다.__   
      - wait()은 부모가 자식의 종료 상태를 얻을 수 있는 파라미터가 전달되어진다.   
      - wait()은 종료된 자식의 pid를 반환하여 부모가 어느 자식이 종료되었는지 알 수 있다.   
      
   - __프로세스가 종료되면, 자원들은 OS에 의해 해제된다.__   
      - 자식 프로세스가 종료된 이후에 부모 프로세스가 자식 프로세스의 상태를 알고 싶을 수 있기 때문에 커널은 자식 프로세스가 종료되더라도 최소한의 정보(프로세스 ID, 프로세스 종료 상태 등)를 가지고 있게 된다. 그러므로 프로세스 테이블에 있는 해당 자식 entry는 부모가 wait()을 호출할 때 까지 남아있어야만 한다.   
      - 프로세스 테이블은 프로세스의 종료 상태를 포함하기 때문이다.   
      
   - __좀비 프로세스__ :star:   
      - 부모가 wait()을 아직 호출하지 않은 자식 프로세스, 즉, 자식 프로세스가 종료되었지만 부모 프로세스가 wait()을 통해 아직 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 자식 프로세스를 의미한다.   
      - 모든 자식 프로세스는 종료될 때 이러한 상태로 남아있고 부모가 wait()을 호출하면 프로세스 테이블 안에 좀비 프로세스의 pid와 entry가 해제된다.   
      
   - __고아 프로세스__ :star:   
      - 부모가 wait()을 호출하지 않고 종료할 경우 자식들은 고아 프로세스로 남게된다. 즉, 부모 프로세스가 종료되었지만 자식 프로세스의 종료 상태를 회수하는 wait()을 호출하지 않고 종료했을 경우에 남게되는 자식 프로세스를 의미한다.      
      - 부모 프로세스가 자식 프로세스보다 먼저 종료되면 init 프로세스가 자식 프로세스 새로운 부모 프로세스가 된다.   
      - 종료되는 프로세스가 발생할 때 커널은 이 프로세스가 누구의 부모 프로세스인지 확인한 후, 커널이 자식 프로세스의 부모 프로세스 ID를 1(init 프로세스)로 바꿔 줍니다.   
      - 고아 프로세스가 작업을 종료하면 init 프로세스가 wait()을 호출하여 고아 프로세스의 종료 상태를 회수함으로써 좀비 프로세스가 되는것을 방지한다.   
      
   - __Linux와 UNIX는 init 프로세스를 사용하여 이러한 두 문제를 해결한다.__ :star:   
      - init 프로세스(root)를 고아 프로세스의 새로운 부모로 할당함으써 이러한 문제를 해결한다.   
      - init 프로세스는 주기적으로 wait()을 호출하여 수집되야 할 고아 프로세스들의 종료 상태를 가져오고 고아 프로세스의 pid와 프로세스 테이블 entry를 해제한다.   
      
### 3.4 Interprocess Communication(프로세스간 통신)   
   
   - __프로세스 협동을 제공하는 이유__   
      - __정보 공유(Information sharing)__   
         - 여러 사용자가 동일한 정보에 관심을 가질 수도 있으므로 이러한 정보에 병행적으로 접근할 수 있는 환경을 제공해야 한다.(공유 파일 등)   
      - __계산 가속화(Computation speedup)__   
         - 특정 작업이 더 빠르게 실행되길 원한다면, 여러 서브 작업으로 나누고 각각 다른 서브 작업들과 병렬로 실행되야 한다.   
      
      - __모듈성(Modularity)__   
         - 시스템 기능을 별도의 프로세스 또는 스레드로 나누어 모듈식 형태로 시스템을 구성하기를 원할 수 있다.   
         
      - __편의성(Convenience)__   
         - 각 사용자가 동시에 많은 작업을 할 수도 있다. (컴파일을 하면서 문서 편집, 노래 듣기 등의 병행)   
         
   - __IPC(Interprocess Communication)__ :star:   
      - 프로세스들이 정보와 데이터를 교환하게 해주는 메카니즘   
      - __공유 메모리(Shared memory)__   
         - 프로세스를 협동시킴으로써 공유된 메모리의 영역이 형성된다.   
         - 프로세스는 공유된 영역에 데이터를 쓰거나 읽음으로써 정보를 교환할 수 있다.   
         
      - __메세지 전달(Message passing)__   
         - 협동하는 프로세스 사이에서 교환된 메세지에 의해 통신이 발생한다.   
         
   - __많은 OS에서 공유 메모리, 메세지 전달 두 가지 모두 사용한다.__   
      - 메세지 전달은 어떠한 충돌도 회피할 필요가 없기 때문에, 작은 양의 데이터를 교환하는 데 유용하다. 그리고 분산 시스템에서 더 쉽게 구현될 수 있다.    
      - 메세지 전달 시스템은 시스템 호출을 사용하여 구현되었기 때문에 커널 개입 작업의 더 많은 시간 소모를 필요로 하기 때문에 메모리 공유보다 느리다.   
         - 공유 메모리는 공유된 메모리 영역을 형성하기 위한 시스템 호출만 필요하다. 그리고 공유 메모리 영역이 형성되면 모든 접근은 메모리 접근 루틴으로 다뤄진다. 그러므로 커널로부터 도움이 필요하지 않다.   
         - 하나의 시스템 안에서 통신할 때 메모리 속도로 접근하기 때문에 최대 속도와 편의성을 제공한다.   
      
   - __다수의 프로세싱 코어를 가진 시스템에서 메세지 전달이 공유 메모리보다 더 좋은 성능을 제공한다.__   
      - 공유 메모리는 여러 캐시 사이에 공유 데이터가 이동하기 때문에 캐시 일관성에 대한 문제가 있다.   
      - 시스템에 프로세싱 코어의 수가 증가할수록, 메세지 전달이 IPC에 더 적합한 메카니즘으로 볼 수 있게 된다.   
      
#### 3.4.1 Shared-Memory Systems(공유 메모리 시스템)   

   - __공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 존재한다.__   
      - 공유 메모리 세그먼트를 사용하여 통신하기를 바라는 다른 프로세스들은 반드시 이 세그먼트를 자신의 주소 공간에 추가해야한다.   
      
   - __공유 메모리는 두 개 이상의 프로세스가 다른 프로세스의 메모리에 접근을 막는 OS의 행동을 제거하기 위한 동의가 필요하다.__ :star:   
   
   - __공유된 영역의 데이터의 형식과 위치는 OS의 통제 아래 있지 않고 프로세스들에 의해 결정된다.__   
      - 프로세스들이 동시에 같은 위치에 쓰지 않도록 하는 것을 보장해야한다.   
      
   - __생산자-소비자 문제__ :star:   
      - __생산자__   
         - 정보를 생산한다.   
      - __소비자__   
         - 정보를 소비한다.   
      - 공유 메모리를 사용하여 해결할 수 있다.   
      - 생산자와 소비자 프로세스를 병행하게 실행되게 하기 위해서, 생산자에 의해 채워질 수 있고 소비자에 의해 비워질 수 있는 항목들의 이용가능한 버퍼가 반드시 필요하다.   
      - 버퍼는 생산자와 소비자에 의해 공유되는 메모리 영역에 위치한다.   
      - 생산자는 소비자가 다른 항목을 소비하는 동안 항목을 생산할 수 있다.   
         - 소비자가 생산되지 않은 항목을 소비하는 것을 시도하지 않게 하기 위해서 반드시 생산자와 소비자는 동기화되야 한다.   
         
      - __버퍼 2종류__   
         - __무한 버퍼(Unbounded buffer)__   
            - 버퍼의 크기에 제한이 없다.   
            - 소비자는 새로운 항목을 기다려야할 수도 있지만 생산자는 항상 새로운 항목을 생산할 수 있다.   
            
         - __유한 버퍼(Bounded buffer)__   
            - 고정된 크기의 버퍼    
            - 소비자는 버퍼가 비어있으면 반드시 기다려야하고 생산자는 버퍼가 꽉 차면 반드시 기다려야한다.   
            
         - __공유된 버퍼는 두 개의 논리적 포인터 in, out을 가진 원형 배열로 구현된다.__   
            - 변수 in은 버퍼안의 다음 빈 공간을 가르킨다.   
            - 변수 out은 버퍼안의 채워진 첫 번째 공간을 가르킨다.   
            - 버퍼가 비어있으면 "in == out"이고, 꽉 차 있으면 "((in+1)%BUFFER_SIZE) == out"이다.   
            
#### 3.4.2 Message-Passing Systems(메세지 전달 시스템)   

   - __같은 주소 공간을 공유하는 것 없이 프로세스들의 동작을 동기화하고 통신하게 하는 메카니즘이다.__ :star:   
      - 네트워크에 연결된 다른 컴퓨터에 있는 프로세스들이 통신하는 분산된 환경에서 특히 유용하다.   
      
   - __적어도 제공되야 하는 2가지 연산__     
      - __Send message__  
      - __Receive message__   

   - __프로세스에 의해 보내진 메세지는 고정 또는 가변 크기 있 수 있다.__   
      - 고정된 크기의 메세지가 보내지어질 수 있다면, 시스템 구현은 간단하지만 프로그래밍 작업을 더 어렵게 만든다.   
      - 가변 크기의 메세지는 더 복잡한 시스템 구현이 필요하지만 프로그래밍 작업은 더 쉬어진다.   
      
   - __통신 링크는 둘 사이에 반드시 존재해야 한다.__    
      - __링크와 send(), receive() 연산을 논리적이게 구현하기 위한 수단__   
         - 직접 또는 간접 통신(Direct or indirect communication)   
         - 동기 또는 비동기 통신(Synchronous or asynchronous communication)   
         - 자동 또는 explicit 버퍼링(Autimatic or explicit buffering)   
         
#### 3.4.2.1 Naming(명명)    
   
   - __통신을 원하는 프로세스들은 서로를 가리킬 수 있는 방법이 있어야 한다. 이 때 직접 또는 간접 통신을 사용한다.__ :star:   
      - __직접 통신__   
         - __대칭(symmetry)__   
            - 각 프로세스는 명백하게 통신의 수신자 또는 송신자의 이름을 정해야한다.   
            - 송신자 수신자 둘 다 통신하기 위해 서로의 이름을 명시해야하는 데 있어서 대칭(symmetry)을 보여준다.
               - Send(P, message) – 프로세스 P에게 메시지를 전송한다.   
               - Receive(Q, message) – 프로세스 Q로부터 메시지를 수신한다.   

            - __통신 링크 특성__   
               - 링크는 통신하길 원하는 각 프로세스 쌍 사이에 자동적으로 형성된다. 프로세스들은 통신하기 위해서 단지 서로의 정체를 확인하면 된다.   
               - 링크는 정확하게 두 프로세스과만 연관되어 있다.   
               - 각 프로세스 쌍 사이에 정확히 하나의 링크만 존재한다.   
            
         - __이러한 구조는 송신자 수신자 둘 다 통신하기 위해 서로의 이름을 명시해야하는 데 있어서 대칭(symmetry)을 보여준다.__   
         
         - __비대칭(asymmetry)__   
            - 이러한 구조의 변형은 오직 송신자가 수신자의 이름을 명시해야한다. 수신자는 송신자의 이름을 명시할 필요가 없는데 있어서 비대칭(asymmetry)를 보여준다.      
               - Send(P, message) – 프로세스 P에게 메시지를 전송한다.   
               - Receive(id, message) – 임의의 프로세스로부터 메시지를 수신한다. 변수 ID는 통신을 발생시킨 프로세스의 이름으로 설정된다.   
