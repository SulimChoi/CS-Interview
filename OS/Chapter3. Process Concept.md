# :bookmark_tabs: Operating System Concepts 9th edition      
## 3장 Process Concept   
__중요하다고 생각되는 목차에는 :star: 표시해놓았습니다.__   
__:star:되어 있는 목차를 클릭하시면 클릭하신 목차의 내용이 있는 페이지로 넘어가며__   
__해당 페이지 내에 있는 중요 개념 옆에 :star: 표시해놓았습니다.__   

__혹시 잘못된 내용이 있거나 보완해야할 점이 있으면 `issue` 해주시거나 알려주시면 감사하겠습니다.:bow:__   

* [3.Process Concept](#3process-concept)   
   - [3.1 Process Concept](#31-process-concept) :star:   
      - [3.1.1 The Process(프로세스)](#311-the-process프로세스) :star:    
      - [3.1.2 Process State(프로세스 상태)](#312-process-state프로세스-상태) :star:   
      - [3.1.3 Process Control Block(프로세스 제어 블록)](#313-process-control-block프로세스-제어-블록) :star:     
      - [3.1.4 Thread(스레드)](#314-thread스레드)   
   - [3.2 Process Scheduling](#32-process-scheduling) :star:
      - [3.2.1 Scheduling Queues(스케줄링 큐)](#321-scheduling-queues스케줄링-큐) :star:   
      - [3.2.2 Schedulers(스케줄러)](#322-schedulers스케줄러) :star:   
      - [3.2.3 Context Switching(문맥 교환)](#323-context-switching문맥-교환) :star:     
   - [3.3 Operations on Processes](#33-operations-on-processes)   
      - [3.3.1 Process Creation(프로세스 생성)](#331-process-creation프로세스-생성) :star:   
      - [3.3.2 Process Termination(프로세스 종료)](#332-process-termination프로세스-종료) :star:   
   - [3.4 Interprocess Communication(프로세스간 통신)](#34-interprocess-communication프로세스간-통신) :star:   
      - [3.4.1 Shared-Memory Systems(공유 메모리 시스템)](#341-shared-memory-systems공유-메모리-시스템) :star:   
      - [3.4.2 Message-Passing Systems(메세지 전달 시스템)](#342-message-passing-systems메세지-전달-시스템) :star:   
         - [3.4.2.1 Naming(명명)](#3421-naming명명) :star:   
         - [3.4.2.2 Synchronization(동기화)](#3422-synchronization동기화) :star:   
         - [3.4.2.3 Buffering(버퍼링)](#3423-buffering버퍼링) :star:   
   - [3.5 Examples of IPC Systems](#35-examples-of-ipc-systems)         
   - [3.6 Communication in Client-Server Systems](#36-communication-in-client-server-systems)   
      - [3.6.1 Sockets(소켓)](#361-sockets소켓) :star:     
      - [3.6.2 Remote Procedure Calls(원격 프로시저 호출)](#362-remote-procedure-calls원격-프로시저-호출) :star:   
      - [3.6.3 Pipe(파이프)](#363-pipe파이프) :star:   
         - [3.6.3.1 Ordinary Pipes(일반 파이프)](#3631-ordinary-pipes일반-파이프)   
         - [3.6.3.2 Named Pipes(지명 파이프)](#3632-named-pipes지명-파이프)   
         
## 3.Process Concept   
   
   - __Process__ :star:   
      - __현대 시분할 시스템에서 작업의 단위__   
      - __실행중인 프로그램__   
      
   - __시스템은 프로세스의 집합으로 구성__    
      - __OS 프로세스__   
         - 시스템 코드 실행   
      - __사용자 프로세스__   
         - 사용자 코드 실행    
         
### 3.1 Process Concept   

   - __batch 시스템__   
      - job을 실행시킨다.   
         - 해당 챕터에서 job은 process와 거의 같은 용어로 사용한다.   
         - 대부분의 OS 이론과 용어들은 OS의 주요 activity가 job processing일때 발전되었다.    
         - process가 job이라는 단어를 대체하기 때문에 일반적으로 받아들여지는 job scheduling 같은 단어 job을 포함하는 용어들의 사용을 피하는 것이 오해를 불러 일으킬 수도 있다.    
      
   - __시분할 시스템__   
      - 사용자 프로그램 또는 task를 가진다.   
      
#### 3.1.1 The Process(프로세스)   

   - __Process는 text 영역으로 알려진 program code뿐만 아니라 processor 레지스터의 내용과 program counter의 값에 의해 보여지는 현재 activity를 포함한다.__   
   
   - __Process in 메모리__ :star:   
      - __Stack__   
         - 함수 매개변수, 반환 주소, 지역 변수 같은 일시적 데이터   
      - __Data__   
         - 전역 변수   
      - __Heap__    
         - Process 실행 동안 동적으로 할당된 메모리   
      - __Text__   
         - Program code   
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_1_Process_Memory.jpg" height = 300px title="3_1_Process_Memory" alt="3_1_Process_Memory"></img><br><strong>3.1 프로세스의 메모리 구조</strong></p>  
      
   - __Program = 수동적 개체__   
      - ex) 디스크에 저장된 명령어 목록을 가진 파일 (= 실행가능한 파일)   
   
   - __Process = 능동적 개체__   
      - ex) 실행할 다음 명령어를 명시하는 Program counter를 가지고 있으며 관련된 자원의 집합을 포함한다.    
      
   - __실행가능한 파일이 메모리로 적재될 때 Program은 Process가 된다.__ :star:   
      - 실행 시키는 방법   
         - 아이콘 더블 클릭   
         - 명령어 라인에서 실행가능한 파일 이름 입력, 엔터   
         
   - __두 개의 Process가 같은 Program과 관련이 있더라도, 두 개의 분리된 실행으로 고려된다.__ :star:   
      - ex) 다수의 사용자가 하나의 메일 프로그램을 여러 개 실행 또는 한 사용자가 하나의 웹브라우저 프로그램을 여러 개 실행할 경우, 각각의 분리된 Process이다.   
      - __Text 영역은 같지만 Stack, Data, Heap 영역은 다르다__   
      
   - __프로세스 자체가 다른 코드를 위한 실행 환경이 될 수 있다.__   
      - ex) Java 프로그래밍 환경   
         - 실행가능한 Java 프로그램은 JVM 내에서 실행된다.   
         - JVM은 적재된 Java 코드를 해석하고 그 코드를 위해서 기계 언어를 통해 그 코드를 실행하는 프로세스로서 실행된다.   
         
#### 3.1.2 Process State(프로세스 상태)   

   - __Process 상태__ :star:   
      - __New__   
         - Process가 생성된 상태   
      - __Running__   
         - 명령어가 실행중인 상태   
      - __Waiting__   
         - Process가 일부 event를 위해 입출력 완료 또는 신호를 기다림과 같은 어떤 사건이 발생하기를 기다리는 상태
      - __Ready__   
         - Processor에 할당되기를 기다리는 상태   
      - __Terminated__   
         - Process의 실행이 종료된 상태   
      
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_2_ProcessState.jpg" width = 600px height = 250px title="3_2_ProcessState" alt="3_2_ProcessState"></img><br><strong>3.2 프로세스 상태</strong></p>  
      
#### 3.1.3 Process Control Block(프로세스 제어 블록)   

   - __각 Process는 PCB에 의해서 OS안에 표현된다.__   
      - PCB를 Task Control Block이라고도 한다.   
      
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_3_PCB.jpg" height = 250px title="3_3_PCB" alt="3_3_PCB"></img><br><strong>3.3 프로세스 제어 블록</strong></p>  
      
   - __PCB가 가진 정보__ :star:   
      - __프로세스 상태(Process state)__   
         - New, Ready, Running, Waiting(Halted)상태 등이 있다.   
      - __프로그램 카운터(Program counter)__   
         - 프로세스를 위해 실행되어야 할 다음 명령어의 주소를 가리킨다.   
      - __CPU 레지스터(CPU register)__   
         - 컴퓨터 구조에 따라 종류와 수가 다르다.   
         - 누산기(accumulator), 색인 레지스터(index register), 스택 레지스터(stack register), 범용 레지스터(general-purpose register), 상태 코드 정보(condition-code information)를 포함한다.   
         - Program Counter와 함께 상태 정보는 나중에 프로세스가 계속 올바르게 수행되도록 하기 위해서 인터럽트 발생시마다 반드시 저장되어야 한다.   
      - __CPU-스케줄링 정보(CPU-scheduling information)__   
         - 프로세스 우선순위, 스케줄링 큐를 위한 포인터, 다른 스케줄링 파라미터를 포함한다.   
      - __메모리-관리 정보(Memory-management information)__   
         - OS에 의해 사용되는 메모리 시스템에 따라 Segment table 또는 Page table과 base register, limit register의 값 같은 항목을 포함한다.   
      - __계산 정보(Accounting information)__   
         - CPU의 수, 사용된 시간, 시간 제한, 계정 정보, 작업(job) 또는 프로세스 번호 등을 포함한다.   
      - __입출력 상태 정보(I/O status information)__   
         - 프로세스에 할당된 일출력 장치들과 열린 파일의 목록 등을 포함   
      
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_4_ProcessSwitch.jpg" height = 500px title="3_4_ProcessSwitch" alt="3_4_ProcessSwitch"></img><br><strong>3.4 프로세스간 CPU 전환</strong></p>    

#### 3.1.4 Thread(스레드)   
   
   - __단일 스레드는 프로세스가 한번에 하나의 작업만 수행할 수 있게 한다.__   
   
   - __현대 OS는 프로세스가 다수의 스레드를 가질 수 있게 하고 한번에 하나 이상의 작업을 수행할 수 있게 한다.__   
      - 멀티 코어 시스템에서 효율적이다.   
      
   - __이러한 다수의 스레드를 지원하기 위해 시스템에서 PCB는 각 스레드를 위한 정보도 포함한다.__ :star:   
   
### 3.2 Process Scheduling   

   - __멀티 프로그래밍의 목적__   
      - 항상 어떤 프로세스가 실행되게하여 CPU의 사용을 최대화하는데 있다.   
      
   - __시분할의 목적__   
      - Process들 사이에 빈번하게 CPU를 변경해주어 각 프로그램이 실행되는 동안 사용자가 각 프로그램과 교류할 수 있게 하기 위해서이다.   
      
   - __이러한 목적을 달성하기 위해서 Process Scheduler가 존재하며, Process Scheduler는 CPU에서 프로그램 실행을 시키기 위해 이용가능한 프로세스들 중 하나의 프로세스를 선택한다.__   
      - 단일 처리기 시스템의 경우, 실행 중인 프로세스가 한 개 이상 있을 수 없다. 만약 단일 처리기에 여러 프로세스들이 있다면 프로세스들은 CPU가 작업이 끝날 때까지 대기하여야 한다.   
      
#### 3.2.1 Scheduling Queues(스케줄링 큐)   
   
   - __스케줄링 큐의 종류__ :star:   
      - __작업 큐(Job queue)__  
         - 프로세스가 시스템에 들어오면 작업 큐에 놓여 진다.   
         - 시스템에 있는 모든 프로세스로 구성된다.   

      - __준비 완료 큐(ready queue)__   
         - 메인 메모리에 있고 준비 완료되고 실행되기를 기다리는 프로세스들은 준비 완료 큐에 저장되어 있다.   
         - 연결 리스트로 저장되어 있다.   
         - 준비 완료 큐의 헤더는 연결 리스트의 첫 번째와 마지막 PCB를 가리키는 포인터를 포함한다.   
         - 각 PCB는 준비 완료 큐에서 다음 PCB를 가리키는 포인터 필드를 가진다.   
         
      - __장치 큐(Device queue)__   
         - 특정 입출력 장치를 위해 기다리고 있는 프로세스들의 목록    
         - 각 장치는 자신 고유의 장치 큐를 가진다.   
         
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_5_Queues.jpg" height = 500px title="3_5_Queues" alt="3_5_Queues"></img><br><strong>3.5 준비 큐와 다양한 입출력 장치 큐</strong></p>     
      
   - __새로운 프로세스는 초기에 ready queue에 넣어지고 실행을 위해 선택되기 전 또는 dispatched 될 때까지 대기한다.__   
      - __dispatch__ :star:   
         - 준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것, 즉 준비 상태에서 실행 상태로 바뀌는 것   
         - dispatch : ready → running   
   
   - __프로세스가 CPU에 할당되면 프로세스는 실행되고 아래의 event들 중 하나가 발생할 수 있다.__   
      __1. 입출력 요청을 하고 입출력 큐로 들어간다.__   
      __2. 자식 프로세스를 생성하고 자식이 종료될 때까지 기다린다.__   
      __3. 인터럽트의 결과로 CPU로부터 강제적으로 제거되고 ready queue에 다시 놓여진다.__   
      
      - __1~2는 프로세스가 결국 Wait -> ready 상태로 바뀌고 ready queue에 다시 놓여진다.__   
      - __프로세스는 종료될 때까지 이러한 cycle을 계속한다.__   
         - 프로세스가 모든 queue로부터 제거되고 각 PCB와 자원이 해제되는 순간 종료된다.   
      
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_6_QueueingDiagram.jpg" title="3_6_QueueingDiagram" alt="3_6_QueueingDiagram"></img><br><strong>3.6 큐잉 다이어그램을 통한 프로세스 스케줄링 표현 </strong></p>   
      
#### 3.2.2 Schedulers(스케줄러)   

   - __batch 시스템의 경우, 즉시 실행될 수 있는 프로세스보다 더 많은 프로세스가 요청 되어진다.__   
      - 이러한 프로세스들은 나중에 실행되기 위해서 거대한 저장 장치에 저장(spool)된다.   
      
   - __장기 스케줄러(= 작업 스케줄러)__ :star:   
      - 이러한 pool(거대한 저장 장치)에서 프로세스를 선택하고 실행을 위해 메모리로 적재한다.   
      
   - __단기 스케줄러(= CPU 스케줄러)__ :star:   
      - 실행할 준비가 된 프로세스들 중 선택하여 CPU에 할당한다.   
      
   - __장기 스케줄러와 단기 스케줄러의 차이점__ :star:   
      - __실행 빈도__    
         - __단기 스케줄러__   
            - CPU를 위해 반드시 빈번한게 새로운 프로세스를 선택해야 한다.    
               - ex) 아주 작은 시간동안만 실행한 후 입출력 요청을 하는 프로세스가 있을 경우 다른 프로세스를 선택해야한다.    
            - 단기 스케줄러는 적어도 100 milliseconds마다 실행한다.   
            - 단기 스케줄러는 실행 간격이 짧기 때문에 반드시 빨라야 한다.   
               - ex) 100 milliseconds 동안 실행되는 프로세스를 실행하기 위해 결정하는데 10 milliseconds가 걸린다면,   
               - (100+10) / 10 = 9% 의 CPU가 작업을 스케줄링 하기 위해서 낭비되어진다.   
               
         - __장기 스케줄러__   
            - 실행 빈도가 훨씬 적다.   
            - 멀티 프로그래밍의 정도(메모리 안에 있는 프로세스들의 수)를 제어한다.   
            - 멀티 프로그래밍의 정도가 안정되면, 프로세스 평균 생성률은 시스템은 나가는 프로세스의 평균률과 반드시 같아진다.   
            - 장기 스케줄러는 프로세스가 시스템을 나갈 때만 호출되어야 할 수도 있다.   
            - 실행 간격이 더 크기 때문에, 장기 스케줄러는 실행할 프로세스를 선택하는데 더 많은 시간을 사용해도 된다.   
               
               
   - __대부분의 프로세스는 입출력 중심 또는 CPU 중심으로 기술된다.__ :star:      
      - __입출력 중심 프로세스__   
         - 연산을 하는 것보다 입출력에 시간을 더 소비하는 프로세스   
         
      - __CPU 프로세스__   
         - 연산에 시간을 더 사용하면 입출력 요청을 드물게 발생시키는 프로세스   
         
   - __장기 스케줄러가 입출력 중심과 CPU 중심 프로세스들의 적절하게 섞인 프로세스를 선택하는 것이 중요하다.__   
      - 모든 프로세스가 입출력 중심일 경우   
         - ready queue는 거의 항상 비어있게 되고, 단기 스케줄러가 해야할 일은 거의 없다.   
      - 모든 프로세스가 CPU 중심일 경우   
         - 입출력 대기 큐는 거의 항상 비어있게 되고, 장치들은 사용되지 않으며 시스템은 다시 균형을 잃게 된다.   
         
      - __최고의 성능을 가진 시스템은 CPU 중심과 입출력 중심 프로세스들의 조합을 가질 것이다.__   
      
   - __일부 시스템에서는 장기 스케줄러가 없거나 아주 작을 수 있다.__   
      - 시분할 시스템(UNIX, MS Window)는 장기 스케줄러가 없지만 단기 스케줄러를 위해 모든 새로운 프로세스를 메모리에 넣는다.   
      - 이러한 시스템의 안정성은 이용가능한 터미널 수와 같은 물리적인 제한 또는 사용자의 조정 능력에 달려있다.   
         - ex) 멀티 사용자 시스템에서 성능이 허용할 수 없을 정도로 하락하면, 사용자는 그냥 종료할 것이다.   
      - 시분할 시스템과 같은 OS는 중기 스케줄링을 도입할 수도 있다.   
      
   - __중기 스케줄러__ :star:   
      - 메모리로부터 프로세스를 제거하는 것이 이점이 될 수 있고 멀티프로그래밍의 정도를 줄일 수 있다.   
      - __스와핑__     
         - 메모리에서 프로세스들을 제거한 다음 차후 실행 시 다시 메모리에 프로세스를 불러와서 중단되었던 시점부터 실행을 재개한다.   
         - 프로세스 중기 스케줄러에 의해 swap out, swap in 된다.   
         - 스와핑은 프로세스 조합을 향상시키거나 메모리 요구 사항에서의 변화가 이용가능한 메모리보다 초과할당했을 때 필수적일 수 있다.   
         
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_6_QueueingDiagram.jpg" title="3_7_QueueingDiagram2" alt="3_7_QueueingDiagram2"></img><br><strong>3.7 큐잉 다이어그램에 중기 스케줄러 추가</strong></p>   
         
#### 3.2.3 Context Switching(문맥 교환)   
   
   - __인터럽트는 OS가 현재 작업으로터 CPU를 변경하고 커널 루틴을 실행하게 한다.__   
      - 인터럽트가 발생하면, CPU에서 실행하는 프로세스의 현재 문맥를 저장하고 나중에 해당 문맥를 복구한다. 본질적으로 프로세스를 중단하고 재개하는 것이다.   
      - 문맥은 프로세스의 PCB에 표시된다.   
         - CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보를 포함한다.   
         
      - 일반적으로 CPU의 현재 상태를 저장하고 실행을 재개하기 위해 상태 복구를 한다.   
      - __문맥 교환__ :star:      
         - __다른 프로세스로 CPU를 전환하는 것은 현재 프로세스의 상태 저장과 다른 프로세스의 상태 복구 수행하는 작업__   
         - __문맥 교환이 발생하면, 커널은 PCB에 현재(오래된) 프로세스의 문맥을 저장하고 스케줄된 새로운 프로세스의 저장된 문맥을 불러온다.__   
         - __문맥 교환이 일어날 동안 시스템은 어떠한 유용한 작업도 할 수 없기 때문에 문맥 교환 시간은 순수 오버헤드로 간주된다.__   
         - 문맥 교환 속도는 메모리 속도, 복사되어야 하는 레지스터의 수, 특수 명령어의 존재(모든 레지스터를 저장 또는 불러오기 위한 단일 명령어) 등의 machine에 따라 다르다.   
         - 일반적인 스피드는 아주 적은 milliseconds이다.   
         - __문맥 교환 시간은 하드웨어 매우 의존적이다.__   
            - 여러 레지스터 집합을 제공하는 프로세서가 있을 경우   
               - 문맥 교환은 단순히 현재 레지스터 집합으로 포인터를 변경하는 것을 요구한다.   
               - 만약 레지스터 집합보다 더 많은 active 프로세스가 있다면, 시스템은 메모리와 복사된 레지스터 데이터를 주고받는데 의지하게 된다.   
               - OS가 복잡할수록 문맥 교환동안 반드시 처리되어야 하는 작업의 양이 커진다.   
               
### 3.3 Operations on Processes   
#### 3.3.1 Process Creation(프로세스 생성)   

   - __대부분의 시스템에서 프로세스는 병행 실행될 수 있고 동적으로 생성, 제거될 수 있다.__    
   
   - __프로세스는 실행 도중에 프로세스 생성 시스템 호출을 통해서 여러 개의 새로운 프로세스들을 생성 할 수 있다.__ :star:   
      - __부모 프로세스__   
         - 생성하는 프로세스   
      - __자식 프로세스__   
         - 생성되는 새로운 프로세스   
      - __새로운 프로세스들은 다시 새로운 프로세스들을 생성할 수 있으며 그 결과 트리 구조의 프로세스가 형성 된다.__    
      
   - __대부분 OS는 고유한 프로세스 식별자(PID)에 의해 프로세스를 구분하며 식별자는 정수이다.__   
      - PID는 커널안의 프로세스의 다양한 속성에 접근하기 위해 index로 사용될 수 있다.   
      
   - __프로세스가 자식 프로세스를 생성할 때, 자식 프로세스는 작업을 수행하기 위해 CPU 시간, 메모리, 파일, 입출력 장치 같은 특정한 자원들이 필요하다.__   
   
   - __자식 프로세스가 자원을 얻는 방법__    
      __1. OS로부터 직접 자원을 받음__   
      __2. 부모 프로세스의 자원의 일부분을 부모 프로세스로부터 받음__   
      
      - 부모 프로세스는 자식들에게 자원을 분할하거나 자식들과 메모리 또는 파일과 같은 일부 자원을 공유할 수 있어야한다.   
      - 부모 자원을 자식에게 제한하는 것은 너무 많은 자식 프로세스를 생성함으로써 시스템이 부하를 받는 것을 막을 수 있다.   
   
   - __물리적, 논리적 자원을 제공하는 데 있어서 부모 프로세스는 초기 설정 데이터(input)를 자식 프로세스로 넘겨줄지도 모른다.__   
      - ex) image.jpg 파일의 내용을 터미널의 화면에 보여주는 기능을 하는 프로세스   
      - 프로세스가 생성될 때, 부모 프로세스로부터 input으로 image.jpg 파일의 이름, 출력 장치의 이름을 얻게 된다.   
      - 파일 이름을 사용하여, 파일을 열고 내용을 작성한다.   
      
      - 일부 OS는 자식 프로세스에 자원을 넘겨준다.   
         - 새로운 프로세스는 image.jpg와 터미널 장치 두 열린 파일을 받을 수 있고 둘 사이에 datum를 전송할 수 있다.   
         
   - __프로세스가 새로운 프로세스를 생성할 때 실행 관련 두 가지 가능성__   
      __1. 부모는 계속해서 자식과 병렬로 실행된다.__   
      __2. 부모는 일부 또는 모든 자식이 종료될 때까지 기다린다.__   
      
   - __새로운 프로세스를 위한 두 가지 주소 공간 가능성__   
      __1. 자식 프로세스는 부모 프로세스의 복사본이다.(같은 프로그램과 데이터를 가진다.)__   
      __2. 자식 프로세스는 자신에게 적재 될 새로운 프로그램을 가진다.__   
      
   - __UNIX에서 자식 프로세스는 부모 프로세스의 주소 공간의 복사본이다.__   
      - 부모가 자식과 통신을 쉽게 할 수 있다.   
      - 두 프로세스가 실행을 계속한다.   
      - fork()의 return 코드는 새로운 자식 프로세스일 경우 0이고 자식의 nonzero인 프로세스 식별자는 부모에게 return된다.    
      
   - __fork()후에 두 프로세스 중 하나는 프로세스의 메모리 공간을 새로운 프로그램으로 대체하기 위해서 exec() 시스템 호출을 사용한다.__   
      - exec()은 이진 파일을 메모리로 불러오고 (exec()이 가지고 있는 프로그램의 메모리 이미지를 파괴하면서) 실행을 시작한다.   
      - 이러한 방식에서 두 프로세스는 통신할 수 있고 각자 분리된 방식으로 진행된다.   
   
   - __자식이 실행되는 동안 부모가 할 게 없을 경우, 자식이 종료될 때까지 자신을 ready queue로 이동시키기 위해 wait()을 발행한다.__   
   
   - __프로세스의 주소 공간을 새로운 프로그램으로 덮어씌우는 exec()때문에, exec()는 에러가 발생하지 않는한 통제권을 반환하지 않는다.__   
   
   - __자식 프로세스는 부모 프로세스로부터 권한, 스케줄링 속성을 상속받는다.__   
   
   <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_10_ProcessCreation.jpg" title="3_10_ProcessCreation" alt="3_10_ProcessCreation"></img><br><strong>3.10 fork()를 사용한 프로세스 생성 </strong></p>   
   
#### 3.3.2 Process Termination(프로세스 종료)   

   - __프로세스는 마지막 명령문을 마칠 때 종료되고 exit() 시스템 호출을 사용하여 OS에게 프로세스 삭제를 요청한다.__   
      - 이 시점에서, 프로세스는 부모 프로세스에게 wait()을 통해 상태 값을 반환할 수 있다.   
      - 물리, 논리 메모리, 열린 파일, 입출력 버퍼를 포함한 모든 자원이 OS에 의해 해제된다.   
      
   - __프로세스는 시스템 호출을 통해 다른 프로세스를 종료시킬 수 있다.__   
      - 종료될 프로세스의 부모에 의해서만 이러한 시스템 호출이 가능하다.   
      
   - __부모가 자식의 실행을 종료하는 이유__ :star:   
      - 자식이 할당받은 자원의 사용을 초과했을 경우    
      - 자식에게 할당된 task가 더 이상 필요하지 않을 경우   
      - 부모가 종료하는데, 부모가 종료한 후 OS가 자식이 계속 실행되게 허용하지 않는 경우   
      
   - __일부 시스템에서는 부모 프로세스가 종료된 이후 자식 프로세스가 존재할 수 없다.__ :star:     
      - __연속적 종료(Cascading Termination)__   
         - 부모 프로세스가 종료되면, 모든 자식 프로세스들은 종료되어야 한다.   
         - OS가 직접 수행한다.   
         
   - __일반적인 종료에서 exit()은 직접적으로 또는 간접적(main의 return)으로 호출될 수 있다.__   
   
   - __부모는 wait()을 사용함으로써 자식이 종료될 때까지 기다릴 수 있다.__   
      - wait()은 부모가 자식의 종료 상태를 얻을 수 있는 파라미터가 전달되어진다.   
      - wait()은 종료된 자식의 pid를 반환하여 부모가 어느 자식이 종료되었는지 알 수 있다.   
      
   - __프로세스가 종료되면, 자원들은 OS에 의해 해제된다.__   
      - 자식 프로세스가 종료된 이후에 부모 프로세스가 자식 프로세스의 상태를 알고 싶을 수 있기 때문에 커널은 자식 프로세스가 종료되더라도 최소한의 정보(프로세스 ID, 프로세스 종료 상태 등)를 가지고 있게 된다. 그러므로 프로세스 테이블에 있는 해당 자식 entry는 부모가 wait()을 호출할 때 까지 남아있어야만 한다.   
      - 프로세스 테이블은 프로세스의 종료 상태를 포함하기 때문이다.   
      
   - __좀비 프로세스__ :star:   
      - 부모가 wait()을 아직 호출하지 않은 자식 프로세스, 즉, 자식 프로세스가 종료되었지만 부모 프로세스가 wait()을 통해 아직 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 자식 프로세스를 의미한다.   
      - 모든 자식 프로세스는 종료될 때 이러한 상태로 남아있고 부모가 wait()을 호출하면 프로세스 테이블 안에 좀비 프로세스의 pid와 entry가 해제된다.   
      
   - __고아 프로세스__ :star:   
      - 부모가 wait()을 호출하지 않고 종료할 경우 자식들은 고아 프로세스로 남게된다. 즉, 부모 프로세스가 종료되었지만 자식 프로세스의 종료 상태를 회수하는 wait()을 호출하지 않고 종료했을 경우에 남게되는 자식 프로세스를 의미한다.      
      - 부모 프로세스가 자식 프로세스보다 먼저 종료되면 init 프로세스가 자식 프로세스 새로운 부모 프로세스가 된다.   
      - 종료되는 프로세스가 발생할 때 커널은 이 프로세스가 누구의 부모 프로세스인지 확인한 후, 커널이 자식 프로세스의 부모 프로세스 ID를 1(init 프로세스)로 바꿔 줍니다.   
      - 고아 프로세스가 작업을 종료하면 init 프로세스가 wait()을 호출하여 고아 프로세스의 종료 상태를 회수함으로써 좀비 프로세스가 되는것을 방지한다.   
      
   - __Linux와 UNIX는 init 프로세스를 사용하여 이러한 두 문제를 해결한다.__ :star:   
      - init 프로세스(root)를 고아 프로세스의 새로운 부모로 할당함으써 이러한 문제를 해결한다.   
      - init 프로세스는 주기적으로 wait()을 호출하여 수집되야 할 고아 프로세스들의 종료 상태를 가져오고 고아 프로세스의 pid와 프로세스 테이블 entry를 해제한다.   
      
### 3.4 Interprocess Communication(프로세스간 통신)   
   
   - __프로세스 협동을 제공하는 이유__   
      - __정보 공유(Information sharing)__   
         - 여러 사용자가 동일한 정보에 관심을 가질 수도 있으므로 이러한 정보에 병행적으로 접근할 수 있는 환경을 제공해야 한다.(공유 파일 등)   
      - __계산 가속화(Computation speedup)__   
         - 특정 작업이 더 빠르게 실행되길 원한다면, 여러 서브 작업으로 나누고 각각 다른 서브 작업들과 병렬로 실행되야 한다.   
      
      - __모듈성(Modularity)__   
         - 시스템 기능을 별도의 프로세스 또는 스레드로 나누어 모듈식 형태로 시스템을 구성하기를 원할 수 있다.   
         
      - __편의성(Convenience)__   
         - 각 사용자가 동시에 많은 작업을 할 수도 있다. (컴파일을 하면서 문서 편집, 노래 듣기 등의 병행)   
         
   - __IPC(Interprocess Communication)__ :star:   
      - 프로세스들이 정보와 데이터를 교환하게 해주는 메카니즘   
      - __공유 메모리(Shared memory)__   
         - 프로세스를 협동시킴으로써 공유된 메모리의 영역이 형성된다.   
         - 프로세스는 공유된 영역에 데이터를 쓰거나 읽음으로써 정보를 교환할 수 있다.   
         
      - __메세지 전달(Message passing)__   
         - 협동하는 프로세스 사이에서 교환된 메세지에 의해 통신이 발생한다.   
         
      <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_12_CommunicationsModels.jpg" title="3_12_CommunicationsModels" alt="3_12_CommunicationsModels"></img><br><strong>3.12 통신 모델 </strong><br>(a) 메시지 전달 (b) 공유 메모리 
      </p>   
         
   - __많은 OS에서 공유 메모리, 메세지 전달 두 가지 모두 사용한다.__   
      - 메세지 전달은 어떠한 충돌도 회피할 필요가 없기 때문에, 작은 양의 데이터를 교환하는 데 유용하다. 그리고 분산 시스템에서 더 쉽게 구현될 수 있다.    
      - 메세지 전달 시스템은 시스템 호출을 사용하여 구현되었기 때문에 커널 개입 작업의 더 많은 시간 소모를 필요로 하기 때문에 메모리 공유보다 느리다.   
         - 공유 메모리는 공유된 메모리 영역을 형성하기 위한 시스템 호출만 필요하다. 그리고 공유 메모리 영역이 형성되면 모든 접근은 메모리 접근 루틴으로 다뤄진다. 그러므로 커널로부터 도움이 필요하지 않다.   
         - 하나의 시스템 안에서 통신할 때 메모리 속도로 접근하기 때문에 최대 속도와 편의성을 제공한다.   
      
   - __다수의 프로세싱 코어를 가진 시스템에서 메세지 전달이 공유 메모리보다 더 좋은 성능을 제공한다.__   
      - 공유 메모리는 여러 캐시 사이에 공유 데이터가 이동하기 때문에 캐시 일관성에 대한 문제가 있다.   
      - 시스템에 프로세싱 코어의 수가 증가할수록, 메세지 전달이 IPC에 더 적합한 메카니즘으로 볼 수 있게 된다.   
      
#### 3.4.1 Shared-Memory Systems(공유 메모리 시스템)   

   - __공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 존재한다.__   
      - 공유 메모리 세그먼트를 사용하여 통신하기를 바라는 다른 프로세스들은 반드시 이 세그먼트를 자신의 주소 공간에 추가해야한다.   
      
   - __공유 메모리는 두 개 이상의 프로세스가 다른 프로세스의 메모리에 접근을 막는 OS의 행동을 제거하기 위한 동의가 필요하다.__ :star:   
   
   - __공유된 영역의 데이터의 형식과 위치는 OS의 통제 아래 있지 않고 프로세스들에 의해 결정된다.__   
      - 프로세스들이 동시에 같은 위치에 쓰지 않도록 하는 것을 보장해야한다.   
      
   - __생산자-소비자 문제__ :star:   
      - __생산자__   
         - 정보를 생산한다.   
      - __소비자__   
         - 정보를 소비한다.   
      - 공유 메모리를 사용하여 해결할 수 있다.   
      - 생산자와 소비자 프로세스를 병행하게 실행되게 하기 위해서, 생산자에 의해 채워질 수 있고 소비자에 의해 비워질 수 있는 항목들의 이용가능한 버퍼가 반드시 필요하다.   
      - 버퍼는 생산자와 소비자에 의해 공유되는 메모리 영역에 위치한다.   
      - 생산자는 소비자가 다른 항목을 소비하는 동안 항목을 생산할 수 있다.   
         - 소비자가 생산되지 않은 항목을 소비하는 것을 시도하지 않게 하기 위해서 반드시 생산자와 소비자는 동기화되야 한다.   
         
      - __버퍼 2종류__   
         - __무한 버퍼(Unbounded buffer)__   
            - 버퍼의 크기에 제한이 없다.   
            - 소비자는 새로운 항목을 기다려야할 수도 있지만 생산자는 항상 새로운 항목을 생산할 수 있다.   
            
         - __유한 버퍼(Bounded buffer)__   
            - 고정된 크기의 버퍼    
            - 소비자는 버퍼가 비어있으면 반드시 기다려야하고 생산자는 버퍼가 꽉 차면 반드시 기다려야한다.   
            
         - __공유된 버퍼는 두 개의 논리적 포인터 in, out을 가진 원형 배열로 구현된다.__   
            - 변수 in은 버퍼안의 다음 빈 공간을 가르킨다.   
            - 변수 out은 버퍼안의 채워진 첫 번째 공간을 가르킨다.   
            - 버퍼가 비어있으면 "in == out"이고, 꽉 차 있으면 "((in+1)%BUFFER_SIZE) == out"이다.   
            
#### 3.4.2 Message-Passing Systems(메세지 전달 시스템)   

   - __같은 주소 공간을 공유하는 것 없이 프로세스들의 동작을 동기화하고 통신하게 하는 메카니즘이다.__ :star:   
      - 네트워크에 연결된 다른 컴퓨터에 있는 프로세스들이 통신하는 분산된 환경에서 특히 유용하다.   
      
   - __적어도 제공되야 하는 2가지 연산__     
      - __Send message__  
      - __Receive message__   

   - __프로세스에 의해 보내진 메세지는 고정 또는 가변 크기 있 수 있다.__   
      - 고정된 크기의 메세지가 보내지어질 수 있다면, 시스템 구현은 간단하지만 프로그래밍 작업을 더 어렵게 만든다.   
      - 가변 크기의 메세지는 더 복잡한 시스템 구현이 필요하지만 프로그래밍 작업은 더 쉬어진다.   
      
   - __통신 링크는 둘 사이에 반드시 존재해야 한다.__    
      - __링크와 send(), receive() 연산을 논리적이게 구현하기 위한 수단__   
         - 직접 또는 간접 통신(Direct or indirect communication)   
         - 동기 또는 비동기 통신(Synchronous or asynchronous communication)   
         - 자동 또는 explicit 버퍼링(Autimatic or explicit buffering)   
         
#### 3.4.2.1 Naming(명명)    
   
   - __통신을 원하는 프로세스들은 서로를 가리킬 수 있는 방법이 있어야 한다. 이 때 직접 또는 간접 통신을 사용한다.__ :star:   
      - __직접 통신__   
         - __대칭(symmetry)__   
            - 각 프로세스는 명백하게 통신의 수신자 또는 송신자의 이름을 정해야한다.   
            - 송신자 수신자 둘 다 통신하기 위해 서로의 이름을 명시해야하는 데 있어서 대칭(symmetry)을 보여준다.
               - Send(P, message) – 프로세스 P에게 메시지를 전송한다.   
               - Receive(Q, message) – 프로세스 Q로부터 메시지를 수신한다.   

            - __통신 링크 특성__   
               - 링크는 통신하길 원하는 각 프로세스 쌍 사이에 자동적으로 형성된다. 프로세스들은 통신하기 위해서 단지 서로의 정체를 확인하면 된다.   
               - 링크는 정확하게 두 프로세스과만 연관되어 있다.   
               - 각 프로세스 쌍 사이에 정확히 하나의 링크만 존재한다.   
            
         - __이러한 구조는 송신자 수신자 둘 다 통신하기 위해 서로의 이름을 명시해야하는 데 있어서 대칭(symmetry)을 보여준다.__   
         
         - __비대칭(asymmetry)__   
            - 이러한 구조의 변형은 오직 송신자가 수신자의 이름을 명시해야한다. 수신자는 송신자의 이름을 명시할 필요가 없는데 있어서 비대칭(asymmetry)를 보여준다.      
               - Send(P, message) – 프로세스 P에게 메시지를 전송한다.   
               - Receive(id, message) – 임의의 프로세스로부터 메시지를 수신한다. 변수 ID는 통신을 발생시킨 프로세스의 이름으로 설정된다.   
         - __직접 통신의 단점__   
            - 프로세스 정의의 제한된 모듈성   
            - 프로세스 식별자를 변경하면 다른 모든 프로세스 정의를 검사할 필요가 있을 수 있다.   
               - 오래된 식별자에 대한 모든 참조가 발견되어야하고 새로운 식별자로 수정되어야 한다.   
            - 식별자가 명백하게 명시된 hand-coding 기술은 비간접과 연관된 기술보다 덜 바람직하다.   
            
      - __간접 통신__    
         - 메세지는 메일 박스 또는 포트로부터 송신되고 수신된다.   
            - 메일 박스는 어느 메세지가 프로세스에 의해 놓일 수 있고 어느 메세지가 제거될 수 있는지에 대한 객체로서 추상적으로 보여질 수 있다.   
            - 각 메일 박스는 고유한 식별자를 가진다.    
            - 두 프로세스는 오직 공유된 메일박스가 있어야만 통신이 가능하다.   
               - Send(A, message) – 메일박스 A로 메시지를 전송한다.   
               - Receive(A, message) – 메일박스 A로부터 메시지를 수신한다.   
            
            - __통신 링크 특성__   
               - 링크는 프로세스들의 쌍 사이에서 두 멤버가 공유된 메일박스를 가지고 있어야만 형성된다.   
               - 링크는 두 개 이상의 프로세스들과 연관될 수 있다.   
               - 통신하는 프로세스들 각 쌍 사이에서 다수의 서로 다른 연결이 존재할 수 있고 각 연결은 하나의 메일 박스에 대응된다.    
               
               - ex) P1, P2, P3가 메일박스 A를 공유한다고 가정   
                  - P2, P3가 A로부터 메세지를 받는 receive()를 실행하는 동안 P1이 A로 메세지를 보낸다면 어떤 프로세스가 P1이 보낸 메세지를 받는가?   
                  - 결과는 아래의 방법에 따라 다르다.   
                     - 링크가 최대 두 개의 프로세스하고만 연결되게 한다.   
                     - 한번에 최대 한 프로세스만 receive()를 실행할 수 있게 한다.   
                     - 시스템이 어느 P가 메세지를 받을 것인지 마음대로 선택하게 한다.   
                        - P2 또는 P3 또는 둘 다 메세지를 받을 수 없을 수도 있다.   
                     - 시스템은 어느 P가 메세지를 받는지 선택하기 위해서 알고리즘을 정의할지도 모른다.   
                        - round robin 방식으로 프로세스들이 차례로 메세지를 받게 하게 정의   
                        - 시스템은 송신자를 위해 수신자를 확인해야할지도 모른다.   
                        
            - __메일 박스는 프로세스 또는 OS에 의해 소유될 수 있다.__   
               - __프로세스에 의해 소유될 경우__   
                  - 메일 박스는 프로세스의 주소 공간의 일부분이다.   
                  - 소유자(메세지 수신자)와 사용자(메세지 송신자)를 구별해야 한다.    
                  - 각 메일 박스는 고유 소유자를 가지기 때문에 어느 프로세스가 메일박스에 보내진 메세지를 받을지에 대한 혼란이 없다.   
                  - 메일박스를 소유한 프로세스가 종료될 때, 메일박스는 사라진다.   
                  - 메일박스가 사라지고 해당 메일박스에 메세지를 보내는 프로세스는 메일박스가 더 이상 존재하지 않다고 고지받는다.   
                  
               - __OS에 의해 소유될 경우__   
                  - 메일박스는 자신 고유의 실체를 가진다.   
                  - 독립적이고 어떠한 특정 프로세스에 연관되어 있지 않다.   
                  - OS는 프로세스가 아래의 작업을 하게하는 메카니즘을 제공해야한다.   
                     - 메일박스 생성   
                     - 메일박스를 통한 메세지 송수신   
                     - 메일박스 삭제   
                  - 새로운 메일박스를 생성한 프로세스는 메일박스의 소유자가 된다.   
                  - 소유자는 메일박스를 통해 메세지를 받을 수 있는 프로세스이지만 소유권과 메세지 받는 권한은 적절한 시스템 호출을 통해 다른 프로세스 전달 될 수 있다.   
                  - 이러한 제공은 각 메일박스가 다수의 수신자를 가지게 한다.   
                  
#### 3.4.2.2 Synchronization(동기화)   
   
   - __메세지 전달에는 blocking 또는 nonblocking 방식이 있고 synchronous(동기) 또는 asynchronous(비동기)로 알려져 있다.__ :star:   
      - __Blocking sending(동기식 송신)__   
         - 송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때까지 block 된다.   
      - __Nonblocking sending(비동기식 송신)__   
         - 송신하는 프로세스가 메세지를 보내고 작업을 재개한다.   
      - __Blocking sending(동기식 수신)__   
         - 수신하는 프로세스는 메세지가 이용가능할 때까지 block된다.   
      - __Nonblocking sending(비동기식 수신)__   
         - 수신하는 프로세스는 유효한 메세지 또는 null을 수신한다.   
         
   - __send()와 receive()가 모두 block일 경우__   
      - 수신자와 송신자 사이에 랑데부(Rendezvouns)를 갖게 된다.   
      - 생산자-소비자 문제를 위한 해결방법은 send(), receive() 모두 block일 때 단순해진다.   
         - 생산자는 수신자나 메일박스에 메세지가 전달될 때까지 기다린다.   
         - 소비자는 메세지가 이용가능할 때까지 기다린다.   
         
#### 3.4.2.3 Buffering(버퍼링)    

   - __통신이 직접 또는 간접이든, 통신하는 프로세스들에 의해 교환되는 메세지는 임시 큐에 들어있다.__ :star:      
   
   - __임시 큐를 구현하는 3가지 방법__   
      - __무 용량(Zero Capacity)__   
         - 큐의 최대 길이가 0이다.   
         - 링크는 큐 안에 대기하는 메시지들을 가질 수 없다.   
         - 이 경우 송신자는 수신자가 메시지를 수신할 때까지 block되야한다.   
      - __유한 용량(Bounded Capacity)__   
         - 큐는 n의 유한 길이를 가진다.   
         - 큐에 최대 n개의 메시지가 안에 들어올 수 있다.    
         - 새로운 메시지가 전송 될 때 큐가 가득 차 있지 않으면 큐에 저장되며 송신자는 대기하지 않고 실행을 계속 한다.   
         - 메세지가 복사되거나 메세지를 가르키는 포인터가 저장되어진다.     
      - __무한 용량(Unbounded Capacity)__   
         - 큐의 길이가 잠재적으로 무한하다.      
         - 메시지들이 얼마든지 큐 안에서 대기할 수 있다. 송신자는 절대 block되지 않는다.   
         
      - __무 용량 방법은은 버퍼링이 없는 메세지 시스템으로 언급되고, 다른 방법은 자동 버퍼링을 가진 시스템으로 언급된다.__   

### 3.5 Examples of IPC Systems   
   - __Posix는 공유 메모리__   
   - __Mach는 메세지 전달__   
   - __Windows는 공유 메모리, 메시지 전달__   
   
### 3.6 Communication in Client-Server Systems   
#### 3.6.1 Sockets(소켓)   
   
   - __소켓__   
      - 통신을 위한 end point로 정의된다.   
      - 포트 번호와 연결된 IP 주소에 의해 식별된다.   
      - 두 프로세스가 네트워크 상에서 통신을 하려면 양 프로세스마다 하나씩 총 두 개의 소켓이 필요하다.   
      - Client-Server 구조에서 사용한다.   
         - Server는 명시화된 포트에 귀 기울임으로써 Client 요청이 들어오기를 기다린다.   
         - 요청이 들어오면, Server는 연결을 완료하기 위해 Client 소켓으로부터 연결을 허용한다.   
         - 특정 서비스 (telnet 23, FTP 21, HTTP 80)를 수행하는 Server들은 잘 알려진 포트에 귀를 기울인다.   
            - 포트 번호 0 ~ 1024는 잘 알려져 있다고 여겨지고 표준 서비를 구현할 때 사용할 수 있다.   
         - Client 프로세스가 연결을 위한 요청을 할 때 host 컴퓨터에 의해 포트가 할당된다.   
            - 1024 보다 큰 포트번호가 임의로 할당된다.   
            - ex) IP : 146.86.5.20를 가진 host x의 Client가 Web Server: 161.25.19.8:80에 연결하기를 원한다면 host x는 포트번호 1625를 할당받아 Client 소켓 - 146.86.5.20:1625, Server 소켓 - 161.25.19.8:80 소켓 한 쌍이 연결된다.   
            
            <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_20_Sockets.jpg" title="3_20_Sockets" alt="3_20_Sockets"></img><br><strong>3.20 소켓을 사용한 통신</strong><br></p>   
         
      - 호스트 사이에 패킷 트레블링은 종착 포트 넘버를 기반으로 하여 적절한 프로세스로 전달된다.   
      - 모든 연결은 고유하다.   
         - 또 다른 프로세스가 Server에 연결을 한다면, 1024 보다 크고 1625가 아닌 포트가 할당되어진다.   
      - 127.0.0.1은 loopback으로 알려져있고 컴퓨터가 해당 IP를 참조할 때 자기 자신을 참조한다.   
         - Client와 Server가 같은 호스트에서 TCP/IP 프로토콜을 사용하여 통신할 수 있게 해준다.   
      - 소켓을 이용한 통신은 분산된 프로세스들 간에 널리 사용되고 효율적이기는 하지만 너무 저수준이다
         - 소켓은 통신하는 스레드들 간에 구조화되지 않은 바이트 스트림만을 통신하도록 하기 때문이다.   
         - 이러한 원시적인 바이트 스트림 자료를 구조화하여 해석하는 것은 Client와 Server의 주요 작업이다.   
         
#### 3.6.2 Remote Procedure Calls(원격 프로시저 호출)    

   - __RPC__ :star:   
      - 네트워크에 연결된 시스템 사이에 사용을 위한 프로시저 호출 메카니즘을 추상화 하기 위한 방법으로 설계되었다.    
      - 일반적으로 시스템의 가장 위에 설치되어 있다.   
      - __분산된 시스템에서 프로세스를 실행하는 환경이기 때문에 원격 서비스를 제공하기 위해 메세지 기반 통신 형식을 사용해야 한다.__   
      - __IPC 메세지와 반대로 RPC 통신에서 교환되는 메세지는 잘 구조화 되어 있고 데이터 패킷 수준을 넘어서게 된다.__   
         - 각 메세지는 원격 시스템에 있는 포트에 귀 기울이는 RPC 데몬의 주소가 지정되어 있다.   
         - 각 메세지는 수행되어야 할 함수의 식별자, 그리고 그 함수에게 전달 되어야 할 매개변수가 포함된다.   
         - 요청된 함수가 실행되거 어떤 결과이든지 별도의 메세지를 통해 요청자에게 반환된다.   
         
      - __포트는 단순히 메세지 패킷의 시작 부분에 포함되는 정수이다.__   
         - 시스템은 하나의 네트워크 주소를 가지지만 시스템이 지원하는 많은 네트워크 서비스를 구분하기 위해서 해당 주소내에서 여러 포트를 가질 수 있다.   
         - 원격 프로세스가 어떤 서비스를 받고자 하면 그 서비스에 대응되는 적절한 포트 주소로 메시지를 보내야 한다.    
            - 데이터는 응답 메세지에서 받아진다.   
            
      - __RPC의 의미는 Client가 원격 호스트 프로시저를 호출하는 것을 마치 자기의 프로시저를 호출하는 것처럼 해준다는 것이다.__   
      
      - __RPC는 Client쪽에서 stub을 제공함으로써 통신이 발생하게 된다는 세부사항을 숨긴다.__   
         - 보통 각 별도의 원격 프로시저마다 별도의 stub이 존재 한다.
         - Client가 원격 프로시저를 호출하면 RPC는 그에 대응하는 stub을 호출하고 원격 프로시저가 필요로 하는 파라미터를 건네 준다.   
         - 그러면 stub이 원격 서버의 포트를 찾고 파라미터를 정돈(marshall)한다.   
            - __Parameter marshall__   
               - 프로시저에게 갈 파라미터를 네트워크로 전송하기 위해 적절한 형태로 재구성 하는 작업   
         
         - stub은 메세지 전달을 사용하여 Server에 메세지를 전송한다.    
         - 이에 대응되는 stub이 Server에도 존재하여 Server측 stub이 메시지를 수신한 후 적절한 Server의 프로시저를 호출한다.   
         - 필요한 경우 반환 값들도 동일한 방식으로 Client에 전달한다.   
         
         - __Client와 Server의 자료 표현 방식에 있어서 다를 경우에 대한 문제가 반드시 다뤄져야 한다.__   
            - __32 bit 정수로 표현할 경우__   
               - __big-endian__   
                  - 최상위 byte를 먼저 저장한다.   
               - __little-endian__   
                  - 최하위 바이트를 먼저 저장한다.   
               - 어떤 것도 더 낫다고 말할 순 없고 컴퓨터 구조에 따라 정해진다.   
               - 이러한 차이점을 해결하기 위해서 많은 RPC 시스템은 데이터의 기계 독립적인 표현을 정의한다.   
                  - __XDR(External Data Representation)__   
                     - Client 측에서 파라미터 masrshall은 데이터가 Server로 보내지기전에 기계 독립적인 데이터를 XDR로 변환하는 것이다.   
                     - Server 측에서 XDR 데이터는 unmarshall되어지고 Server를 위한 기계 독립적인 데이터로 변환된다.   
                     
          - __호출의 의미에 대한 문제에 있어서도 주의를 해야한다.__   
             - 지역 프로시저의 경우 네트워크 에러와 같은 극단적인 경우에만 실패하지만 RPC는 실패할 수도 있으며 메시지가 중복되어 여러 번 호출 될 수도 있다.   
             - 이 문제를 해결하기 위해 OS는 메세지가 "최대 한번"이 아니라 "정확히 한번" 처리되도록 보장해야한다.   
             - 대부분 지역 프로시저는 "정확히 한번" 기능성을 가지지만 구현하기 어렵다.   
                - "최대 한번" 이라는 의미는 각 메세지에 time stamp를 붙임으로써 수행될 수도 있다.   
                  - Server는 반드시 이미 실행된 메세지의 모든 time stamp의 기록을 유지하거나 반복된 메세지 감지를 보장할 수 있는 충분한 크기의 history를 유지해야한다.   
                  - history에서 이미 time stamp를 가진 메세지 수신은 무시된다.   
                  - Client는 한번 이상 메세지를 보낼 수 있고 오직 한번 실행하는것을 보장 받을 수 있다.   
                - "정확히 한번"을 위해서 Server가 요청을 절대 수신하지 않을 것이라는 위험성을 제거해야만 한다.   
                  - 이를 달성하기 위해서, Server는 "최대 한번" 프로토콜을 반드시 구현해야할 뿐만 아니라, RPC 호출이 수신되고 실행되어진 것을 Client에게 알려줘야한다.    
                  - 이러한 ACK 메세지는 네트워킹에서는 흔하다   
                  - Client는 보낸 RPC 호출에 대한 ACK를 받기 전까지, 각 RPC 호출을 주기적으로 재전송해야한다.   
                  
      - __Client와 Server 사이의 통신 문제도 다뤄져야 한다.__   
         - 일반적인 프로시저의 경우, 바인딩(binding)이라는 작업이 링크,적재,실행 시간 동안에 행해진다.   
            - 이때 프로시저의 이름이 프로시저의 메모리 주소로 변환 된다.   
         - RPC 구조는 Client와 Server 포트의 유사한 바인딩이 필요하다.   
         - 시스템끼리는 메모리를 공유하지 않기 때문에 어떠한 시스템도 다른 시스템에 관한 완전한 정보를 가지고 있지 않다.   
         - 그렇다면 어떻게 Client가 Server의 포트번호를 알 수 있을 까?   
         
            - __고정 포트 방법__   
               - 정보 바인딩은 고정 포트 주소 방식에서 미리 결정될수도 있다.   
               - 컴파일 시간에 RPC 호출은 RPC 호출과 관련된 고정된 포트 번호를 가진다.   
               - 프로그램이 컴파일 되면, Server는 요청된 서비스의 포트 번호를 변경할 수 없게 된다.   
               
            - __동적 바인딩 방법__   
               - OS는 고정된 RPC 포트에 rendezvous(matchmaker) 데몬을 제공한다.   
               - Client는 자신이 수행하기를 원하는 RPC 이름을 담고 있는 메시지를 랑데부 데몬에게 보내서 RPC 이름에 대응하는 포트 주소가 무엇인지 요청하여 알 수 있다.   
               - 포트 번호가 반환되고 프로세스가 종료되거나(Server 붕괴)될 때까지 해당 포트로 RPC 호출이 전송될 수 있다.   
               
            - 동적 바인딩 방법은 초기 요청 시 추가적인 오버헤드를 요구하지만 고정 포트 방법보다 훨씬 유연하다.   
            
      - __RPC 구조는 분산 파일 시스템 구현 시에 유용하다.__   
         - 이러한 시스템은 RPC 데몬과 Client의 집합으로 구현될 수 있다.   
         - 메세지는 발생되야 할 파일 연산이 Server에서 분산된 파일 시스템 포트로 전달된다.   
         - 메세지는 수행되어야 할 디스크 연산을 포함한다.   
         - 디스크 연산은 일반적인 파일 관련 시스템 호출에 상응하는 read, write, rename, delete, status일 수 있다.   
         - 반환 메세지는 Client를 대신하여 DFS 데몬에 의해 실행되는 호출로부터 얻어지는 데이터를 가지고 있다.   
            - ex) 메세지는 모든 파일을 Client에 전송하기 위한 요청을 포함하거나 간단한 블록 요청으로 제한될 수 있다. 후자의 경우, 모든 파일이 전송되어져야 한다면 다수의 요청일 필요할지도 모른다.   
            
#### 3.6.3 Pipe(파이프)   

   - __파이프는 두 개의 프로세스가 통신하게하는 전달자로써의 역할을 한다.__    
      - 하나의 프로세스에서 다른 프로세스에게로 데이터 흐름을 연결할 때 사용한다.   

   - __파이프 구현 시 고려 사항__ :star:      
      - 양방향 또는 단방향 통신인가?   
      - 양방향 통신이 허락되면, half duplex(데이터가 한번에 한 방향으로만 이동) 또는 full duplex(데이터가 동시에 양방향으로 이동)인가?   
      - 통신하는 프로세스 사이에 반드시 관계(부모-자식)가 존재해야 하는가?   
      - 네트워크를 통해 통신할 수 있는가 또는 반드시 같은 기계에 있는 프로세스 통신만 할 수 있는가?   
      
#### 3.6.3.1 Ordinary Pipes(일반 파이프)   

   - __파이프는 두 프로세스가 표준 생산자-소비자 모델에 따라 통신할 수 있게 하는 원형 버퍼이다.__   
      - 생산자는 파이프의 한쪽 끝에 기록한다.   
         - fd[1] = write-end   
      - 소비자는 파이프의 반대쪽 끝에서부터 읽는다.   
         - fd[0] = read-end   
      - 양방향 통신일 경우, 두 개의 파이프가 사용되야 한다.   
         - 각 파이프는 다른 방향으로 데이터를 전송해야 한다.   
      - 파이프를 생성한 프로세스의 외부로부터 접근이 되지 않는다.   
      - 부모 프로세스는 파이프를 생성하고 fork()를 통해 생성한 자식 프로세스와 통신하기 위해 파이프를 사용한다.   
         - 자식은 부모로부터 열린 파일을 상속받는다.   
            - 파이프는 특별한 파일 종류이기 때문에 자식은 부모 프로세스로부터 파이프를 상속받는다.   
         - 사용하지 않는 파이프의 끝을 닫아야 한다.   
            - ex) 부모는 read-end, 자식은 write-end 쪽을 닫는다.   
         - 파이프로부터 읽는 프로세스는 쓰는 프로세스가 파이프의 끝을 닫았을 때 EOF(read() 가 0 반환)를 탐지할 수 있도록 보장해야 한다.   
         <p align="center"><img src="https://github.com/seongbeenkim/CS-Interview/blob/master/OS/image/3_22_PipeFileDescriptors.jpg" title="3_22_PipeFileDescriptors" alt="3_22_PipeFileDescriptors"></img><br><strong>3.22 일반 파이프의 파일디스크립터</strong><br></p>   
         
   - __일반 파이프는 프로세스들이 서로 통신하는 동안만 존재하고 프로세스가 통신을 끝내고 종료하면 파이프도 소멸한다.__   

   - __Windows와 UNIX에서는 통신하는 프로세스 사이에 부모 자식 관계가 필요하다.__   
      - 이러한 일반 파이프는 같은 기계에 있는 프로세스 사이의 통신을 위해서만 사용될 수 있다는 것을 의미한다.   
      
   - __익명 파이프(anonymous pipe)__   
      - 일반 파이프이 Windows 시스템에서 사용되는 용어이다.   
      - 단방향이고 통신하는 프로세스 사이 부모 자식 관계가 존재한다.   
      
#### 3.6.3.2 Named Pipes(지명 파이프)   

   - __지명 파이프__   
      - 양방향 통신이 가능하다.   
      - 부모 자식 관계가 필요없다.   
      - 하나의 지명 파이프가 형성되면, 다수의 프로세스가 통신을 위해 지명 파이프를 사용할 수 있다.   
      - 프로세스가 종료되어도 존재한다.   
   
   - __UNIX 지명 파이프__   
      - FIFO via mkfifo()   
      - 생성될 시 파일 시스템에서 일반 파일로 보여진다.   
      - open(), read(), write(), close() 시스템 호출로 조작할 수 있다.   
      - 파일 시스템에서 제거될 때까지 존재한다.   
      - 양방향 통신을 제공하지만 half-duplex전송만 허용된다.   
         - 데이터가 양방향으로 이동해야 할 시에는, 두 개의 FIFO가 사용된다.   
      - 통신하는 프로세스는 반드시 같은 기계에 존재해야 한다.   
         - 다른 기계간 통신이 필요할 시에는, 소켓이 사용되야한다.   
         
   - __Windows 지명 파이프__   
       - full-duplex 전송을 허용하며 통신하는 프로세스는 다른 기계에 있어도 된다.   
       - UNIX FIFO를 통해서는 byte 지향적 데이터만 전송되어질 수 있지만 Windows는 메세지 또는 byte 지향적인 데이터 둘 다 가능하다.   
       - CreatNamedPipe(), ConnectNamedPipe(), ReadFile(), WriteFile()을 통해 통신을 할 수 있다.   
       
