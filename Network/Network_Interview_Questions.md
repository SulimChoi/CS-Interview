# :bookmark_tabs: Network Interview Questions   
   
* [REST API](#rest_api란_무엇인가?)    
* [라우터에서 발생하는 Packet delay](#라우터에서_패킷_교환간_발생하는_delay에_대해_설명해보세요)   
* [쿠키와 세션](#쿠키와_세션)   
* [HTTP와 HTTPS](#http와_https)   
* [](#)   
* [](#)   
* [](#)   
* [](#)   
* [](#)   
* [](#)   
* [](#)   
* [](#)   
* [](#)   


## REST API란 무엇인가?       
  - __서버에 HTTP 요청을 보낼 때 각 요청이 어떤 동작이나 정보를 위한 것인지 그 요청의 모습 자체로 추론 가능한 API__   
  - 과거의 SOAP(Simple Object Access Protocol)이란 복잡한 형식 대체   
    - __SOAP__   
      - 일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다. SOAP은 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다.   
      - SOAP에는 몇가지 형태의 메시지 패턴이 있지만, 보통의 경우 원격 프로시져 호출(Remote Procedure Call:RPC) 패턴으로, 네트워크 노드(클라이언트)에서 다른 쪽 노드(서버)로 메시지를 요청 하고, 서버는 메시지를 즉시 응답하게 된다.    

  - __프로그램을 만들 때 기능 자체만 중요하게 생각한다면 REST를 생각할 필요 없이 동작만 되게 하면 된다.__   
    - Ex) 어떤 학원의 반과 학생들에 대한 API를 만들 때    
    - `https://(도메인)/1` = 학원의 반 리스트 요청   
    - `https://(도메인)/hello` = 반의 학생들 리스트 요청   
    - `https://(도메인)/seongbeen` = 학생의 정보 수정 요청   
    
  - __하지만 REST를 왜 사용하는가?__   
    - 서비스를 혼자 만드는 것이 아니기 때문이다. 위에 처럼 기능 자체만 중요하게 만들 경우 당장은 혼자라도, 나중에 이 일을 인계받을 개발자나, 해당 API를 사용해서 다른 제품을 만들 개발자들은 일하기 힘들어진다.   
    - 그러므로 RESTful하게 만든 API는 요청 보내는 주소만으로 어떤 요청인지 파악이 가능하게 하여 다른 개발자들이 일을 더 편하게 할 수 있게 해준다.    
    - Ex) 
    - `https://(도메인)/classes` => 학원의 반 목록 요청 추론 가능   
    - `https://(도메인)/classes/2` => 2반에 관한 정보 요청 추론 가능 (초급반, 중급반 등)   
    - `https://(도메인)/classes/2/students` => 2반 학생들에 대한 정보 요청 추론 가능   
    - `https://(도메인)/classes/2/students/15` => 2반의 15번째 학생에 대한 정보 요청 추론 가능   
    - `https://(도메인)/classes/2/students?sex=male` => 2반의 남학생에 대한 정보 요청 추론 가능   
    - `https://(도메인)/classes/2/students?page=2&count=10` => 2반의 2 page의 학생 10명에 대한 정보 요청 추론 가능   

    __여기서 `classes/2/students`와 같이 자원을 구조와 같이 나타내는 형태의 구분자를 “URI”라고 한다.__   

  - 위처럼 조회 작업 뿐만 아니라 정보를 새로 넣거나 수정, 삭제를 할 경우도 필요하다.   
    - Create(생성), Read(조회), Update(수정), Delete(삭제)   

  - __서버에 REST API로 요청을 보낼 경우 HTTP 규약에 따라 신호를 전송한다.__    
    - HTTP로 요청을 보낼 경우 여러 메소드들이 사용되는데 __REST API는 GET, POST, PUT(또는 PATCH), DELETE를 사용__한다.   
    - __POST, PUT, PATCH에는 body라는 컨테이너가 있어 GET이나 DELETE보다 비교적 안전하게 데이터를 감춰서 실어보낼 수 있다.__   
    - __이 기능들은 특정 용도에 제한되어 있지는 않다.__   
      - Ex) POST로 데이터를 CRUD를 모두 다 할 수 있다. 용량이 적고 중요도가 낮은 정보들은 GET으로 CRUD 모두 할 수 있다.   
    - __하지만, 누구든 각 요청의 의도를 쉽게 파악할 수 있도록 RESTful하게 API를 만들기 위해서는 이러한 기능들을 목적에 따라 구분해서 사용해야 한다.__   
    - __GET__   
      - Read(조회)   
      - Ex)   
      - GET `https://(도메인)/classes/2/students` => 2반 학생들을 조회하는 요청   
    - __POST__   
      - Create(생성)   
      - Ex)   
        - POST `https://(도메인)/classes/2/students` 일 경우   
        - POST의 body에 새 학생에 대한 정보를 담아 보낸다. => 2반에 새로운 학생 데이터 추가 요청 (idx가 생성될 것이기 때문에 idx를 표시할 필요가 없다)
    - __PUT 또는 PATCH__   
      - Update(수정)   
      - Ex)    
        - PUT 또는 PATCH `https://(도메인)/classes/2/students/14` 일 경우   
        - PUT 또는 PATCH의 body에 수정할 정보들을 담아 보낸다. => 2반의 14번 학생 데이터 수정 요청   
      - __PUT으로 모두 사용하는 경우도 있지만 정석으로는 PUT은 보통 정보를 완전히 수정할 때 사용하며 PATCH는 정보의 일부분만 수정할 때 사용해야한다.__   
    - __DELETE__   
      - Delete(삭제)    
      - Ex) DELETE `https://(도메인)/classes/2/students/14` = 2반 14번 학생에 대한 데이터 삭제 요청   

    - __위에서 말했다시피 POST 또는 GET이 CRUD 모두 할 수 있다고 하였는데 이렇게 사용해야 할 경우 URI에 이에 대한 동작도 명시해야 한다. 이 경우는 RESTful 하지 못한 경우이다.__    
      - Ex)   
      - POST `https://(도메인)/classes/2/students/create`   
      - POST `https://(도메인)/classes/2/students/read`   
      - POST `https://(도메인)/classes/2/students/update`   
      - POST `https://(도메인)/classes/2/students/delete`   
    - 이럴 경우 깔끔하지가 않기 때문에 이런 것들을 지양하기 위한 __REST의 규칙 중 하나로 URI는 동사가 아닌 명사__ 로 이뤄저야 한다.   
    
    - __REST 특징__   
      - __Stateless (무상태성)__   
        - 세션 정보나 쿠키 정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리한다.   
      - __Uniform Interface (유니폼 인터페이스)__   
        - URI로 지정한 자원에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다.   
      - __Cacheable (캐시 가능)__   
        - HTTP가 가진 캐싱 기능이 적용 가능합니다. HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능하다.   
      - __Self-descriptiveness (자체 표현 구조)__   
        - REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조   
      - __Client - Server 구조__   
        - 자원이 있는 쪽을 Server이고 자원 요청하는 쪽이 Client    
        - Server와 Client에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 된다.   
      - __Layered system (계층형 구조)__   
        - REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 한다.   
        - Client는 Rest API 서버만 호출   
        
  __즉, REST API란, HTTP 요청을 보낼 때 URI에 어떤 메소드(자원 등)를 사용할 지 개발자들 사이에 널리 지켜지는 약속이다.__    
  
  __형식이기 때문에 기술 또는 프레임워크에 구애받지 않는다.__   
  
  __앱을 만들든, 웹사이트를 만들든 어떤 언어로 써서 만들든 소프트웨어간 HTTP로 정보를 주고 받는 부분이 있다면 이러한 규칙을 준수해서 RESTful한 서비스를 만들 수 있다.__   
  
  
## 라우터에서 패킷 교환간 발하는 delay에 대해 설명해보세요.      
  - __1. Nodal processing delay(처리 지연)__   
     - 라우터에서 패킷을 받았을 때 검사(최종 목적지가 어디인지 다음 라우터는 무엇인지)하고 output link를 결정하는 등 작업을 하는데 걸리는 delay   
     
  - __2. Queuing delay(큐잉 지연)__   
    - output link에 전송될 때까지 큐에서 대기하는 시간, 라우터의 혼잡도에 따라 다르다.   
    
  - __3. Transmission delay(전송 지연)__   
    - 전송 시 걸리는 delay, output link로 첫번째 비트가 나가는 순간부터 마지막 비트가 나가는 순간까지 걸리는 시간   
    - R = 링크 대역폭(bps), L = 패킷 크기(bits), L/R = 비트를 링크로 보내는데 걸리는 시간(전송 지연)   
    - R이 클수록 transmission delay가 적게 걸린다.   

  - __4. Propagation delay(전파 지연)__   
    - 데이터가 output link로 전달된 후 다음 라우터까지 도달하는데 걸리는 시간    
    - d = 물리적 링크의 길이, s = 전파 속도, propagation delay = d/s   
    - s는 전파이기 때문에 조절할 수 없으며, d가 짧을 수록 propagation delay가 적게 걸린다.   
    
  - __delay 줄이는 방법__   
    - __1. Nodal processing delay(처리 지연)__   
      - 좋은 성능의 라우터를 사용   
    - __2. Queuing delay(큐잉 지연)__   
      - x, 인터넷 사용량이 항상 다르기 때문이다.   
    - __3. Transmission delay(전송 지연)__   
      - 링크 대역폭을 확장   
    - __4. Propagation delay(전파 지연)__   
      - 물리적 링크 변경

  - __큐잉 지연과 패킷 손실__   
    - __queue의 크기는 제한적이기 때문에 꽉 찬 상태에서 계속하여 패킷이 온다면 패킷 손실이 발생한다.__   
      - __TCP에서 패킷 손실이 일어날 경우 어떻게 재전송을 하는가?__   
        1. 이전 라우터가 직접 재전송하는 방법
        2. 처음부터 재전송   
        - __2번의 방법으로 처음부터 재전송을 한다. -> 현재 인터넷 디자인__   
        - __1번의 방법을 사용하지 않는 이유__ - 라우터는 빠른 속도로 전달해야하기 위해 해야할 작업이 많으므로 이 전달을 위한 목적으로만 사용을 하기 때문이다.   
        - dumb core: TCP 사이의 모든 라우터를 지칭 (TCP - 라우터 - 라우터 - 라우터 ... - TCP)

## 쿠키와 세션   
  - __쿠키와 세션을 사용하는 이유__   
    -	HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용된다.   
      - __Connectionless 프로토콜 (비연결지향)__   
        - 클라이언트가 서버에 요청(Request)을 했을 때, 그 요청에 맞는 응답(Response)을 보낸 후 연결을 끊는 처리방식이다.   
        - HTTP 1.1 버전에서 연결을 유지하고, 재활용 하는 기능이 Default로 추가되었다.(keep-alive 값으로 변경 가능)   
      - __Stateless 프로토콜 (상태정보 유지 안함)__   
        - 클라이언트의 상태 정보를 가지지 않는 서버 처리 방식이다.   
        - 클라이언트와 첫번째 통신에서 데이터를 주고 받았다 해도, 두번째 통신에서 이전 데이터를 유지하지 않는다.   
        
      - __서버와 클라이언트가 통신을 할 때 통신이 연속적으로 이어지지 않고 한 번 통신이 되면 끊어진다. 따라서 서버는 클라이언트가 누구인지 계속 인증을 해줘야 한다. 하지만 그것은 매우 귀찮고 번거로운 일이다. 또한 웹페이지의 로딩을 느리게 만드는 요인이 되기도 한다. 그런 번거로움을 해결하는 방법이 바로 쿠키와 세션이다.__ 
      
  - __쿠키__   
    - HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우, 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일    
    - HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 필요시 정보를 참조하거나 재사용할 수 있다.   
    - __특징__   
      - 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성   
      - 클라이언트에 총 300개의 쿠키 저장 가능
      - 하나의 도메인 당 20개의 쿠키   
      - 하나의 쿠키는 4KB(=4096byte)까지 저장 가능
    
    - __동작 순서__   
      - 클라이언트가 페이지 요청(웹 사이트 접근)    
      - 서버가 쿠키 생성   
      - 생성한 쿠키에 정보를 담아 HTTP Response 할 때 클라이언트에게 보내준다.   
      - 클라이언트는 자신의 PC에 쿠키를 저장한 후 나중에 서버에 요청할 때 쿠키를 함께 전송한다.   
    
    - ex) 사이트 다시 방문 시 ID/PASSWORD 자동 입력, 팝업 창 "오늘 이 창을 다시 보지 않기", 장바구니   
      
      
  - __세션__   
    - 일정 시간동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술   
    - 사용자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다.   
    
    - __특징__   
      - 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장   
      - 서버의 저장되는 쿠키 (= 세션 쿠키)   
      - 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되므로 쿠키보다 보안이 좋다.   
      - 저장 데이터에 제한이 없다.(서버 용량)   
      - 각 클라이언트에 고유 세션 ID를 부여하여 각 클라이언트 요구에 맞는 서비스 제공한다.   
      
    - __동작 순서__   
      - 클라이언트가 페이지 요청(웹 사이트 접근)   
      - 서버는 클라이언트의 Request-header 필드인 쿠키를 확인하여, 세션 ID를 보냈는지 확인   
      - 세션 ID가 존재하지 않다면, 서버는 세션 ID를 생성하여 클라이언트에게 전달   
      - 서버에서 클라이언트로 준 세션 ID를 쿠키를 사용해 서버에 저장     
        - 쿠키 이름 : JSESSIONID(세션을 유지하기 위해 발급하는 키)   
      - 클라이언트는 재접속 시 JSESSIONID를 이용하여 세션 ID값을 서버에 전달   
    - ex) 화면 전환을 하더라도 로그아웃하기 전까지 로그인 상태 유지   
    
  - __세션을 쓰면 되는데 쿠키도 사용하는 이유?__   
    - 세션이 쿠키에 비해 보안도 높은 편이나 쿠키를 사용하는 이유는 세션은 서버에 저장되고, 서버 자원을 사용하기 때문에 사용자가 많을 경우 소모되는 자원이 상당하다.   
    - 이러한 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여, 서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다.   
 
  - __쿠키와 세션의 차이점__   
    - __저장 위치__   
      - 쿠키 : 클라이언트 PC   
      - 세션 : 서버   
      
    - __보안__   
      - 쿠키 : 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 Sniffing(네트워크상에서 자신이 아닌 다른 상대방들의 패킷 교환을 훔쳐보는 행위) 당할 우려가 있어서 보안에 취약   
      - 세션 : 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 서버에 직접 접근하지 않는 이상 세션 내의 데이터를 탈취하는 것은 어려우므로 비교적 보안이 좋다.      
      
    - __라이프 사이클(만료 시점)__   
      - 쿠키 : 브라우저가 종료되도, 만료시점이 지나지 않으면 삭제가 되지 않는다.   
      - 세션 : 만료시점을 정할 수 있지만 만료시점 상관없이 브라우저 종료 시 삭제된다.   
      
    - __속도__   
      - 쿠키 : 쿠키에 정보가 들어있기 때문에 서버에 요청시 속도가 빠르다.   
      - 세션 : 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.   
      
  - __캐시__   
    - 캐시는 이미지나 css, js파일 등 용량 큰 파일이나 홈페이지 관리자가 설정한 값이 사용자의 브라우저에 저장이 되는 것으로 페이지 로딩 속도를 개선시켜준다.   
      - 같은 홈페이지를 접속하게 되면 css, js, 이미지 파일을 서버를 거치지 않고 사용자의 PC에서 가져오게 된다.   
      - 이를 통해 자원을 아낄 수 있지만 서버에서 자원을 변경하였는데 사용자에게는 변경된 자원이 보이지 않을 경우가 발생할 수 있다. 즉, 브라우저에 이미 캐시되어 있는 경우 문제가 발생할 수 있다.  
        - 사용자의 브라우저의 캐시를 지워주거나(Ctrl + F5) 서버에서 클라이언트로 응답을 보낼 때 header에 캐시 만료시간을 명시하는 방법 등을 이용하여 해결할 수 있다.   
        
      - __웹 브라우저 캐시 종류__   
        - __브라우저 캐시__   
          - 클라이언트 app이 내부적으로 가지고 있는 캐시    
        - __프록시 캐시__    
          - 실제 서버가 있는 곳이 아닌 네트워크 관리자에 의해 네트워크 상에 설치되는 캐시로 latency(지연)와 트래픽을 줄이는데 이용된다.   
        - __게이트웨이 캐시__   
          - 서버의 관리자에 의해 설치 및 운용되는 캐시    
          - 서버의 앞단에 설치되어 요청에 대한 캐시 및 효율적인 분배를 통해 서버의 응답 성능을 좋게 한다.   
        
## HTTP와 HTTPS    
  - __HTTP__   
    - 웹브라우저(Client)와 서버(Server)간의 웹페이지 같은 자원을 주고 받을 때 쓰는 통신 규약   
    - 클라이언트가 서버에 HTTP를 통해 웹페이지나 이미지 정보를 요청하면 서버는 이 요청에 응답하여 요구하는 정보를 제공하게 된다.   
    - http는 텍스트 교환이다. html 페이지도 텍스트다. 바이너리 데이터로 되어있는 것도 아니고 단순 텍스트를 주고 받기 때문에 누군가 네트워크에서 신호를 가로채어 본다면 내용이 노출된다.   
    - `http://`, Port 번호 80   
    
  - __HTTPS__   
    - HTTP는 패킷 캡쳐시 정보가 그대로 노출될 수 있는 문제점을 가지고 있어 이를 보완하기 위해 HTTP에 SSL(Secure Socket Layer)을 추가한 통신 규악   
    - 
