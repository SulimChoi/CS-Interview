# :bookmark_tabs: SQLD 정리   
* [데이터 모델링의 이해](#데이터-모델링의-이해)
  * [1. 데이터 모델의 이해](#1-데이터-모델의-이해)    
  * [2. Entity](#2-entity)    
  * [3. 속성](#3-속성)   
  * [4. 관계](#4-관계)   
  * [5. 성능 데이터 모델링](#5-성능-데이터-모델링)    
  * [6. 정규화](#6-정규화)   
  * [7. 반정규화](#7-반정규화)   
  * [8. 대량 데이터](#8-대량-데이터)   
  * [9. 데이터베이스 구조와 성능](#9-데이터베이스-구조와-성능)   
  * [10. 분산 데이터베이스](#10-분산-데이터베이스)   
* [SQL 기본 및 활용](#sql-기본-및-활용)   
  * [1. 관계형 데이터베이스](#1-관계형-데이터베이스)   
  * [2. DDL](#2-ddl)   
  * [3. DML](#3-dml)   
  * [4. DCL](#4-dcl)   
  * [5. WHERE 절](#5-where-절)   
  * [](#)   
  * [](#)   
  * [](#)   
  * [](#)   
  * [](#)   
  * [](#)   
  

# 데이터 모델링의 이해
## 1. 데이터 모델의 이해   
### 모델링의 이해   

  - __모델링 3가지 특징__   
    - 추상화: 다양한 현상을 일정한 양식인 표기법에 의해 표현   
    - 단순화: 복잡한 현실세계를 약속된 규약에 의해 제한된 표기법이나 언어로 표현하여 쉽게 이해할 수 있도록 하는 개념   
    - 명확화: 누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확(正確)하게 현상을 기술   
    
  - __모델링 3가지 관점__   
    - 데이터관점: 업무가 어떤 데이터와 관련이 있는지 또는 데이터간의 관계는 무엇인지에 대해서 모델링하는 방법(What, Data)   
    - 프로세스관점: 프로세스관점 : 업무가 실제하고 있는 일은 무엇인지 또는 무엇을 해야 하는지를 모델링하는 방법(How, Process)   
    - 데이터와 프로세스의 상관관점: 데이터와 프로세스의 상관관점 : 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링하는 방법(Interaction)   
    
  - __데이터 모델링의 중요성__   
    - 파급효과(Leverage)   
    - 복잡한 정보 요구사항의 간결한 표현(Conciseness)   
    - 데이터 품질(Data Quality)   
    
  - __데이터 모델링의 유의점__    
    - 중복(Duplication)   
    - 비유연성(Inflexibility)   
    - 비일관성(Inconsistency)   
    
  - __데이터 모델링의 3단계 진행__   
    - __개념적 데이터 모델링(Conceptual Data Modeling)___   
      - 조직, 사용자의 데이터 요구사항을 찾고 분석   
      - 전사적 데이터 모델(Enterprise Data Model)   
      - 조직의 데이터 요구를 공식화
        - 추상적
        - 데이터 요구 사항을 발견하는 것을 지원
    - __논리적 데이터 모델링(Logical Data Modeling)___   
      - 데이터베이스 설계 프로세스의 Input으로써 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현   
      - 가장 먼저 시작할 기초적인 업무조사   
      - 정규화   
      - 
    - __물리적 데이터 모델링(Physical Data Modeling)___   
      - 논리 데이터 모델이 데이터 저장소로서 어떻게 컴퓨터 하드웨어에 표현   
      - 물리적 스키마   

  - __프로젝트 생명주기(Life Cycle)에서 데이터 모델링__   
    - __Waterfall 기반___   
      - 분석과 설계단계로 구분되어 명확하게 정의   
    - __객체지향 기반___   
      - 데이터 모델링과 프로세스 모델링을 구분하지 않고 일체형   
      
  - __데이터 모델링에서 데이터독립성의 이해__   
    - __데이터 독립성의 필요성___   
      - 지속적으로 증가하는 유지보수 비용을 절감하고 데이터 복잡도를 낮추며 중복된 데이터를 줄이기 위한 목적   
      - 끊임없이 요구되는 사용자 요구사항에 대해 화면과 데이터베이스 간에 서로 독립성을 유지하기 위한 목적   
      - three-schema architecture   
        - 미국 표준 협회(ANSI) 산하의 X3 위원회(컴퓨터 및 정보 처리)의 특별연구분과위원회에서 1978년에 DBMS와 그 인터페이스를 위해 제안   
        - 각 View의 독립성을 유지하고 계층별 View에 영향을 주지 않고 변경이 가능하다.   
        - 단계별 Schema에 따라 데이터 정의어(DDL)와 데이터 조작어(DML)가 다름을 제공한다.   
      
  - __데이터베이스 3단계 구조__   
    - __외부 단계___   
    - __개념적 단계__   
    - __내부적 단계__   
    
  - __데이터독립성 요소__   
    - __외부 스키마___   
      - 사용자 관점   
      - 응용 프로그래머나 DB 각 사용자가 접근하는 DB 정의   
    - __개념적 스키마__   
      - 통합 관점   
      - 모든 사용자 관점을 통합한 조적 전체의 DB 기술   
      - 데이터와 관계 표현   
    - __내부적 스키마__   
      - 물리적 저장 관점   
      - DB가 물리적으로 저장된 형식   
      - 물리적 장치에 데이터가 실제적으로 저장되는 방법 표현   
      
  - __두 영역의 데이터 독립성__   
    - __논리적 데이터 독립성___   
      - 외부의 변경에도 개념 스키마가 변하지 않는 특징   
      - 논리작 구조가 변경되어도 응용프로그램에 영향이 없다.   
      - 사용자 특성에 맞게 변경 가능, 통합 구조 변경 가능   
    - __물리적 데이터 독립성___   
      - 내부의 변경에도 개념 스키마가 변하지 않는 특징   
      - 저장장치의 구조변경은 응용프로그램과 개념 스키마에 영향 없음   
      - 개념구조 영향없이 물리적 구조 변경 가능, 물리적 구조 영향없이 개념 구조 변경 가능   
      
  - __사상(Mapping)__   
    - 상호 독립적인 개념을 연결시켜주는 다리
    - _____   
    
  - __데이터 모델링에서 데이터독립성의 이해__   
    - __논리적 사상___   
      - 외부 화면이나 사용자에게 인터페이스하기 위한 스키마 구조는 전체가 통합된 개념적 스키마와 연결   
    - __물리적 사상___   
      - 통합된 개념적 스키마 구조와 물리적으로 저장된 구조의 물리적인 테이블스페이스와 연결   
    데이터독립성을 보장하기 위해서는 사상을 하는 스크립트(DDL)를 DBA가 필요할 때마다 변경해 주어야 한다.   
      
  - __데이터 모델링의 세 가지 요소__   
    - __엔터티___   
      - 사물이나 사건 등을 바라 볼 때 전체를 지칭하는 용어   
    - __속성__   
      - 가지고 있는 세부적인 사항   
    - __관계__   
      - 연관성   
  
  - __단수와 집합(복수)의 명명__  
    - __복수:단수__   
      - __엔터티:인스턴스/어커런스___   
      - __관계:페어링__   
      - __속성:속성값__   
    
  - __데이터 모델링의 이해관계자__   
    - __정보시스템을 구축하는 모든 사람(전문적으로 코딩만하는 사람 포함)___   
    - __IT기술에 종사하거나 전공하지 않았더라도 해당 업무에서 정보화를 추진하는 위치에 있는 사람__   
    
  - __데이터 모델 표기법__   
    - __Entity-relationship model(E-R Model)___   
      - 엔터티 - 사각형   
      - 관계 - 마름모   
      - 속성 - 타원형   
    
  - __ERD(Entity Relationship Diagram) 표기법을 이용하여 모델링하는 방법__   
    - __각 업무분석에서 도출된 엔터티와 엔터티간의 관계를 이해하기 쉽게 도식화된 다이어그램으로 표시하는 방법___   
    - __일정한 규칙을 지정하여 그림으로써 데이터 모델을 누구나 공통된 시각으로 파악할 수 있고 의사소통을 원활하게 하는 장점__   
    - __ERD 작업순서__   
      - 엔터티를 그린다   
      - 엔터티를 적절하게 배치   
      - 엔터티간 관계를 설정   
      - 관계명을 기술   
      - 관계의 참여도를 기술   
      - 관계의 필수여부를 기술   
    - __엔터티와 엔터티 사이의 관계가 있는 정보를 나타내므로 두 개를 이용하여 작성하고, 이에 따라 Primary Key와 Foreign Key를 ERD 규칙에 따라 기술__   
    - __가장 중요한 엔터티를 왼쪽상단에 배치하고 이것을 중심으로 다른 엔터티를 나열__   
    - __ERD 관계명의 표시 관계설정이 완료되면 연결된 관계에 관계이름을 부여__   
      - 현재형    
    - __ERD 관계 관계차수와 선택성 표시 관계에 대한 이름을 모두 지정하였으면 관계가 참여하는 성격 중 엔터티내에 인스턴스들이 얼마나 관계에 참여하는 지를 나타내는 관계차수(Cardinality)를 표현__   
    
  - __좋은 데이터 모델의 요소__   
    - __완전성(Completeness)___   
    - __중복배제(Non-Redundancy)___   
    - __업무규칙(Business Rules)___   
    - __데이터 재사용(Data Reusability)___   
    - __의사소통(Communication)___     
    - __통합성(Integration)___    
   
   
## 2. Entity    
  - __업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것__   
    - __특징__   
      - 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다.   
      - 영속적으로 존재하는 인스턴스의 집합이어야 한다.(‘한 개’가 아니라 ‘두 개 이상’)   
      - Entity는 업무 프로세스에 의해 이용되어야 한다.   
      - Entity는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.   
      - Entity는 반드시 속성이 있어야 한다.   
        - 속성(Attribute)   
          - 공통 속성   
          - 개별 속성   
      - 유일한 식별자에 의해 식별이 가능해야 한다.   

  - __Entity의 분류__   
    - __유무(有無)형에 따른 분류___   
      - __유형 Entity__   
        - 물리적인 형태가 있고 안정적이며 지속적으로 활용되는 Entity   
      - __개념 Entity__   
        - 물리적인 형태는 존재하지 않고 관리해야 할 개념적 정보   
      - __사건 Entity__   
        - 업무를 수행함에 따라 발생되는 Entity   
    - __발생시점(發生時點)에 따른 분류___   
      - __기본/키 Entity(Fundamental Entity, Key Entity)__   
        - 업무에 원래 존재하는 정보로서 다른 엔터티와 관계에 의해 생성되지 않고 독립적으로 생성이 가능하고 자신은 타 Entity의 부모의 역할을 하게 된다. 다른 Entity로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지게 된다.   
      - __중심 Entity(Main Entity)__   
        - 기본 Entity로부터 발생되고 그 업무에 있어서 중심적인 역할을 한다. 데이터의 양이 많이 발생되고 다른 Entity와의 관계를 통해 많은 행위엔터티를 생성   
      - __행위 Entity(Active Entity)__   
        - 두 개 이상의 부모 Entity로부터 발생되고 자주 내용이 바뀌거나 데이터량이 증가된다. 분석초기 단계에서는 잘 나타나지 않으며 상세 설계단계나 프로세스와 상관모델링을 진행하면서 도출   
    - __스스로 생성될 수 있는지에 따른 분류___   
      - __독립 Entity__   
      - __의존 Entity__   
      
  - __Entity의 명명__   
    - __가능하면 현업업무에서 사용하는 용어___   
    - __가능하면 약어를 사용하지 않는다__   
    - __단수명사__   
    - __모든 Entity에서 유일하게 이름이 부여__   
    - __Entity 생성의미대로 이름을 부여__   
    
## 3. 속성   

  - __업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위__   
    - __업무에서 필요로 한다.__   
    - __의미상 더 이상 분리되지 않는다.__   
    - __Entity를 설명하고 인스턴스의 구성요소가 된다.__   
    
  - __Entity, 인스턴스, 속성, 속성값의 관계__   
    - __한 개의 Entity는 두 개 이상의 인스턴스의 집합이어야 한다.__   
    - __한 개의 Entity는 두 개 이상의 속성을 갖는다.__   
    - __한 개의 속성은 한 개의 속성값을 갖는다.__   
    
  - __속성의 표기법__   
    - __속성의 표기법은 Entity 내에 이름을 포함하여 표현__   
  
  - __속성의 특징__   
    - __Entity와 마찬가지로 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다.__    
    - __정규화 이론에 근간하여 정해진 주식별자에 함수적 종속성을 가져야 한다.__   
    - __하나의 속성에는 한 개의 값만을 가진다. 하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 Entity를 이용하여 분리한다.__   
  - __속성의 분류__   
    - __속성의 특성에 따른 분류__   
      - __기본속성(Basic Attribute)__   
        - 업무분석을 통해 바로 정의한 속성   
      - __설계속성(Designed Attribute)__   
        - 원래 업무상 존재하지는 않지만 설계를 하면서 도출해내는 속성   
      - __파생속성(Derived Attribute)__   
        - 다른 속성으로부터 계산이나 변형이 되어 생성되는 속성   
        
    - __Entity 구성방식에 따른 분류__   
      - __PK(Primary Key)속성__   
        - Entity를 식별할 수 있는 속성   
      - __FK(Foreign Key)속성__   
        - 다른 Entity와의 관계에서 포함된 속성   
      - __일반속성__   
        - 엔터티에 포함되어 있고 PK, FK에 포함되지 않은 속성   
      - __세부 의미를 쪼갤 수 있는지에 따른 분류__   
        - 복합 속성(Composite Attribute)   
          - 여러 세부 속성들로 구성   
        - 단순 속성(Simple Attribute)   
          - 더 이상 다른 속성들로 구성될 수 없는 단순한 속성   
      - __단일값 속성__   
        - 속성 하나에 한 개의 값을 가지는 경우   
      - __다중값 속성__   
        - 속성 하나에 여러 개의 값을 가지는 경우   
  - __도메인(Domain)__   
    - __각 속성은 가질 수 있는 값의 범위__   
    
  - __속성의 명명(Naming)fffff__   
    - __현업에서 사용하는 이름을 부여하는 것이 가장 중요하다.__   
    - __명사형을 이용__   
    - __약어는 사용하지 않는 것이 좋다.__   
    - __가능하면 모든 속성의 이름은 유일하게 작성하는 것이 좋다.__   
       
       
## 4. 관계   
  - __엔터티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태__   
    
  - __관계의 페어링__   
    - __각각의 엔터티의 인스턴스들은 자신이 관련된 인스턴스들과 관계의 어커런스로 참여하는 형태__   
    
  - __관계의 분류__   
    - __존재에 의한 관계__   
    - __행위에 의한 관계__    
    - __UML(Unified Modeling Language)에는 클래스다이어그램__   
      - __연관관계(Association)__   
        - 항상 이용하는 관계로 존재적 관계   
      - __의존관계(Dependency)__   
        - 상대방 클래스의 행위에 의해 관계가 형성   
    
  - __관계의 표기법__   
    - __관계명(Membership)__   
      - 관계의 이름   
      - 관계시작점(The Beginning)   
        - 엔터티에서 관계가 시작되는 편   
      - 관계끝점(The End)   
        - 엔터티에서 관계를 받는 편   
      - 애매한 동사를 피한다.   
      - 현재형으로 표현   
      
    - __관계차수(Cardinality)__   
      - 1:1, 1:M, M:N   
      
    - __관계선택사양(Optionality)__   
      - 필수관계, 선택관계   
    
  - __관계의 정의 및 읽는 방법__        
    - __관계 체크사항__        
      - 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?   
      - 두 개의 엔터티 사이에 정보의 조합이 발생되는가?    
      - 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?    
      - 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가?     

    - __관계 읽기__       
      - 기준(Source) 엔터티를 한 개(One) 또는 각(Each)으로 읽는다.   
      - 대상(Target) 엔터티의 관계참여도 즉 개수(하나, 하나 이상)를 읽는다.   
      - 관계선택사양과 관계명을 읽는다.   

## 5. 식별자   
  - __하나의 엔터티에 구성되어 있는 여러 개의 속성 중에 엔터티를 대표할 수 있는 속성을 의미하며 하나의 엔터티는 반드시 하나의 유일한 식별자가 존재해야 한다.__            
    
  - __식별자의 특징__        
    - 주식별자에 의해 엔터티내에 모든 인스턴스들이 유일하게 구분되어야 한다.        
    - 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어    
    - 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.   
    - 주식별자가 지정이 되면 반드시 값이 들어와야 한다.   

  - __식별자 분류 및 표기법__   
    - __식별자 분류__   
      - 자신의 엔터티 내에서 대표성을 가지는가에 따라 주식별자(Primary Identifier)와 보조식별자(Alternate Identifier)   
      - 엔터티 내에서 스스로 생성되었는지 여부에 따라 내부식별자와 외부식별자(Foreign Identifier)   
      - 단일 속성으로 식별이 되는가에 따라 단일식별자(Single Identifier)와 복합식별자(Composit Identifier)   
      - 의미가 있던 식별자 속성을 대체하여 일련번호와 같이 새롭게 만든 식별자를 구분하기 위해 본질식별자와 인조식별자   
      
    - __주식별자 도출기준__    
      - 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.   
      - 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않는다.   
      - 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다.   
      
  - __식별자관계와 비식별자관계에 따른 식별자__   
  
    - __식별자관계와 비식별자 관계의 결정__   
      - 외부식별자(Foreign Identifier)는 자기 자신의 엔터티에서 필요한 속성이 아니라 다른 엔터티와의 관계를 통해 자식 쪽에 엔터티에 생성되는 속성을 외부식별자라 하며 데이터베이스 생성 시에 Foreign Key역할   
      
    - __식별자관계__   
      - 자식엔터티의 주식별자로 부모의 주식별자가 상속이 되는 경우   
      - 부모로부터 받은 식별자를 자식엔터티의 주식별자로 이용하는 경우는 Null값이 오면 안되므로 반드시 부모엔터티가 생성되어야 자기 자신의 엔터티가 생성되는 경우   
      
    - __비식별자관계__   
      - 부모엔터티로부터 속성을 받았지만 자식엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용하는 경우   
      
    - __식별자 관계로만 설정할 경우의 문제점__   
      - 주식별자 속성이 지속적으로 증가할 수 밖에 없는 구조로서 개발자 복잡성과 오류가능성을 유발시킬 수 있는 요인이 될 수 있다   
     
    - __비식별자 관계로만 설정할 경우의 문제점__   
      - SQL구문에 많은 조인이 걸리게 되고 그에 따라 복잡성이 증가하고 성능이 저하   
      
    - __식별자관계와 비식별자관계 모델링__   
      - 비식별자관계 선택 프로세스   
      - 식별자와 비식별자관계 비교   
      - 식별자와 비식별자를 적용한 데이터 모델   
      
## 5. 성능 데이터 모델링   

  - __데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것__            
    
  - __성능 데이터 모델링 고려사항__        
    - __데이터 모델링을 할 때 정규화를 정확하게 수행한다.__        
    - __데이터베이스 용량산정을 수행한다.__        
    - __데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.__        
    - __용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.__     
    - __이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.__        
    - __성능관점에서 데이터 모델을 검증한다.__     
       
       
## 6. 정규화   
  
  - __데이터의 중복속성을 제거하고 결정자에 의해 동일한 의미의 일반속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과__        
  - __정규화 수행 모델은 데이터를 입력/수정/삭제할 때 일반적으로 반정규화된 테이블에 비해 처리 성능이 향상된다. 단 데이터를 조회할 때에는 처리 조건에 따라 조회 성능이 향상될 수도 있고 저하될 수도 있다.__        
       
  - __반정규화만이 조회 성능을 향상시킨다는 고정관념은 탈피되어야 한다.__   
    - __반정규화된 테이블의 성능저하가 있을 수 있다.__   
    
  - __함수적 종속성(Functional Dependency)에 근거한 정규화 수행 필요__   
    - __함수의 종속성(Functional Dependency)
      - 데이터들이 어떤 기준값에 의해 종속되는 현상
    - __결정자(Determinant)__   
      - 기준값   
    - __종속자(Dependent)__   
      - 종속되는 값   
  - __정규화가 잘 정의된 데이터 모델에서 성능이 저하될 수 있는 경우가 있다.__    
  
      
## 7. 반정규화  

  - __정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발(Development)과 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법__        
  
    - __반정규화를 적용하는 이유__        
      - 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능저하가 예상되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.   
      - 업무적으로 조회에 대한 처리성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려   
      - 함수적 종속관계는 위반하지 않지만 데이터의 중복성을 증가시켜야만 데이터조회의 성능을 향상시키는 경우    
    
  - __반정규화의 적용방법__        
  
    - __보통 프로젝트에서는 칼럼 중복을 통해서만 반정규화를 수행__        
      - __칼럼의 반정규화가 많은 이유__   
        - 개발을 하다가 SQL문장 작성이 복잡해지고 그에 따라 SQL단위 성능 저하가 예상이 되어 다른 테이블에서 조인하여 가져와야 할 칼럼을 기준이 되는 테이블에 중복하여 SQL문장을 단순하게 처리하도록 하기 위해 요청    
        - 데이터에 대한 무결성을 깨뜨리는 결정적인 역할을 하는 경우가 많이 있다.   
        
    - __반정규화의 대상을 조사한다.__        
      - 자주 사용되는 테이블에 접근(Access)하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하는 경우에 반정규화를 검토한다.   
      - 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없을 경우에 반정규화를 검토한다.   
      - 통계성 프로세스에 의해 통계 정보를 필요로 할 때 별도의 통계테이블(반정규화 테이블)을 생성한다.   
      - 테이블에 지나치게 많은 조인(JOIN)이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 반정규화를 검토한다.   
      
    - __반정규화의 대상에 대해 다른 방법으로 처리할 수 있는지 검토한다.__   
      - 지나치게 많은 조인(JOIN)이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 뷰(VIEW)를 사용하면 이를 해결할 수도 있다.   
      - 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우에 클러스터링을 적용하거나 인덱스를 조정함으로써 성능을 향상시킬 수 있다.   
        - 클러스터링을 적용하는 방법   
          - 대량의 데이터를 특정 클러스터링 팩트에 의해 저장방식을 다르게 하는 방법   
            - 데이터를 입력/수정/삭제하는 경우 성능이 많이 저하되므로 조회중심의 테이블이 아니라면 생성하면 안되는 오브젝트   
            - 다만, 조회가 대부분이고 인덱스를 통해 성능향상이 불가능하다면 클러스터링을 고려할 만하다.   
      - 인덱스를 통해 성능을 충분히 확보할 수 있다면 인덱스를 조정하여 반정규화를 회피   
      - 물리적인 저장기법에 따라 성능을 향상시킬 수 있는 파티셔닝 기법(Partitioning)이 적용되어 성능저하를 방지할 수 있다.   
        - 대량의 데이터는 Primary Key의 성격에 따라 부분적인 테이블로 분리할 수 있다.   
        - 데이터가 특정 기준(파티셔닝 키)에 의해 다르게 저장되고 파티셔닝 키에 따른 조회가 될 때 성능이 좋아지는 특성이 있다.   
        - 따라서 특정 기준에 의해 물리적인 저장공간이 구분될 수 있고 트랜잭션이 들어올 때 일정한 기준에 의해 들어온다면 파티셔닝 테이블을 적용하여 조회의 성능을 향상시키는 것도 좋은 방법이 될 수 있다.   
      - 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.   
        - 응용 메모리 영역에 데이터를 처리하기 위한 값을 캐쉬한다든지 중간 클래스 영역에 데이터를 캐쉬하여 공유하게 하여 성능을 향상 시키는 것도 성능을 향상   
        
    - __반정규화를 적용한다.__   
      - 반정규화를 적용하기 이전에 사전에 충분히 성능에 대한 고려가 이루어져서 반정규화를 적용해야겠다는 판단이 들었다면 이 때 반정규화의 세 가지 규칙을 고려하여 반정규화를 적용   
      - 반정규화의 기법   
        - 테이블 반정규화   
        - 칼럼 반정규화   
        - 관계 반정규화   
      - 테이블과 칼럼의 반정규화는 데이터 무결성에 영향을 미치게 되나 관계의 반정규화는 데이터 무결성을 깨뜨릴 위험을 갖지 않고서도 데이터처리의 성능을 향상시킬 수 있는 반정규화의 기법이 된다.   
      - 데이터 모델 전체가 관계로 연결되어 있고 관계가 서로 먼 친척간에 조인관계가 빈번하게 되어 성능저하가 예상이 된다면 관계의 반정규화를 통해 성능향상을 도모할 필요가 있다.   

  - __반정규화를 적용할 때 기억해야 할 내용은 데이터를 입력, 수정, 삭제할 때는 성능이 떨어지는 점을 기억해야 하고 데이터의 무결성 유지에 주의를 해야 한다.__   
  
## 8. 대량 데이터    

  - __한 테이블에 데이터가 대량으로 집중되거나 하나의 테이블에 여러 개의 칼럼이 존재하여 디스크에 많은 블록을 점유하는 경우는 모두 성능저하를 유발할 수 있는 경우__   
  
    - 하나의 테이블에 대량의 데이터가 존재하는 경우에는 인덱스의 Tree구조가 너무 커져 효율성이 떨어져 데이터를 처리(입력, 수정, 삭제, 조회)할 때 디스크 I/O를 많이 유발하게 된다.   
    - 한 테이블에 많은 수의 칼럼이 존재하게 되면 데이터가 디스크의 여러 블록에 존재하므로 인해 디스크에서 데이터를 읽는 I/O량이 많아지게 되어 성능이 저하되게 된다.   
      -  데이터를 처리할 때 여러 블록에서 데이터를 I/O해야 하는 즉 SQL문장의 성능이 저하될 수 특징을 가지게 된다.   
    
  - __대량의 데이터가 처리되는 테이블에 성능이 저하되는 이유__        
  
    - __SQL문장에서 데이터를 처리하기 위한 I/O의 양이 증가하기 때문이다.__        
    
    - __대량의 데이터가 하나의 테이블에 존재하게 되면 인덱스를 생성할 때 인덱스의 크기(용량)가 커지게 되고 그렇게 되면 인덱스를 찾아가는 단계가 깊어지게 되어 조회의 성능에도 영향을 미치게 된다.__   
      - 인덱스 크기가 커질 경우 조회의 성능에는 영향을 미치는 정도가 작지만 데이터를 입력/수정/삭제하는 트랜잭션의 경우 인덱스의 특성상 일량이 증가하여 더 많이 성능의 저하를 유발하게 된다.   
      - 또한 데이터에 대한 범위 조회시 더 많은 I/O 유발할 수 있게 되어 성능저하를 유발할 수 있게 된다.   
      
    - __로우체이닝(Row Chaining) 현상__    
      - 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태  
      
    - __로우마이그레이션(Row Migration)__    
      - 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식  
      
    - __로우체이닝과 로우마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 데이터베이스 메모리에서 디스크와 I/O(입력/출력)가 발생할 때 불필요하게 I/O가 많이 발생하여 성능이 저하된다.__   
    
  - __테이블에 많은 양의 데이터가 예상될 경우 파티셔닝을 적용하거나 PK에 의해 테이블을 분할하는 방법을 적용할 수 있다.__    
    - 데이터량이 몇 천만건을 넘어서면 아무리 서버사양이 훌륭하고 인덱스를 잘 생성해준다고 하더라고 SQL문장의 성능이 나오지 않는다. 이 때는 논리적으로는 하나의 테이블로 보이지만 물리적으로 여러 개의 테이블스페이스에 쪼개어 저장될 수 있는 구조의 파티셔닝을 적용하도록 한다.   
    - __RANGE PARTITION(범위) 적용__    
      - 대상 테이블이 날자 또는 숫자값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리된다면 RANGE PARTITION을 적용   
      - 데이터보관주기에 따라 테이블에 데이터를 쉽게 지우는 것이 가능하므로(파티션 테이블을 DROP하면 되므로) 데이터보관주기에 다른 테이블관리가 용이하다.   
    - __LIST PARTITION(특정값 지정) 적용__   
      - PK가 구성되어 있고 대량의 데이터가 있는 테이블이라면 값 각각에 의해 파티셔닝이 되는 LIST PARTITION을 적용할 수 있다.   
      - 대용량 데이터를 특정값에 따라 분리 저장할 수는 있으나 RANGE PARTITION과 같이 데이터 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없다.   
    - __HASH PARTITION(해쉬적용)__   
      - 지정된 HASH 조건에 따라 해슁 알고리즘이 적용되어 테이블이 분리되며 설계자는 테이블에 데이터가 정확하게 어떻게 들어갔는지 알 수 없다. 역시 성능향상을 위해 사용하며 데이터 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없다.   
    - __COMPOSITE PARTITION(범위와 해쉬가 복합)__    
    
    
  - __테이블에 대한 수평분할/수직분할의 절차__        
    - __4가지 원칙__        
      - __데이터 모델링을 완성한다.__   
      - __데이터베이스 용량산정을 한다.__        
      - __대량 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴을 분석한다.__   
      - __칼럼 단위로 집중화된 처리가 발생하는지, 로우단위로 집중화된 처리가 발생되는지 분석하여 집중화된 단위로 테이블을 분리하는 것을 검토한다.__       
    - 칼럼의 수가 많은 경우 트랜잭션의 특성에 따라 테이블을 1:1 형태로 분리할 수 있는지 검증하면 된다.   
    - 칼럼의 수가 적지만 데이터용량이 많아 성능저하가 예상이 되는 경우 테이블에 대해 파티셔닝 전략을 고려하도록 한다.   
    
## 9. 데이터베이스 구조와 성능       
    
  - __슈퍼/서브타입 데이터 모델의 개요__     
    - __Extended ER모델__        
      - 데이터의 특징을 공통과 차이점의 특징을 고려하여 효과적으로 표현할 수 있어 자주 쓰인다.   
      - 즉, 공통의 부분을 슈퍼타입으로 모델링하고 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성에 대해서는 별도의 서브엔터티로 구분하여 업무의 모습을 정확하게 표현하면서 물리적인 데이터 모델로 변환을 할 때 선택의 폭을 넓힐 수 있는 장점   
      - 논리적인 데이터 모델에서 이용되는 형태이고 분석/설계단계를 구분하자면, 분석단계에서 많이 쓰이는 모델   
      - 따라서 물리적인 데이터 모델을 설계하는 단계에서는 슈퍼/서브타입 데이터 모델을 일정한 기준에 의해 변환을 해야 한다.    
    
  - __슈퍼/서브타입 데이터 모델의 변환__        
    - __슈퍼/서브타입에 대한 변환을 잘못하면 성능이 저하되는 이유__        
      - 트랜잭션 특성을 고려하지 않고 테이블이 설계되었기 때문이다.   
        - 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union연산에 의해 성능이 저하될 수 있다.   
        - 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터가 집약되어 있어 성능이 저하되는 경우가 있다.   
        - 트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능이 저하되는 경우가 있다.   
    - __슈퍼/서브타입을 성능을 고려한 물리적인 데이터 모델로 변환하는 기준은 데이터 양과 해당 테이블에 발생되는 트랜잭션의 유형에 따라 결정된다.__   
    - __데이터량에 따른 변형__   
      - 소량일 경우 성능에 영향을 미치지 않기 때문에 데이터처리의 유연성을 고려하여 가급적 1:1 관계를 유지하는 것이 바람직하다.    
      - 데이터용량이 많아지는 경우 그리고 해당 업무적인 특징이 성능에 민감한 경우는 트랜잭션이 해당 테이블에 어떻게 발생되는지에 따라 3가지 변환방법을 참조하여 상황에 맞게 변환하도록 해야 한다.   
    
  - __슈퍼/서브 타입 데이터 모델의 변환기술__        
    - __개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성__        
      - 슈퍼타입과 서브타입각각에 대해 독립적으로 트랜잭션이 발생이 되면 슈퍼타입에도 꼭 필요한 속성만을 가지게 하고 서브타입에도 꼭 필요한 속성 및 자신이 타입에 맞는 데이터만 가지게 하기 위해서 모두 분리하여 1:1 관계를 갖도록 한다.    
    - __슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성__        
      - 슈퍼타입과 서브타입을 묶어 트랜잭션이 발생하는 업무특징을 가지고 있을 때에는 다음 데이터 모델과 같이 슈퍼타입+각서브타입을 하나로 묶어 별도의 테이블로 구성하는 것이 효율적이다.   
    - __전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성__   
      - 슈퍼타입과 서브타입의 테이블들을 하나로 묶었을 때 각각의 속성별로 제약사항(NULL/NOT NULL, 기본값, 체크값)을 정확하게 지정하지 못할지라도 대용량이고 성능향상이 필요하다면 하나의 테이블로 묶어서 만들어 준다.   
      
  - __인덱스 특성을 고려한 PK/FK 데이터베이스 성능향상__        
    - __인덱스__        
      - PK/FK 칼럼 순서와 성능개요 데이터를 조회할 때 가장 효과적으로 처리될 수 있도록 접근경로를 제공하는 오브젝트   
      - 데이터베이스 테이블에서는 균형 잡힌 트리구조의 B*Tree구조를 많이 사용한다.   
      - 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다.   
      - 앞쪽에 위치한 속성 값이 가급적 ‘=’ 아니면 최소한 범위 ‘BETWEEN’ ‘< >’가 들어와야 인덱스를 이용할 수 있는 것이다.   

    - __설계단계 말에 칼럼의 순서를 조정할 필요가 있다.__        
    - __PK__        
      - 해당테이블의 데이터를 접근하는 가장 빈번하게 사용되는 유일한 인덱스(Unique Index)를 모두 자동 생성한다.   
      - PK순서를 결정하는 기준은 인덱스 정렬구조를 이해한 상태에서 인덱스를 효율적으로 이용할 수 있도록 PK순서를 지정해야 한다.   
    - __FK__   
      - 데이터를 조회할 때 조인의 경로를 제공하는 역할을 수행   
      - FK에 대해서는 반드시 인덱스를 생성하도록 하고 인덱스 칼럼의 순서도 조회의 조건을 고려하여 접근이 가장 효율적인 칼럼 순서대로 인덱스를 생성하도록 주의해야 한다.   
    - __PK/FK설계는 업무적 의미로도 매우 중요한 의미를 가지고 있지만 데이터를 접근할 때 경로를 제공하는 성능의 측면에서도 중요한 의미를 가지고 있기 때문에 성능을 고려한 데이터베이스 설계가 될 수 있도록 설계단계 말에 칼럼의 순서를 조정할 필요가 있다.__   
    - __PK칼럼의 순서를 조정하지 않으면 성능이 저하 이유__        
      - 데이터 모델링에서 엔터티를 설계하면 그에 따라 DDL이 생성이 되고 생성된 DDL에 따라 인덱스가 생성된다.   
      - 인덱스의 정렬된 첫 번째 칼럼에 비교가 되었을 때 순차적으로 데이터를 찾아가게 된다.   
      - 맨 앞에 있는 칼럼이 제외된 상태에서 데이터를 조회 할 경우 데이터를 비교하는 범위가 매우 넓어지게 되어 성능 저하를 유발하게 된다.   
        - 인덱스를 읽고 테이블 블록에서 읽어 처리하는데 I/O가 많이 발생하게 되므로 옵티마이저는 차라리 테이블에 가서 전체를 읽는 방식으로 처리하게 된다.   
    - __PK의 순서를 인덱스 특징에 맞게 고려하지 않고 바로 그대로 생성하게 되면, 테이블에 접근하는 트랜잭션의 특징에 효율적이지 않은 인덱스가 생성되어 있으므로 인덱스의 범위를 넓게 이용하거나 Full Scan을 유발하게 되어 성능이 저하된다고 정리할 수 있다.__   
      - PK순서를 잘못 지정하여 성능이 저하된 경우   
      - 물리적인 테이블에 FK제약이 걸려있지 않을 경우 인덱스 미생성으로 성능저하   
      
      
## 10. 분산 데이터베이스   

  - __정의__        
    - __여러 곳으로 분산되어있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스__        
    - __논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임. 물리적 Site 분산, 논리적으로 사용자 통합·공유__        
    - __즉, 분산 데이터베이스는 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역 여러 노드로 위치시켜 사용성/성능 등을 극대화 시킨 데이터베이스__    
    
  - __분산 데이터베이스의 6가지 투명성(Transparency)__        
    - __분할 투명성 (단편화)__        
      - 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장   
    - __위치 투명성__        
      - 사용하려는 데이터의 저장 장소 명시 불필요. 위치정보가 System Catalog에 유지되어야 함   
    - __지역사상 투명성__        
      - 지역DBMS와 물리적 DB사이의 Mapping 보장. 각 지역시스템 이름과 무관한 이름 사용 가능   
    - __중복 투명성__        
      - DB 객체가 여러 site에 중복 되어 있는지 알 필요가 없는 성질   
    - __장애 투명성__        
      - 구성요소(DBMS, Computer)의 장애에 무관한 Transaction의 원자성 유지   
    - __병행 투명성__        
      - 다수 Transaction 동시 수행시 결과의 일관성 유지, Time Stamp, 분산 2단계 Locking을 이용 구현   
    
  - __데이터베이스 분산구성의 가치__        
    - __통합된 데이터베이스에서 제공할 수 없는 빠른 성능을 제공__        
    
  - __분산 데이터베이스의 적용 기법__        
  
    - __테이블 위치 분산__        
      - 테이블 위치 분산은 테이블의 구조는 변하지 않는다. 또한 테이블이 다른 데이터베이스에 중복되어 생성되지도 않는다. 다만 설계된 테이블의 위치를 각각 다르게 위치시키는 것이다   
      - 테이블별 위치 분산은 정보를 이용하는 형태가 각 위치별로 차이가 있을 경우에 이용한다.   
      - 테이블의 위치가 위치별로 다르므로 테이블의 위치를 파악할 수 있는 도식화된 위치별 데이터베이스 문서가 필요하다.   
      
    - __테이블 분할(Fragmentation) 분산__        
    
      - 단순히 위치만 다른 곳에 두는 것이 아니라 각각의 테이블을 쪼개어 분산하는 방법   
      - 분살하는 방법 2가지   
        - __로우(Row)단위로 분리하는 수평분할(Horizontal Fragmentation)__   
          - 지사(Node)에 따라 테이블을 특정 칼럼의 값을 기준으로 로우(Row)를 분리한다. 칼럼은 분리되지 않는다. 모든 데이터가 각 지사별로 분리되어 있는 형태를 가지고 있다.   
          - 각 지사에 존재하는 테이블에 대해서 통합처리를 해야 하는 경우는 조인(JOIN)이 발생하여 성능 저하가 예상되므로 통합처리 프로세스가 많은지를 먼저 검토한 이후에 많지 않은 경우에 수평분할을 해야 한다.   
          - 데이터가 지사별로 별도로 존재하므로 중복은 발생하지 않는다. -> 무결성 보장   
          
        - __칼럼(Column) 단위로 분할하는 수직분할(Vertical Fragmentation)__   
          - 지사(Node)에 따라 테이블 칼럼을 기준으로 칼럼(Row)을 분리한다. 로우(Row) 단위로는 분리되지 않는다. 모든 데이터가 각 지사별로 분리되어 있는 형태를 가지고 있다.   
          - 지사별로 쪼개어진 테이블들을 조합하면 Primary Key가 동일한 데이터의 조합이 가능해야 하며 하나의 완전한 테이블이 구성되어야 한다.   
          - 칼럼을 기준으로 분할하였기 때문에 각각의 테이블에는 동일한 Primary Key구조와 값을 가지고 있어야 한다.   
          - 테이블의 전체 칼럼 데이터를 보기 위해서는 각 지사(Node)별로 흩어져 있는 테이블들을 조인(JOIN)하여 가져와야 하므로 가능하면 통합하여 처리하는 프로세스가 많은 경우에는 이용하지 않도록 한다.   
          
    - __테이블 복제(Replication) 분산__        
      - 가장 많이 사용   
      - 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형   
      
      - __부분복제(Segment Replication)__    
        - 마스터 데이터베이스에서 테이블의 일부의 내용만 다른 지역이나 서버에 위치   
        - 통합된 테이블을 한군데(본사)에 가지고 있으면서 각 지사별로는 지사에 해당된 로우(Row)를 가지고 있는 형태   
        - 각 지사에서 데이터 처리가 용이할 뿐만 아니라 전체 데이터에 대한 통합처리도 본사에 있는 통합 테이블을 이용하게 되므로 여러 테이블에 조인(JOIN)이 발생하지 않는 빠른 작업 수행이 가능해진다.   
        - 보통 지사에 데이터가 먼저 발생하고 본사에 데이터는 지사에 데이터를 이용하여 통합하여 발생된다.   
          - 지사에서 데이터에 대한 입력, 수정, 삭제가 발생하여 본사에서 이용하는 방식   
        - 다른 지역간의 데이터를 복제(Replication)하는데 많은 시간이 소요되고 데이터베이스와 서버에 부하(Load)가 발생하므로 보통 실시간(On-Line) 처리에 의해 복사하는 것보다는 야간에 배치 작업에 의해 수행되는 경우가 많이 있다.   
        - 본사와 지사 양쪽 모두 데이터를 수정하여 전송하는 경우 데이터의 정합성을 일치시키는 것이 어렵기 때문에 가능하면 한쪽(지사)에서 데이터의 수정이 발생하여 본사로 복제(Replication)를 하도록 한다.   
        
      - __광역복제(Broadcast Replication)__   
        - 마스터 데이터베이스의 테이블의 내용을 각 지역이나 서버에 존재   
        - 통합된 테이블을 한군데(본사)에 가지고 있으면서 각 지사에도 본사와 동일한 데이터를 모두 가지고 있는 형태   
        - 본사에서는 데이터를 관리하고 지사에서는 이 데이터를 읽어 업무프로세스를 발생시키는 것이다.   
          -  본사에서 데이터가 입력, 수정, 삭제가 되어 지사에서 이용하는 형태   
        - 데이터를 복제(Replication)하는데 많은 시간이 소요되고 데이터베이스와 서버에 부하(Load)가 발생하므로 보통 실시간(On-Line) 처리에 의해 복사하는 것보다는 야간에 배치에 의해 복제가 되도록 한다.   
        
    - __테이블 요약(Summarization) 분산__    
      - 지역간에 또는 서버 간에 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우   
      - 분석요약(Rollup Summarization)   
        - 동일한 테이블 구조를 가지고 있으면서 분산되어 있는 동일한 내용의 데이터를 이용하여 통합된 데이터를 산출   
        - 각 지사별로 존재하는 요약정보를 본사에 통합하여 다시 전체에 대해서 요약정보를 산출하는 분산방법   
        - 테이블에 있는 모든 칼럼(Column)과 로우(Row)가 지사에도 동일하게 존재하지만, 각 지사에는 동일한 내용에 대해 지사별로 요약되어 있는 정보를 가지고 있고 본사에는 각 지사의 요약정보를 통합하여 재산출하여 전체에 대한 요약정보를 가지고 있는 것   
        - 각종 통계데이터를 산정할 경우에, 모든 지사의 데이터를 이용하여 처리하면 성능이 지연되고 각 지사 서버에 부하를 주기 때문에 업무에 장애가 발생할 수 있다.   
        - 통합 통계데이터에 대한 정보제공에 용이한 분산방법    
        - 본사에 분석 요약된 테이블을 생성하고 데이터는 역시 일반 업무가 종료되는 야간에 수행하여 생성한다.   

      - 통합요약(Consolidation Summarization)   
        - 분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출   
        - 각 지사별로 존재하는 다른 내용의 정보를 본사에 통합하여 다시 전체에 대해서 요약정보를 산출하는 분산방법   
        - 테이블에 있는 모든 칼럼(Column)과 로우(Row)가 지사에도 동일하게 존재하지만 각 지사에는 타지사와 다른 요약정보를 가지고 있고 본사에는 각 지사의 요약정보를 데이터를 같은 위치에 두는 것으로 통합하여 전체에 대한 요약정보를 가지고 있는 것    
        - 지사에서 요약한 정보를 본사에서 취합하여 각 지사별로 데이터를 비교하기 위해 이용되는 것   
        - 각종 통계데이터를 산정할 경우에, 모든 지사의 데이터를 조인하여 처리하면 성능이 지연되고 각 지사 서버에 부하(LOAD)를 주기 때문에 업무에 장애가 발생할 수 있다.   
        - 통합 통계데이터에 대한 정보제공에 용이한 분산방법   
        - 본사에 통합 요약된 테이블을 생성하고 데이터는 역시 일반 업무가 종료되는 야간에 수행하여 생성   
        
  - __분산 데이터베이스를 적용해야 하는 경우__        
    - __성능이 중요한 사이트에 적용해야 한다.__        
    - __공통코드, 기준정보, 마스터 데이터 등에 대해 분산환경을 구성하면 성능이 좋아진다.__        
    - __실시간 동기화가 요구되지 않을 때 좋다. 거의 실시간(Near Real Time)의 업무적인 특징을 가지고 있을 때도 분산 환경을 구성할 수 있다__   
    - __특정 서버에 부하가 집중이 될 때 부하를 분산할 때도 좋다.__   
    - __백업 사이트(Disaster Recovery Site)를 구성할 때 간단하게 분산기능을 적용하여 구성할 수 있다.__   
    
    
 # SQL 기본 및 활용      
## 1. 관계형 데이터베이스   
  - __데이터베이스__   
    - __특정 기업이나 조직 또는 개인이 필요에 의해(ex: 부가가치가 발생하는) 데이터를 일정한 형태로 저장해 놓은 것__        
    - __DBMS(Database Management System)__   
      - 효율적인 데이터의 관리 뿐만 아니라 예기치 못한 사건으로 인한 데이터의 손상을 피하고, 필요시 필요한 데이터를 복구하기 위한 강력한 기능의 소프트웨어   
    
  - __관계형 데이터베이스__        
    - __정규화를 통한 합리적인 테이블 모델링을 통해 이상(ANOMALY) 현상을 제거하고 데이터 중복을 피할 수 있으며, 동시성 관리, 병행 제어를 통해 많은 사용자들이 동시에 데이터를 공유 및 조작할 수 있는 기능을 제공__        
    - __인증된 사용자만이 참조할 수 있도록 보안 기능을 제공__        
    - __데이터의 성격, 속성 또는 표현 방법 등을 체계화할 수 있고, 데이터 표준화를 통한 데이터 품질을 확보__   
    - __데이터 무결성(Integrity)을 보장__   
    - __모든 데이터를 칼럼과 행의 2차원 구조__   
      - 세로 방향 = 칼럼(Column)/열    
      - 가로 방향 = 행(Row)   
      - 칼럼과 행이 겹치는 하나의 공간 = 필드(Field)   
    
  - __SQL(Structured Query Language)__        
    - __대부분 ANSI/ISO를 통해 표준화__        
    - __DDL, DML, DCL__       
    
  - __TABLE__        
    - __데이터를 저장하는 객체(Object)로서 관계형 데이터베이스의 기본 단위__        
    - __어느 특정한 주제와 목적으로 만들어지는 일종의 집합__        
    - __정규화(Normalization)__   
      - 테이블을 분할하여 데이터의 불필요한 중복을 줄이는 것   
      - 데이터의 정합성 확보와 데이터 입력/수정/삭제시 발생할 수 있는 이상현상(Anomaly)을 방지   
    - __기본키(Primary Key)__     
      - __각 행을 한 가지 의미로 특정할 수 있는 한 개 이상의 칼럼__      
    - __외부키(Foreign Key)__        
      - __다른 테이블의 기본키로 사용되면서 테이블과의 관계를 연결하는 역할__   
    
  - __ERD(Entity Relationship Diagram)__        
    - __테이블 간 서로의 상관 관계를 그림으로 도식화한 것__        
    - __ERD의 구성 요소__    
      - 엔터티(Entity)   
      - 관계(Relationship)   
      - 속성(Attribute)   
      
## 2. DDL      
  - __데이터 유형__        
    - __숫자형 타입__    
      - __ANSI/ISO__   
        - NUMERIC, DECIMAL, DEC, SMALLINT, INTEGER, INT, BIGINT, FLOAT, REAL, DOUBLE PRECISION   
        - __Oracle__ 은 숫자형 타입 NUMBER 하나만 지원한다.   
    - __문자열 타입__    
      - __VARCHAR__   
        - 맨 처음부터 한 문자씩 비교하고 공백도 하나의 문자로 취급하므로 끝의 공백이 다르면 다른 문자로 판단한다.   
        - 가변 길이이므로 필요한 영역은 실제 데이터 크기   
        - 길이가 다양한 칼럼과, 정의된 길이와 실제 데이터 길이에 차이가 있는 칼럼에 적합   
        - CHAR 유형보다 작은 영역에 저장   
      - __CHAR__   
        - 문자열을 비교할 때 공백(BLANK)을 채워서 비교하는 방법을 사용   
          - 공백 채우기 비교에서는 우선 짧은 쪽의 끝에 공백을 추가하여 2개의 데이터가 같은 길이가 되도록 한다.   
          - 앞에서부터 한 문자씩 비교한다.   
          - 끝의 공백만 다른 문자열은 같다고 판단된다.   
      
      __문자열(CHAR와 VARCHAR)에 대한 최대 길이와 NUMBER 칼럼의 정밀도(Precision)를 지정하는 것은 테이블 설계시 반드시 고려해야 할 중요 요소__    
        - 잘못된 판단은 추후 ALTER TABLE 명령으로 정정할 수는 있지만 데이터가 입력된 상황이라면 처리 과정이 쉽지 않다.   
    
  - __CREATE TABLE__      
    - __테이블과 칼럼 정의__   
      - __해당 테이블에 입력될 데이터를 정의하고, 정의한 데이터를 어떠한 데이터 유형으로 선언할 것인지를 결정__        
      - __기본키 칼럼 지정 필요__        
      - __정규화를 통해 수정/삭제 이상 현상 방지 필요__    
      - __테이블과 테이블 간에 정의된 관계는 기본키와 외부키를 활용하여 설정__   
      
    - __CREATE TABLE__        
      - `CREATE　TABLE　테이블이름 ( 칼럼명1 DATATYPE [DEFAULT 형식], 칼럼명2 DATATYPE [DEFAULT 형식], 칼럼명2 DATATYPE [DEFAULT 형식] );`
      - __단수형 테이블명__   
      - __다른 테이블 이름과 중복 X__   
      - __각 칼럼들은 괄호 "( )" 로 묶어 지정__    
      - __테이블명과 칼럼명은 반드시 문자로 시작__     
      - __단수형 테이블명__     
      - __`A-Z, a-z, 0-9, _, $, #` 문자만 허용__        
      - __추가적인 주의사항__   
        - 테이블 생성시 대/소문자 구분은 하지 않는다.    
        - DATETIME 데이터 유형에는 별도로 크기를 지정하지 않는다.   
        - 문자 데이터 유형은 반드시 가질 수 있는 최대 길이를 표시해야 한다.   
        - 칼럼과 칼럼의 구분은 콤마로 하되, 마지막 칼럼은 콤마를 찍지 않는다.   
        - 칼럼에 대한 제약조건이 있으면 CONSTRAINT를 이용하여 추가할 수 있다.   
    
  - __제약조건(CONSTRAINT)__        
    - __데이터의 무결성을 유지하기 위한 데이터베이스의 보편적인 방법으로 테이블의 특정 칼럼에 설정하는 제약__        
    - __NULL__   
      - __NULL(ASCII 코드 00번)은 공백(BLANK, ASCII 코드 32번)이나 숫자 0(ZERO, ASCII 48)과는 전혀 다른 값이며, 조건에 맞는 데이터가 없을 때의 공집합과도 다르다.__        
      - __‘NULL’은 ‘아직 정의되지 않은 미지의 값’이거나 ‘현재 데이터를 입력하지 못하는 경우’를 의미한다.__   
    - __DEFAULT__   
      - 데이터 입력시 명시된 값을 지정하지 않은 경우에 NULL 값이 입력되고, DEFAULT 값을 정의했다면 해당 칼럼에 NULL 값이 입력되지 않고 사전에 정의된 기본 값이 자동으로 입력   

  - __생성된 테이블 구조 확인__        
    - `DESC 테이블명;`        
    
  - __SELECT 문장을 통한 테이블 생성 사례__        
    - __CTAS(Create Table ~ As Select ~)__   
      - SELECT 문장을 활용해서 테이블을 생성할 수 있는 방법   
      - 칼럼별로 데이터 유형을 다시 재정의 하지 않아도 되는 장점   
      - __주의할 점__   
        - 기존 테이블의 제약조건 중에 NOT NULL만 새로운 복제 테이블에 적용이 되고, 기본키, 고유키, 외래키, CHECK 등의 다른 제약 조건은 없어진다는 점   
        - 제약 조건을 추가하기 위해서는 뒤에 나오는 ALTER TABLE 기능을 사용해야 한다.   
  - __ALTER TABLE__   
    - 주로 칼럼을 추가/삭제하거나 제약조건을 추가/삭제하는 작업   
    - __ADD COLUMN__   
      - `ALTER TABLE 테이블명 ADD 추가할 칼럼명 데이터 유형;`   
      - 새롭게 추가된 칼럼은 테이블의 마지막 칼럼이 되며 칼럼의 위치를 지정할 수는 없다.   
    - __DROP COLUMN__   
      - `ALTER TABLE 테이블명 DROP COLUMN 삭제할 칼럼명;`   
      - 테이블에서 필요 없는 칼럼을 삭제할 수 있으며, 데이터가 있거나 없거나 모두 삭제 가능하다.   
      - 한 번에 하나의 칼럼만 삭제 가능하며, 칼럼 삭제 후 최소 하나 이상의 칼럼이 테이블에 존재해야 한다.   
    - __MODIFY COLUMN__   
      - `ALTER TABLE 테이블명 MODIFY (칼럼명1 데이터 유형 [DEFAULT 식] [NOT NULL], 칼럼명2 데이터 유형 …);`   
      - 칼럼의 데이터 유형, 디폴트(DEFAULT) 값, NOT NULL 제약조건에 대한 변경   
      - __변경 시 고려사항__   
        - 해당 칼럼의 크기를 늘릴 수는 있지만 줄이지는 못한다.   
        - 해당 칼럼이 NULL 값만 가지고 있거나 테이블에 아무 행도 없으면 칼럼의 폭을 줄일 수 있다.   
        - 해당 칼럼이 NULL 값만을 가지고 있으면 데이터 유형을 변경할 수 있다.   
        - 해당 칼럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미치게 된다.   
        - 해당 칼럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다.   
    - __RENAME COLUMN__   
      - `ALTER TABLE 테이블명 RENAME COLUMN 변경해야 할 칼럼명 TO 새로운 칼럼명;`      
      - 칼럼명을 어떤 이유로 불가피하게 변경해야 하는 경우 사용   
      - 칼럼명이 변경되면, 해당 칼럼과 관계된 제약조건에 대해서도 자동으로 변경되는 장점이 있지만 Oracle과 같은 일부 DBMS에서만 지원하는 기능이다.   
    - __DROP CONSTRAINT__   
      - `ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;`   
      - 테이블 생성 시 부여했던 제약조건을 삭제하는 명령   
    - __ADD CONSTRAINT__   
      - `ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 제약조건 (칼럼명);`   
      - 특정 칼럼에 제약조건을 추가하는 명령어   
    - __RENAME TABLE__   
      - `RENAME 변경전 테이블명 TO 변경후 테이블명;`   
      - 테이블의 이름을 변경 명령    
    - __DROP TABLE__   
      - `DROP TABLE 테이블명 [CASCADE CONSTRAINT];`   
      - 불필요한 테이블을 삭제하는 명령   
      - 테이블의 모든 데이터 및 구조를 삭제   
        - __CASCADE CONSTRAINT 옵션__   
          - 해당 테이블과 관계가 있었던 참조되는 제약조건에 대해서도 삭제한다는 것을 의미   
    - __TRUNCATE TABLE__   
      - `TRUNCATE TABLE PLAYER;`   
      - 해당 테이블에 들어있던 모든 행들이 제거되고 저장 공간을 재사용 가능하도록 해제   
      - 테이블 구조는 그대로 유지한 체 데이터만 전부 삭제하는 기능   
    - __테이블의 전체 데이터를 삭제하는 경우, 시스템 활용 측면에서는 DELETE TABLE 보다는 시스템 부하가 적은 TRUNCATE TABLE을 권고한다__   

## 3. DML      
  - __INSERT__        
    - __테이블에 데이터를 입력하는 2가지 방법__        
      - `INSERT INTO 테이블명 (COLUMN_LIST)VALUES (COLUMN_LIST에 넣을 VALUE_LIST);`   
        - 테이블의 칼럼을 정의할 수 있는데, 이때 칼럼의 순서는 테이블의 칼럼 순서와 매치할 필요는 없으며, 정의하지 않은 칼럼은 Default로 NULL 값이 입력된다.   
        - 단, Primary Key나 Not NULL 로 지정된 칼럼은 NULL이 허용되지 않는다.   
      - `INSERT INTO 테이블명VALUES (전체 COLUMN에 넣을 VALUE_LIST);   
        - 모든 칼럼에 데이터를 입력하는 경우로 굳이 COLUMN_LIST를 언급하지 않아도 되지만, 칼럼의 순서대로 빠짐없이 데이터가 입력되어야 한다.   
      - 해당 칼럼명과 입력되어야 하는 값을 서로 1:1로 매핑해서 입력하면 된다.    
      - 데이터 유형이 CHAR나 VARCHAR2 등 문자 유형일 경우 『 ' 』(SINGLE QUOTATION)로 입력할 값을 입력   
      - 숫자일 경우 『 ' 』(SINGLE QUOTATION)을 붙이지 않아야 한다.   
  - __UPDATE__        
    - `UPDATE 테이블명 SET 수정되어야 할 칼럼명 = 수정되기를 원하는 새로운 값;`           
    - 데이터 수정        
    
  - __DELETE__        
    - `DELETE [FROM] 삭제를 원하는 정보가 들어있는 테이블명;`        
    - 데이터 삭제        
    - __DDL 명령어와 DML 명령어를 처리하는 방식에 있어서 차이__   
      - DDL(CREATE, ALTER, RENAME, DROP) 명령어인 경우에는 직접 데이터베이스의 테이블에 영향을 미치기 때문에 DDL 명령어를 입력하는 순간 명령어에 해당하는 작업이 즉시(AUTO COMMIT) 완료   
      - DML(INSERT, UPDATE, DELETE, SELECT) 명령어의 경우, 조작하려는 테이블을 메모리 버퍼에 올려놓고 작업을 하기 때문에 실시간으로 테이블에 영향을 미치는 것은 아니다.   
        - 따라서 버퍼에서 처리한 DML 명령어가 실제 테이블에 반영되기 위해서는 COMMIT 명령어를 입력하여 TRANSACTION을 종료해야 한다.    
      - __테이블의 전체 데이터를 삭제하는 경우__   
        - 시스템 활용 측면에서는 삭제된 데이터를 로그로 저장하는 DELETE TABLE 보다는 시스템 부하가 적은 TRUNCATE TABLE을 권고한다.   
  - __SELECT__        
    - `SELECT [ALL/DISTINCT] 칼럼명 FROM 테이블명;`           
    - __데이터 조회__        
      - __ALL__   
        - Default 옵션이므로 별도로 표시하지 않아도 된다.   
      - __DISTINCT__   
        - 중복된 데이터가 있는 경우 1건으로 처리해서 출력한다.   
      - __애스터리스크(*)__   
        - `SELECT * FROM 테이블명;`   
        - 테이블의 모든 칼럼 정보를 보고 싶을 경우 사용   
      - __ALIAS__   
        - `SELECT [ALL/DISTINCT] 칼럼명 AS ALIAS FROM 테이블명;`  
        - 칼럼 레이블을 변경   
        - 칼럼명 바로 뒤에 온다. - 칼럼명과 ALIAS 사이에 AS, as 키워드를 사용할 수도 있다.   
        - "" 이중 인용부호(Double quotation)는 ALIAS가 공백, 특수문자를 포함할 경우와 대소문자 구분이 필요할 경우 사용된다.   
          - `SELECT [ALL/DISTINCT] 칼럼명 "ALIAS" FROM 테이블명;`   
          
  - __산술 연산자와 합성 연산자__   
    - __산술 연산자__   
      - NUMBER와 DATE 자료형에 대해 적용   
      - 우선순위를 위한 () 괄호 적용이 가능   
      - 4칙 연산과 동일하다. `*, /, +, -`   
    - __합성(CONCATENATION) 연산자__   
      - 문자와 문자를 연결하는 합성(CONCATENATION) 연산자를 사용하면 별도의 프로그램 도움 없이도 SQL 문장만으로도 유용한 리포트를 출력할 수 있다.   
      - 문자와 문자를 연결하는 경우 2개의 수직 바(||)에 의해 이루어진다.   
        - (Oracle) - 문자와 문자를 연결하는 경우 + 표시에 의해 이루어진다.   
        - `Oracle SELECT 칼럼명 || '문자,' || 칼럼명2 FROM 테이블;`   
    
## 4. DCL          
  - __트랜잭션__        
    - __데이터베이스의 논리적 연산단위__        
    - __밀접히 관련되어 분리될 수 없는 한 개 이상의 데이터베이스 조작을 가리킨다.__        
    - __하나의 트랜잭션에는 하나 이상의 SQL 문장이 포함된다. 트랜잭션은 분할할 수 없는 최소의 단위이다.__   
      - ALL OR NOTHING의 개념인 전부 적용하거나 전부 취소한다.   
      - ex) 은행 계좌이체   
      
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
## 5. WHERE 절          
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
