# :bookmark_tabs: SQLD 정리   
* [데이터 모델링의 이해](#데이터-모델링의-이해)
  * [1. 데이터 모델의 이해](#1-데이터-모델의-이해)    
  * [2. Entity](#2-엔터티)    
  * [3. 속성](#3-속성)   
  * [4. 관계](#4-관계)   
  * [5. 성능 데이터 모델링](#5-성능-데이터-모델링)    
  * [6. 정규화](#6-정규화)   
  * [7. 반정규화](#7-반정규화)   
  * [8. 대량 데이터](#8-대량-데이터)   
  * [9. 데이터베이스 구조와 성능](#9-데이터베이스-구조와-성능)   
  * [10. 분산 데이터베이스](#10-분산-데이터베이스)   
* [SQL 기본 및 활용](#구조화-질의-언어-기본-및-활용)   
  * [1. 관계형 데이터베이스](#1-관계형-데이터베이스)   
  * [](#)   
  * [](#)   
  * [](#)   
  * [](#)   
  * [](#)   
  * [](#)   
  * [](#)   
  * [](#)   
  * [](#)   
  * [](#)   
  

# 데이터 모델링의 이해
## 1. 데이터 모델의 이해   
### 모델링의 이해   

  - __모델링 3가지 특징__   
    - 추상화: 다양한 현상을 일정한 양식인 표기법에 의해 표현   
    - 단순화: 복잡한 현실세계를 약속된 규약에 의해 제한된 표기법이나 언어로 표현하여 쉽게 이해할 수 있도록 하는 개념   
    - 명확화: 누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확(正確)하게 현상을 기술   
    
  - __모델링 3가지 관점__   
    - 데이터관점: 업무가 어떤 데이터와 관련이 있는지 또는 데이터간의 관계는 무엇인지에 대해서 모델링하는 방법(What, Data)   
    - 프로세스관점: 프로세스관점 : 업무가 실제하고 있는 일은 무엇인지 또는 무엇을 해야 하는지를 모델링하는 방법(How, Process)   
    - 데이터와 프로세스의 상관관점: 데이터와 프로세스의 상관관점 : 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링하는 방법(Interaction)   
    
  - __데이터 모델링의 중요성__   
    - 파급효과(Leverage)   
    - 복잡한 정보 요구사항의 간결한 표현(Conciseness)   
    - 데이터 품질(Data Quality)   
    
  - __데이터 모델링의 유의점__    
    - 중복(Duplication)   
    - 비유연성(Inflexibility)   
    - 비일관성(Inconsistency)   
    
  - __데이터 모델링의 3단계 진행__   
    - __개념적 데이터 모델링(Conceptual Data Modeling)___   
      - 조직, 사용자의 데이터 요구사항을 찾고 분석   
      - 전사적 데이터 모델(Enterprise Data Model)   
      - 조직의 데이터 요구를 공식화
        - 추상적
        - 데이터 요구 사항을 발견하는 것을 지원
    - __논리적 데이터 모델링(Logical Data Modeling)___   
      - 데이터베이스 설계 프로세스의 Input으로써 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현   
      - 가장 먼저 시작할 기초적인 업무조사   
      - 정규화   
      - 
    - __물리적 데이터 모델링(Physical Data Modeling)___   
      - 논리 데이터 모델이 데이터 저장소로서 어떻게 컴퓨터 하드웨어에 표현   
      - 물리적 스키마   

  - __프로젝트 생명주기(Life Cycle)에서 데이터 모델링__   
    - __Waterfall 기반___   
      - 분석과 설계단계로 구분되어 명확하게 정의   
    - __객체지향 기반___   
      - 데이터 모델링과 프로세스 모델링을 구분하지 않고 일체형   
      
  - __데이터 모델링에서 데이터독립성의 이해__   
    - __데이터 독립성의 필요성___   
      - 지속적으로 증가하는 유지보수 비용을 절감하고 데이터 복잡도를 낮추며 중복된 데이터를 줄이기 위한 목적   
      - 끊임없이 요구되는 사용자 요구사항에 대해 화면과 데이터베이스 간에 서로 독립성을 유지하기 위한 목적   
      - three-schema architecture   
        - 미국 표준 협회(ANSI) 산하의 X3 위원회(컴퓨터 및 정보 처리)의 특별연구분과위원회에서 1978년에 DBMS와 그 인터페이스를 위해 제안   
        - 각 View의 독립성을 유지하고 계층별 View에 영향을 주지 않고 변경이 가능하다.   
        - 단계별 Schema에 따라 데이터 정의어(DDL)와 데이터 조작어(DML)가 다름을 제공한다.   
      
  - __데이터베이스 3단계 구조__   
    - __외부 단계___   
    - __개념적 단계__   
    - __내부적 단계__   
    
  - __데이터독립성 요소__   
    - __외부 스키마___   
      - 사용자 관점   
      - 응용 프로그래머나 DB 각 사용자가 접근하는 DB 정의   
    - __개념적 스키마__   
      - 통합 관점   
      - 모든 사용자 관점을 통합한 조적 전체의 DB 기술   
      - 데이터와 관계 표현   
    - __내부적 스키마__   
      - 물리적 저장 관점   
      - DB가 물리적으로 저장된 형식   
      - 물리적 장치에 데이터가 실제적으로 저장되는 방법 표현   
      
  - __두 영역의 데이터 독립성__   
    - __논리적 데이터 독립성___   
      - 외부의 변경에도 개념 스키마가 변하지 않는 특징   
      - 논리작 구조가 변경되어도 응용프로그램에 영향이 없다.   
      - 사용자 특성에 맞게 변경 가능, 통합 구조 변경 가능   
    - __물리적 데이터 독립성___   
      - 내부의 변경에도 개념 스키마가 변하지 않는 특징   
      - 저장장치의 구조변경은 응용프로그램과 개념 스키마에 영향 없음   
      - 개념구조 영향없이 물리적 구조 변경 가능, 물리적 구조 영향없이 개념 구조 변경 가능   
      
  - __사상(Mapping)__   
    - 상호 독립적인 개념을 연결시켜주는 다리
    - _____   
    
  - __데이터 모델링에서 데이터독립성의 이해__   
    - __논리적 사상___   
      - 외부 화면이나 사용자에게 인터페이스하기 위한 스키마 구조는 전체가 통합된 개념적 스키마와 연결   
    - __물리적 사상___   
      - 통합된 개념적 스키마 구조와 물리적으로 저장된 구조의 물리적인 테이블스페이스와 연결   
    데이터독립성을 보장하기 위해서는 사상을 하는 스크립트(DDL)를 DBA가 필요할 때마다 변경해 주어야 한다.   
      
  - __데이터 모델링의 세 가지 요소__   
    - __엔터티___   
      - 사물이나 사건 등을 바라 볼 때 전체를 지칭하는 용어   
    - __속성__   
      - 가지고 있는 세부적인 사항   
    - __관계__   
      - 연관성   
  
  - __단수와 집합(복수)의 명명__  
    - __복수:단수__   
      - __엔터티:인스턴스/어커런스___   
      - __관계:페어링__   
      - __속성:속성값__   
    
  - __데이터 모델링의 이해관계자__   
    - __정보시스템을 구축하는 모든 사람(전문적으로 코딩만하는 사람 포함)___   
    - __IT기술에 종사하거나 전공하지 않았더라도 해당 업무에서 정보화를 추진하는 위치에 있는 사람__   
    
  - __데이터 모델 표기법__   
    - __Entity-relationship model(E-R Model)___   
      - 엔터티 - 사각형   
      - 관계 - 마름모   
      - 속성 - 타원형   
    
  - __ERD(Entity Relationship Diagram) 표기법을 이용하여 모델링하는 방법__   
    - __각 업무분석에서 도출된 엔터티와 엔터티간의 관계를 이해하기 쉽게 도식화된 다이어그램으로 표시하는 방법___   
    - __일정한 규칙을 지정하여 그림으로써 데이터 모델을 누구나 공통된 시각으로 파악할 수 있고 의사소통을 원활하게 하는 장점__   
    - __ERD 작업순서__   
      - 엔터티를 그린다   
      - 엔터티를 적절하게 배치   
      - 엔터티간 관계를 설정   
      - 관계명을 기술   
      - 관계의 참여도를 기술   
      - 관계의 필수여부를 기술   
    - __엔터티와 엔터티 사이의 관계가 있는 정보를 나타내므로 두 개를 이용하여 작성하고, 이에 따라 Primary Key와 Foreign Key를 ERD 규칙에 따라 기술__   
    - __가장 중요한 엔터티를 왼쪽상단에 배치하고 이것을 중심으로 다른 엔터티를 나열__   
    - __ERD 관계명의 표시 관계설정이 완료되면 연결된 관계에 관계이름을 부여__   
      - 현재형    
    - __ERD 관계 관계차수와 선택성 표시 관계에 대한 이름을 모두 지정하였으면 관계가 참여하는 성격 중 엔터티내에 인스턴스들이 얼마나 관계에 참여하는 지를 나타내는 관계차수(Cardinality)를 표현__   
    
  - __좋은 데이터 모델의 요소__   
    - __완전성(Completeness)___   
    - __중복배제(Non-Redundancy)___   
    - __업무규칙(Business Rules)___   
    - __데이터 재사용(Data Reusability)___   
    - __의사소통(Communication)___     
    - __통합성(Integration)___    
   
   
## 2. 엔터티    
  - __업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것__   
    - __특징__   
      - 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다.   
      - 영속적으로 존재하는 인스턴스의 집합이어야 한다.(‘한 개’가 아니라 ‘두 개 이상’)   
      - Entity는 업무 프로세스에 의해 이용되어야 한다.   
      - Entity는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.   
      - Entity는 반드시 속성이 있어야 한다.   
        - 속성(Attribute)   
          - 공통 속성   
          - 개별 속성   
      - 유일한 식별자에 의해 식별이 가능해야 한다.   

  - __Entity의 분류__   
    - __유무(有無)형에 따른 분류___   
      - __유형 Entity__   
        - 물리적인 형태가 있고 안정적이며 지속적으로 활용되는 Entity   
      - __개념 Entity__   
        - 물리적인 형태는 존재하지 않고 관리해야 할 개념적 정보   
      - __사건 Entity__   
        - 업무를 수행함에 따라 발생되는 Entity   
    - __발생시점(發生時點)에 따른 분류___   
      - __기본/키 Entity(Fundamental Entity, Key Entity)__   
        - 업무에 원래 존재하는 정보로서 다른 엔터티와 관계에 의해 생성되지 않고 독립적으로 생성이 가능하고 자신은 타 Entity의 부모의 역할을 하게 된다. 다른 Entity로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지게 된다.   
      - __중심 Entity(Main Entity)__   
        - 기본 Entity로부터 발생되고 그 업무에 있어서 중심적인 역할을 한다. 데이터의 양이 많이 발생되고 다른 Entity와의 관계를 통해 많은 행위엔터티를 생성   
      - __행위 Entity(Active Entity)__   
        - 두 개 이상의 부모 Entity로부터 발생되고 자주 내용이 바뀌거나 데이터량이 증가된다. 분석초기 단계에서는 잘 나타나지 않으며 상세 설계단계나 프로세스와 상관모델링을 진행하면서 도출   
    - __스스로 생성될 수 있는지에 따른 분류___   
      - __독립 Entity__   
      - __의존 Entity__   
      
  - __Entity의 명명__   
    - __가능하면 현업업무에서 사용하는 용어___   
    - __가능하면 약어를 사용하지 않는다__   
    - __단수명사__   
    - __모든 Entity에서 유일하게 이름이 부여__   
    - __Entity 생성의미대로 이름을 부여__   
    
## 3. 속성   

  - __업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위__   
    - __업무에서 필요로 한다.__   
    - __의미상 더 이상 분리되지 않는다.__   
    - __Entity를 설명하고 인스턴스의 구성요소가 된다.__   
    
  - __Entity, 인스턴스, 속성, 속성값의 관계__   
    - __한 개의 Entity는 두 개 이상의 인스턴스의 집합이어야 한다.__   
    - __한 개의 Entity는 두 개 이상의 속성을 갖는다.__   
    - __한 개의 속성은 한 개의 속성값을 갖는다.__   
    
  - __속성의 표기법__   
    - __속성의 표기법은 Entity 내에 이름을 포함하여 표현__   
  
  - __속성의 특징__   
    - __Entity와 마찬가지로 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다.__    
    - __정규화 이론에 근간하여 정해진 주식별자에 함수적 종속성을 가져야 한다.__   
    - __하나의 속성에는 한 개의 값만을 가진다. 하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 Entity를 이용하여 분리한다.__   
  - __속성의 분류__   
    - __속성의 특성에 따른 분류__   
      - __기본속성(Basic Attribute)__   
        - 업무분석을 통해 바로 정의한 속성   
      - __설계속성(Designed Attribute)__   
        - 원래 업무상 존재하지는 않지만 설계를 하면서 도출해내는 속성   
      - __파생속성(Derived Attribute)__   
        - 다른 속성으로부터 계산이나 변형이 되어 생성되는 속성   
        
    - __Entity 구성방식에 따른 분류__   
      - __PK(Primary Key)속성__   
        - Entity를 식별할 수 있는 속성   
      - __FK(Foreign Key)속성__   
        - 다른 Entity와의 관계에서 포함된 속성   
      - __일반속성__   
        - 엔터티에 포함되어 있고 PK, FK에 포함되지 않은 속성   
      - __세부 의미를 쪼갤 수 있는지에 따른 분류__   
        - 복합 속성(Composite Attribute)   
          - 여러 세부 속성들로 구성   
        - 단순 속성(Simple Attribute)   
          - 더 이상 다른 속성들로 구성될 수 없는 단순한 속성   
      - __단일값 속성__   
        - 속성 하나에 한 개의 값을 가지는 경우   
      - __다중값 속성__   
        - 속성 하나에 여러 개의 값을 가지는 경우   
  - __도메인(Domain)__   
    - __각 속성은 가질 수 있는 값의 범위__   
    
  - __속성의 명명(Naming)fffff__   
    - __현업에서 사용하는 이름을 부여하는 것이 가장 중요하다.__   
    - __명사형을 이용__   
    - __약어는 사용하지 않는 것이 좋다.__   
    - __가능하면 모든 속성의 이름은 유일하게 작성하는 것이 좋다.__   
       
       
## 4. 관계   
  - __엔터티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태__   
    
  - __관계의 페어링__   
    - __각각의 엔터티의 인스턴스들은 자신이 관련된 인스턴스들과 관계의 어커런스로 참여하는 형태__   
    
  - __관계의 분류__   
    - __존재에 의한 관계__   
    - __행위에 의한 관계__    
    - __UML(Unified Modeling Language)에는 클래스다이어그램__   
      - __연관관계(Association)__   
        - 항상 이용하는 관계로 존재적 관계   
      - __의존관계(Dependency)__   
        - 상대방 클래스의 행위에 의해 관계가 형성   
    
  - __관계의 표기법__   
    - __관계명(Membership)__   
      - 관계의 이름   
      - 관계시작점(The Beginning)   
        - 엔터티에서 관계가 시작되는 편   
      - 관계끝점(The End)   
        - 엔터티에서 관계를 받는 편   
      - 애매한 동사를 피한다.   
      - 현재형으로 표현   
      
    - __관계차수(Cardinality)__   
      - 1:1, 1:M, M:N   
      
    - __관계선택사양(Optionality)__   
      - 필수관계, 선택관계   
    
  - __관계의 정의 및 읽는 방법__        
    - __관계 체크사항__        
      - 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?   
      - 두 개의 엔터티 사이에 정보의 조합이 발생되는가?    
      - 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?    
      - 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가?     

    - __관계 읽기__       
      - 기준(Source) 엔터티를 한 개(One) 또는 각(Each)으로 읽는다.   
      - 대상(Target) 엔터티의 관계참여도 즉 개수(하나, 하나 이상)를 읽는다.   
      - 관계선택사양과 관계명을 읽는다.   

## 5. 식별자   
  - __하나의 엔터티에 구성되어 있는 여러 개의 속성 중에 엔터티를 대표할 수 있는 속성을 의미하며 하나의 엔터티는 반드시 하나의 유일한 식별자가 존재해야 한다.__            
    
  - __식별자의 특징__        
    - 주식별자에 의해 엔터티내에 모든 인스턴스들이 유일하게 구분되어야 한다.        
    - 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어    
    - 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.   
    - 주식별자가 지정이 되면 반드시 값이 들어와야 한다.   

  - __식별자 분류 및 표기법__   
    - __식별자 분류__   
      - 자신의 엔터티 내에서 대표성을 가지는가에 따라 주식별자(Primary Identifier)와 보조식별자(Alternate Identifier)   
      - 엔터티 내에서 스스로 생성되었는지 여부에 따라 내부식별자와 외부식별자(Foreign Identifier)   
      - 단일 속성으로 식별이 되는가에 따라 단일식별자(Single Identifier)와 복합식별자(Composit Identifier)   
      - 의미가 있던 식별자 속성을 대체하여 일련번호와 같이 새롭게 만든 식별자를 구분하기 위해 본질식별자와 인조식별자   
      
    - __주식별자 도출기준__    
      - 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.   
      - 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않는다.   
      - 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다.   
      
  - __식별자관계와 비식별자관계에 따른 식별자__   
  
    - __식별자관계와 비식별자 관계의 결정__   
      - 외부식별자(Foreign Identifier)는 자기 자신의 엔터티에서 필요한 속성이 아니라 다른 엔터티와의 관계를 통해 자식 쪽에 엔터티에 생성되는 속성을 외부식별자라 하며 데이터베이스 생성 시에 Foreign Key역할   
      
    - __식별자관계__   
      - 자식엔터티의 주식별자로 부모의 주식별자가 상속이 되는 경우   
      - 부모로부터 받은 식별자를 자식엔터티의 주식별자로 이용하는 경우는 Null값이 오면 안되므로 반드시 부모엔터티가 생성되어야 자기 자신의 엔터티가 생성되는 경우   
      
    - __비식별자관계__   
      - 부모엔터티로부터 속성을 받았지만 자식엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용하는 경우   
      
    - __식별자 관계로만 설정할 경우의 문제점__   
      - 주식별자 속성이 지속적으로 증가할 수 밖에 없는 구조로서 개발자 복잡성과 오류가능성을 유발시킬 수 있는 요인이 될 수 있다   
     
    - __비식별자 관계로만 설정할 경우의 문제점__   
      - SQL구문에 많은 조인이 걸리게 되고 그에 따라 복잡성이 증가하고 성능이 저하   
      
    - __식별자관계와 비식별자관계 모델링__   
      - 비식별자관계 선택 프로세스   
      - 식별자와 비식별자관계 비교   
      - 식별자와 비식별자를 적용한 데이터 모델   
      
## 5. 성능 데이터 모델링   

  - __데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것__            
    
  - __성능 데이터 모델링 고려사항__        
    - __데이터 모델링을 할 때 정규화를 정확하게 수행한다.__        
    - __데이터베이스 용량산정을 수행한다.__        
    - __데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.__        
    - __용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.__     
    - __이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.__        
    - __성능관점에서 데이터 모델을 검증한다.__     
       
       
## 6. 정규화   
  
  - __데이터의 중복속성을 제거하고 결정자에 의해 동일한 의미의 일반속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과__        
  - __정규화 수행 모델은 데이터를 입력/수정/삭제할 때 일반적으로 반정규화된 테이블에 비해 처리 성능이 향상된다. 단 데이터를 조회할 때에는 처리 조건에 따라 조회 성능이 향상될 수도 있고 저하될 수도 있다.__        
       
  - __반정규화만이 조회 성능을 향상시킨다는 고정관념은 탈피되어야 한다.__   
    - __반정규화된 테이블의 성능저하가 있을 수 있다.__   
    
  - __함수적 종속성(Functional Dependency)에 근거한 정규화 수행 필요__   
    - __함수의 종속성(Functional Dependency)
      - 데이터들이 어떤 기준값에 의해 종속되는 현상
    - __결정자(Determinant)__   
      - 기준값   
    - __종속자(Dependent)__   
      - 종속되는 값   
  - __정규화가 잘 정의된 데이터 모델에서 성능이 저하될 수 있는 경우가 있다.__    
  
      
## 7. 반정규화  

  - __정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발(Development)과 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법__        
  
    - __반정규화를 적용하는 이유__        
      - 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능저하가 예상되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.   
      - 업무적으로 조회에 대한 처리성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려   
      - 함수적 종속관계는 위반하지 않지만 데이터의 중복성을 증가시켜야만 데이터조회의 성능을 향상시키는 경우    
    
  - __반정규화의 적용방법__        
  
    - __보통 프로젝트에서는 칼럼 중복을 통해서만 반정규화를 수행__        
      - __칼럼의 반정규화가 많은 이유__   
        - 개발을 하다가 SQL문장 작성이 복잡해지고 그에 따라 SQL단위 성능 저하가 예상이 되어 다른 테이블에서 조인하여 가져와야 할 칼럼을 기준이 되는 테이블에 중복하여 SQL문장을 단순하게 처리하도록 하기 위해 요청    
        - 데이터에 대한 무결성을 깨뜨리는 결정적인 역할을 하는 경우가 많이 있다.   
        
    - __반정규화의 대상을 조사한다.__        
      - 자주 사용되는 테이블에 접근(Access)하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하는 경우에 반정규화를 검토한다.   
      - 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없을 경우에 반정규화를 검토한다.   
      - 통계성 프로세스에 의해 통계 정보를 필요로 할 때 별도의 통계테이블(반정규화 테이블)을 생성한다.   
      - 테이블에 지나치게 많은 조인(JOIN)이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 반정규화를 검토한다.   
      
    - __반정규화의 대상에 대해 다른 방법으로 처리할 수 있는지 검토한다.__   
      - 지나치게 많은 조인(JOIN)이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 뷰(VIEW)를 사용하면 이를 해결할 수도 있다.   
      - 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우에 클러스터링을 적용하거나 인덱스를 조정함으로써 성능을 향상시킬 수 있다.   
        - 클러스터링을 적용하는 방법   
          - 대량의 데이터를 특정 클러스터링 팩트에 의해 저장방식을 다르게 하는 방법   
            - 데이터를 입력/수정/삭제하는 경우 성능이 많이 저하되므로 조회중심의 테이블이 아니라면 생성하면 안되는 오브젝트   
            - 다만, 조회가 대부분이고 인덱스를 통해 성능향상이 불가능하다면 클러스터링을 고려할 만하다.   
      - 인덱스를 통해 성능을 충분히 확보할 수 있다면 인덱스를 조정하여 반정규화를 회피   
      - 물리적인 저장기법에 따라 성능을 향상시킬 수 있는 파티셔닝 기법(Partitioning)이 적용되어 성능저하를 방지할 수 있다.   
        - 대량의 데이터는 Primary Key의 성격에 따라 부분적인 테이블로 분리할 수 있다.   
        - 데이터가 특정 기준(파티셔닝 키)에 의해 다르게 저장되고 파티셔닝 키에 따른 조회가 될 때 성능이 좋아지는 특성이 있다.   
        - 따라서 특정 기준에 의해 물리적인 저장공간이 구분될 수 있고 트랜잭션이 들어올 때 일정한 기준에 의해 들어온다면 파티셔닝 테이블을 적용하여 조회의 성능을 향상시키는 것도 좋은 방법이 될 수 있다.   
      - 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.   
        - 응용 메모리 영역에 데이터를 처리하기 위한 값을 캐쉬한다든지 중간 클래스 영역에 데이터를 캐쉬하여 공유하게 하여 성능을 향상 시키는 것도 성능을 향상   
        
    - __반정규화를 적용한다.__   
      - 반정규화를 적용하기 이전에 사전에 충분히 성능에 대한 고려가 이루어져서 반정규화를 적용해야겠다는 판단이 들었다면 이 때 반정규화의 세 가지 규칙을 고려하여 반정규화를 적용   
      - 반정규화의 기법   
        - 테이블 반정규화   
        - 칼럼 반정규화   
        - 관계 반정규화   
      - 테이블과 칼럼의 반정규화는 데이터 무결성에 영향을 미치게 되나 관계의 반정규화는 데이터 무결성을 깨뜨릴 위험을 갖지 않고서도 데이터처리의 성능을 향상시킬 수 있는 반정규화의 기법이 된다.   
      - 데이터 모델 전체가 관계로 연결되어 있고 관계가 서로 먼 친척간에 조인관계가 빈번하게 되어 성능저하가 예상이 된다면 관계의 반정규화를 통해 성능향상을 도모할 필요가 있다.   

  - __반정규화를 적용할 때 기억해야 할 내용은 데이터를 입력, 수정, 삭제할 때는 성능이 떨어지는 점을 기억해야 하고 데이터의 무결성 유지에 주의를 해야 한다.__   
  
## 8. 대량 데이터    

  - __한 테이블에 데이터가 대량으로 집중되거나 하나의 테이블에 여러 개의 칼럼이 존재하여 디스크에 많은 블록을 점유하는 경우는 모두 성능저하를 유발할 수 있는 경우__   
  
    - 하나의 테이블에 대량의 데이터가 존재하는 경우에는 인덱스의 Tree구조가 너무 커져 효율성이 떨어져 데이터를 처리(입력, 수정, 삭제, 조회)할 때 디스크 I/O를 많이 유발하게 된다.   
    - 한 테이블에 많은 수의 칼럼이 존재하게 되면 데이터가 디스크의 여러 블록에 존재하므로 인해 디스크에서 데이터를 읽는 I/O량이 많아지게 되어 성능이 저하되게 된다.   
      -  데이터를 처리할 때 여러 블록에서 데이터를 I/O해야 하는 즉 SQL문장의 성능이 저하될 수 특징을 가지게 된다.   
    
  - __대량의 데이터가 처리되는 테이블에 성능이 저하되는 이유__        
  
    - __SQL문장에서 데이터를 처리하기 위한 I/O의 양이 증가하기 때문이다.__        
    
    - __대량의 데이터가 하나의 테이블에 존재하게 되면 인덱스를 생성할 때 인덱스의 크기(용량)가 커지게 되고 그렇게 되면 인덱스를 찾아가는 단계가 깊어지게 되어 조회의 성능에도 영향을 미치게 된다.__   
      - 인덱스 크기가 커질 경우 조회의 성능에는 영향을 미치는 정도가 작지만 데이터를 입력/수정/삭제하는 트랜잭션의 경우 인덱스의 특성상 일량이 증가하여 더 많이 성능의 저하를 유발하게 된다.   
      - 또한 데이터에 대한 범위 조회시 더 많은 I/O 유발할 수 있게 되어 성능저하를 유발할 수 있게 된다.   
      
    - __로우체이닝(Row Chaining) 현상__    
      - 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태  
      
    - __로우마이그레이션(Row Migration)__    
      - 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식  
      
    - __로우체이닝과 로우마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 데이터베이스 메모리에서 디스크와 I/O(입력/출력)가 발생할 때 불필요하게 I/O가 많이 발생하여 성능이 저하된다.__   
    
  - __테이블에 많은 양의 데이터가 예상될 경우 파티셔닝을 적용하거나 PK에 의해 테이블을 분할하는 방법을 적용할 수 있다.__    
    - 데이터량이 몇 천만건을 넘어서면 아무리 서버사양이 훌륭하고 인덱스를 잘 생성해준다고 하더라고 SQL문장의 성능이 나오지 않는다. 이 때는 논리적으로는 하나의 테이블로 보이지만 물리적으로 여러 개의 테이블스페이스에 쪼개어 저장될 수 있는 구조의 파티셔닝을 적용하도록 한다.   
    - __RANGE PARTITION(범위) 적용__    
      - 대상 테이블이 날자 또는 숫자값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리된다면 RANGE PARTITION을 적용   
      - 데이터보관주기에 따라 테이블에 데이터를 쉽게 지우는 것이 가능하므로(파티션 테이블을 DROP하면 되므로) 데이터보관주기에 다른 테이블관리가 용이하다.   
    - __LIST PARTITION(특정값 지정) 적용__   
      - PK가 구성되어 있고 대량의 데이터가 있는 테이블이라면 값 각각에 의해 파티셔닝이 되는 LIST PARTITION을 적용할 수 있다.   
      - 대용량 데이터를 특정값에 따라 분리 저장할 수는 있으나 RANGE PARTITION과 같이 데이터 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없다.   
    - __HASH PARTITION(해쉬적용)__   
      - 지정된 HASH 조건에 따라 해슁 알고리즘이 적용되어 테이블이 분리되며 설계자는 테이블에 데이터가 정확하게 어떻게 들어갔는지 알 수 없다. 역시 성능향상을 위해 사용하며 데이터 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없다.   
    - __COMPOSITE PARTITION(범위와 해쉬가 복합)__    
    
    
  - __테이블에 대한 수평분할/수직분할의 절차__        
    - __4가지 원칙__        
      - __데이터 모델링을 완성한다.__   
      - __데이터베이스 용량산정을 한다.__        
      - __대량 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴을 분석한다.__   
      - __칼럼 단위로 집중화된 처리가 발생하는지, 로우단위로 집중화된 처리가 발생되는지 분석하여 집중화된 단위로 테이블을 분리하는 것을 검토한다.__       
    - 칼럼의 수가 많은 경우 트랜잭션의 특성에 따라 테이블을 1:1 형태로 분리할 수 있는지 검증하면 된다.   
    - 칼럼의 수가 적지만 데이터용량이 많아 성능저하가 예상이 되는 경우 테이블에 대해 파티셔닝 전략을 고려하도록 한다.   
    
## 9. 데이터베이스 구조와 성능       
    
  - __슈퍼/서브타입 데이터 모델의 개요__     
    - __Extended ER모델__        
      - 데이터의 특징을 공통과 차이점의 특징을 고려하여 효과적으로 표현할 수 있어 자주 쓰인다.   
      - 즉, 공통의 부분을 슈퍼타입으로 모델링하고 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성에 대해서는 별도의 서브엔터티로 구분하여 업무의 모습을 정확하게 표현하면서 물리적인 데이터 모델로 변환을 할 때 선택의 폭을 넓힐 수 있는 장점   
      - 논리적인 데이터 모델에서 이용되는 형태이고 분석/설계단계를 구분하자면, 분석단계에서 많이 쓰이는 모델   
      - 따라서 물리적인 데이터 모델을 설계하는 단계에서는 슈퍼/서브타입 데이터 모델을 일정한 기준에 의해 변환을 해야 한다.    
    
  - __슈퍼/서브타입 데이터 모델의 변환__        
    - __슈퍼/서브타입에 대한 변환을 잘못하면 성능이 저하되는 이유__        
      - 트랜잭션 특성을 고려하지 않고 테이블이 설계되었기 때문이다.   
        - 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union연산에 의해 성능이 저하될 수 있다.   
        - 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터가 집약되어 있어 성능이 저하되는 경우가 있다.   
        - 트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능이 저하되는 경우가 있다.   
    - __슈퍼/서브타입을 성능을 고려한 물리적인 데이터 모델로 변환하는 기준은 데이터 양과 해당 테이블에 발생되는 트랜잭션의 유형에 따라 결정된다.__   
    - __데이터량에 따른 변형__   
      - 소량일 경우 성능에 영향을 미치지 않기 때문에 데이터처리의 유연성을 고려하여 가급적 1:1 관계를 유지하는 것이 바람직하다.    
      - 데이터용량이 많아지는 경우 그리고 해당 업무적인 특징이 성능에 민감한 경우는 트랜잭션이 해당 테이블에 어떻게 발생되는지에 따라 3가지 변환방법을 참조하여 상황에 맞게 변환하도록 해야 한다.   
    
  - __슈퍼/서브 타입 데이터 모델의 변환기술__        
    - __개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성__        
      - 슈퍼타입과 서브타입각각에 대해 독립적으로 트랜잭션이 발생이 되면 슈퍼타입에도 꼭 필요한 속성만을 가지게 하고 서브타입에도 꼭 필요한 속성 및 자신이 타입에 맞는 데이터만 가지게 하기 위해서 모두 분리하여 1:1 관계를 갖도록 한다.    
    - __슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성__        
      - 슈퍼타입과 서브타입을 묶어 트랜잭션이 발생하는 업무특징을 가지고 있을 때에는 다음 데이터 모델과 같이 슈퍼타입+각서브타입을 하나로 묶어 별도의 테이블로 구성하는 것이 효율적이다.   
    - __전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성__   
      - 슈퍼타입과 서브타입의 테이블들을 하나로 묶었을 때 각각의 속성별로 제약사항(NULL/NOT NULL, 기본값, 체크값)을 정확하게 지정하지 못할지라도 대용량이고 성능향상이 필요하다면 하나의 테이블로 묶어서 만들어 준다.   
      
  - __인덱스 특성을 고려한 PK/FK 데이터베이스 성능향상__        
    - __인덱스__        
      - PK/FK 칼럼 순서와 성능개요 데이터를 조회할 때 가장 효과적으로 처리될 수 있도록 접근경로를 제공하는 오브젝트   
      - 데이터베이스 테이블에서는 균형 잡힌 트리구조의 B*Tree구조를 많이 사용한다.   
      - 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다.   
      - 앞쪽에 위치한 속성 값이 가급적 ‘=’ 아니면 최소한 범위 ‘BETWEEN’ ‘< >’가 들어와야 인덱스를 이용할 수 있는 것이다.   

    - __설계단계 말에 칼럼의 순서를 조정할 필요가 있다.__        
    - __PK__        
      - 해당테이블의 데이터를 접근하는 가장 빈번하게 사용되는 유일한 인덱스(Unique Index)를 모두 자동 생성한다.   
      - PK순서를 결정하는 기준은 인덱스 정렬구조를 이해한 상태에서 인덱스를 효율적으로 이용할 수 있도록 PK순서를 지정해야 한다.   
    - __FK__   
      - 데이터를 조회할 때 조인의 경로를 제공하는 역할을 수행   
      - FK에 대해서는 반드시 인덱스를 생성하도록 하고 인덱스 칼럼의 순서도 조회의 조건을 고려하여 접근이 가장 효율적인 칼럼 순서대로 인덱스를 생성하도록 주의해야 한다.   
    - __PK/FK설계는 업무적 의미로도 매우 중요한 의미를 가지고 있지만 데이터를 접근할 때 경로를 제공하는 성능의 측면에서도 중요한 의미를 가지고 있기 때문에 성능을 고려한 데이터베이스 설계가 될 수 있도록 설계단계 말에 칼럼의 순서를 조정할 필요가 있다.__   
    - __PK칼럼의 순서를 조정하지 않으면 성능이 저하 이유__        
      - 데이터 모델링에서 엔터티를 설계하면 그에 따라 DDL이 생성이 되고 생성된 DDL에 따라 인덱스가 생성된다.   
      - 인덱스의 정렬된 첫 번째 칼럼에 비교가 되었을 때 순차적으로 데이터를 찾아가게 된다.   
      - 맨 앞에 있는 칼럼이 제외된 상태에서 데이터를 조회 할 경우 데이터를 비교하는 범위가 매우 넓어지게 되어 성능 저하를 유발하게 된다.   
        - 인덱스를 읽고 테이블 블록에서 읽어 처리하는데 I/O가 많이 발생하게 되므로 옵티마이저는 차라리 테이블에 가서 전체를 읽는 방식으로 처리하게 된다.   
    - __PK의 순서를 인덱스 특징에 맞게 고려하지 않고 바로 그대로 생성하게 되면, 테이블에 접근하는 트랜잭션의 특징에 효율적이지 않은 인덱스가 생성되어 있으므로 인덱스의 범위를 넓게 이용하거나 Full Scan을 유발하게 되어 성능이 저하된다고 정리할 수 있다.__   
      - PK순서를 잘못 지정하여 성능이 저하된 경우   
      - 물리적인 테이블에 FK제약이 걸려있지 않을 경우 인덱스 미생성으로 성능저하   
      
      
## 10. 분산 데이터베이스   

  - __정의__        
    - __여러 곳으로 분산되어있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스__        
    - __논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임. 물리적 Site 분산, 논리적으로 사용자 통합·공유__        
    - __즉, 분산 데이터베이스는 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역 여러 노드로 위치시켜 사용성/성능 등을 극대화 시킨 데이터베이스__    
    
  - __분산 데이터베이스의 6가지 투명성(Transparency)__        
    - __분할 투명성 (단편화)__        
      - 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장   
    - __위치 투명성__        
      - 사용하려는 데이터의 저장 장소 명시 불필요. 위치정보가 System Catalog에 유지되어야 함   
    - __지역사상 투명성__        
      - 지역DBMS와 물리적 DB사이의 Mapping 보장. 각 지역시스템 이름과 무관한 이름 사용 가능   
    - __중복 투명성__        
      - DB 객체가 여러 site에 중복 되어 있는지 알 필요가 없는 성질   
    - __장애 투명성__        
      - 구성요소(DBMS, Computer)의 장애에 무관한 Transaction의 원자성 유지   
    - __병행 투명성__        
      - 다수 Transaction 동시 수행시 결과의 일관성 유지, Time Stamp, 분산 2단계 Locking을 이용 구현   
    
  - __데이터베이스 분산구성의 가치__        
    - __통합된 데이터베이스에서 제공할 수 없는 빠른 성능을 제공__        
    
  - __분산 데이터베이스의 적용 기법__        
  
    - __테이블 위치 분산__        
      - 테이블 위치 분산은 테이블의 구조는 변하지 않는다. 또한 테이블이 다른 데이터베이스에 중복되어 생성되지도 않는다. 다만 설계된 테이블의 위치를 각각 다르게 위치시키는 것이다   
      - 테이블별 위치 분산은 정보를 이용하는 형태가 각 위치별로 차이가 있을 경우에 이용한다.   
      - 테이블의 위치가 위치별로 다르므로 테이블의 위치를 파악할 수 있는 도식화된 위치별 데이터베이스 문서가 필요하다.   
      
    - __테이블 분할(Fragmentation) 분산__        
    
      - 단순히 위치만 다른 곳에 두는 것이 아니라 각각의 테이블을 쪼개어 분산하는 방법   
      - 분살하는 방법 2가지   
        - __로우(Row)단위로 분리하는 수평분할(Horizontal Fragmentation)__   
          - 지사(Node)에 따라 테이블을 특정 칼럼의 값을 기준으로 로우(Row)를 분리한다. 칼럼은 분리되지 않는다. 모든 데이터가 각 지사별로 분리되어 있는 형태를 가지고 있다.   
          - 각 지사에 존재하는 테이블에 대해서 통합처리를 해야 하는 경우는 조인(JOIN)이 발생하여 성능 저하가 예상되므로 통합처리 프로세스가 많은지를 먼저 검토한 이후에 많지 않은 경우에 수평분할을 해야 한다.   
          - 데이터가 지사별로 별도로 존재하므로 중복은 발생하지 않는다. -> 무결성 보장   
          
        - __칼럼(Column) 단위로 분할하는 수직분할(Vertical Fragmentation)__   
          - 지사(Node)에 따라 테이블 칼럼을 기준으로 칼럼(Row)을 분리한다. 로우(Row) 단위로는 분리되지 않는다. 모든 데이터가 각 지사별로 분리되어 있는 형태를 가지고 있다.   
          - 지사별로 쪼개어진 테이블들을 조합하면 Primary Key가 동일한 데이터의 조합이 가능해야 하며 하나의 완전한 테이블이 구성되어야 한다.   
          - 칼럼을 기준으로 분할하였기 때문에 각각의 테이블에는 동일한 Primary Key구조와 값을 가지고 있어야 한다.   
          - 테이블의 전체 칼럼 데이터를 보기 위해서는 각 지사(Node)별로 흩어져 있는 테이블들을 조인(JOIN)하여 가져와야 하므로 가능하면 통합하여 처리하는 프로세스가 많은 경우에는 이용하지 않도록 한다.   
          
    - __테이블 복제(Replication) 분산__        
      - 가장 많이 사용   
      - 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형   
      
      - __부분복제(Segment Replication)__    
        - 마스터 데이터베이스에서 테이블의 일부의 내용만 다른 지역이나 서버에 위치   
        - 통합된 테이블을 한군데(본사)에 가지고 있으면서 각 지사별로는 지사에 해당된 로우(Row)를 가지고 있는 형태   
        - 각 지사에서 데이터 처리가 용이할 뿐만 아니라 전체 데이터에 대한 통합처리도 본사에 있는 통합 테이블을 이용하게 되므로 여러 테이블에 조인(JOIN)이 발생하지 않는 빠른 작업 수행이 가능해진다.   
        - 보통 지사에 데이터가 먼저 발생하고 본사에 데이터는 지사에 데이터를 이용하여 통합하여 발생된다.   
          - 지사에서 데이터에 대한 입력, 수정, 삭제가 발생하여 본사에서 이용하는 방식   
        - 다른 지역간의 데이터를 복제(Replication)하는데 많은 시간이 소요되고 데이터베이스와 서버에 부하(Load)가 발생하므로 보통 실시간(On-Line) 처리에 의해 복사하는 것보다는 야간에 배치 작업에 의해 수행되는 경우가 많이 있다.   
        - 본사와 지사 양쪽 모두 데이터를 수정하여 전송하는 경우 데이터의 정합성을 일치시키는 것이 어렵기 때문에 가능하면 한쪽(지사)에서 데이터의 수정이 발생하여 본사로 복제(Replication)를 하도록 한다.   
        
      - __광역복제(Broadcast Replication)__   
        - 마스터 데이터베이스의 테이블의 내용을 각 지역이나 서버에 존재   
        - 통합된 테이블을 한군데(본사)에 가지고 있으면서 각 지사에도 본사와 동일한 데이터를 모두 가지고 있는 형태   
        - 본사에서는 데이터를 관리하고 지사에서는 이 데이터를 읽어 업무프로세스를 발생시키는 것이다.   
          -  본사에서 데이터가 입력, 수정, 삭제가 되어 지사에서 이용하는 형태   
        - 데이터를 복제(Replication)하는데 많은 시간이 소요되고 데이터베이스와 서버에 부하(Load)가 발생하므로 보통 실시간(On-Line) 처리에 의해 복사하는 것보다는 야간에 배치에 의해 복제가 되도록 한다.   
        
    - __테이블 요약(Summarization) 분산__    
      - 지역간에 또는 서버 간에 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우   
      - 분석요약(Rollup Summarization)   
        - 동일한 테이블 구조를 가지고 있으면서 분산되어 있는 동일한 내용의 데이터를 이용하여 통합된 데이터를 산출   
        - 각 지사별로 존재하는 요약정보를 본사에 통합하여 다시 전체에 대해서 요약정보를 산출하는 분산방법   
        - 테이블에 있는 모든 칼럼(Column)과 로우(Row)가 지사에도 동일하게 존재하지만, 각 지사에는 동일한 내용에 대해 지사별로 요약되어 있는 정보를 가지고 있고 본사에는 각 지사의 요약정보를 통합하여 재산출하여 전체에 대한 요약정보를 가지고 있는 것   
        - 각종 통계데이터를 산정할 경우에, 모든 지사의 데이터를 이용하여 처리하면 성능이 지연되고 각 지사 서버에 부하를 주기 때문에 업무에 장애가 발생할 수 있다.   
        - 통합 통계데이터에 대한 정보제공에 용이한 분산방법    
        - 본사에 분석 요약된 테이블을 생성하고 데이터는 역시 일반 업무가 종료되는 야간에 수행하여 생성한다.   

      - 통합요약(Consolidation Summarization)   
        - 분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출   
        - 각 지사별로 존재하는 다른 내용의 정보를 본사에 통합하여 다시 전체에 대해서 요약정보를 산출하는 분산방법   
        - 테이블에 있는 모든 칼럼(Column)과 로우(Row)가 지사에도 동일하게 존재하지만 각 지사에는 타지사와 다른 요약정보를 가지고 있고 본사에는 각 지사의 요약정보를 데이터를 같은 위치에 두는 것으로 통합하여 전체에 대한 요약정보를 가지고 있는 것    
        - 지사에서 요약한 정보를 본사에서 취합하여 각 지사별로 데이터를 비교하기 위해 이용되는 것   
        - 각종 통계데이터를 산정할 경우에, 모든 지사의 데이터를 조인하여 처리하면 성능이 지연되고 각 지사 서버에 부하(LOAD)를 주기 때문에 업무에 장애가 발생할 수 있다.   
        - 통합 통계데이터에 대한 정보제공에 용이한 분산방법   
        - 본사에 통합 요약된 테이블을 생성하고 데이터는 역시 일반 업무가 종료되는 야간에 수행하여 생성   
        
  - __분산 데이터베이스를 적용해야 하는 경우__        
    - __성능이 중요한 사이트에 적용해야 한다.__        
    - __공통코드, 기준정보, 마스터 데이터 등에 대해 분산환경을 구성하면 성능이 좋아진다.__        
    - __실시간 동기화가 요구되지 않을 때 좋다. 거의 실시간(Near Real Time)의 업무적인 특징을 가지고 있을 때도 분산 환경을 구성할 수 있다__   
    - __특정 서버에 부하가 집중이 될 때 부하를 분산할 때도 좋다.__   
    - __백업 사이트(Disaster Recovery Site)를 구성할 때 간단하게 분산기능을 적용하여 구성할 수 있다.__   
    
    
# 구조화 질의 언어 기본 및 활용      
## 1. 관계형 데이터베이스   
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
  - ____        
    - ____        
    - ____        
    
  - ____        
    - ____        
    - ____        
